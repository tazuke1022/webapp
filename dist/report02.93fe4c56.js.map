{"mappings":"A,S,E,C,C,C,C,C,C,C,E,O,c,C,E,E,C,I,E,I,E,W,C,E,a,C,C,E,C,I,E,W,E,C,E,E,C,E,E,E,iB,A,O,I,A,C,E,S,C,E,G,K,E,O,C,C,E,C,O,C,G,K,E,C,I,E,C,C,E,A,Q,C,C,E,C,I,E,C,G,E,Q,C,C,E,O,C,C,E,C,E,E,I,C,E,O,C,E,E,O,E,E,O,A,C,I,E,A,M,uB,E,I,O,E,I,C,mB,C,C,E,Q,C,S,C,C,C,E,C,C,E,C,C,E,E,iB,C,G,I,E,E,Q,C,E,Q,S,C,C,C,E,E,E,O,C,gB,I,G,E,E,O,C,a,I,G,I,E,E,S,E,E,S,E,E,S,E,E,SCoBO,IAAM,EAAgB,AAAA,CAAA,EAAA,EAAA,aAAY,AAAZ,IAGhB,EAAa,AAAC,IACzB,IAAM,EAAY,AAAA,CAAA,EAAA,EAAA,MAAK,AAAL,EAAO,MACnB,CAAC,EAAW,EAAa,CAAG,AAAA,CAAA,EAAA,EAAA,QAAO,AAAP,EAAS,CAAA,GACrC,CAAC,EAAc,EAAgB,CAAG,AAAA,CAAA,EAAA,EAAA,QAAO,AAAP,EAAS,IAG3C,EAAO,AAAA,CAAA,EAAA,EAAA,UAAS,AAAT,EAAW,EAAA,YAAW,EAE7B,EAAa,KAEjB,IAAM,EAAa,EACjB,CAAE,KAAM,CAAE,MAAO,EAAK,KAAK,CAAE,SAAU,EAAK,QAAQ,AAAC,CAAE,EAAI,CAAC,EAC9D,GAAK,EAAU,OAAO,CAuBpB,EAAgB,IAChB,EAAU,OAAO,CAAC,OAAO,OAxBH,CACtB,IAAM,EAAS,AAAA,CAAA,EAAA,EAAA,EAAC,AAAD,EAAG,EAAM,GAAG,CAAE,CAC3B,aAAc,CAAA,EACd,GAAG,CAAU,AACf,GACA,EAAO,EAAE,CAAC,UAAW,KACnB,EAAa,CAAA,EACf,GACA,EAAO,EAAE,CAAC,QAAS,AAAC,IAClB,EAAgB,EAAM,OAAO,CAC/B,GACA,EAAO,EAAE,CAAC,gBAAiB,AAAC,IAC1B,EAAgB,EAAM,OAAO,CAC/B,GACA,EAAO,EAAE,CAAC,kBAAmB,AAAC,IAC5B,EAAgB,EAAM,OAAO,CAC/B,GACA,EAAO,EAAE,CAAC,aAAc,AAAC,IACvB,EAAgB,CAAC,cAAc,EAAE,EAAO,CAAC,CAAC,EAC1C,EAAa,CAAA,EACf,GACA,EAAU,OAAO,CAAG,CACtB,CAIF,EAEM,EAAc,KACd,EAAU,OAAO,EACnB,EAAU,OAAO,CAAC,KAAK,EAE3B,QAIA,AAAA,CAAA,EAAA,EAAA,SAAQ,AAAR,EAAU,KACH,GACH,IAEK,KACL,GACF,GAGC,EAAE,EAYH,AAAA,CAAA,EAAA,EAAA,IAAA,AAAA,EAAC,MADH,CACO,UAAU,c,S,CACb,AAAA,CAAA,EAAA,EAAA,IAAA,AAAA,EAAC,MAAD,CAAK,UAAU,sB,S,CACb,AAAA,CAAA,EAAA,EAAA,IAAA,AAAA,EAAC,OAAD,CAAM,UAAY,EAAY,GAAK,2B,S,CAA6B,cAAY,EAAM,GAAG,C,A,GACrF,AAAA,CAAA,EAAA,EAAA,GAAA,AAAA,EAAC,SAAD,CAAQ,KAAK,SAAS,QAZA,KACtB,EACF,IAEA,GAEJ,EAOS,SAAA,EAAY,KAAO,I,G,A,GAGvB,EAEC,AAAA,CAAA,EAAA,EAAA,GAAA,AAAA,EAAC,EAAc,QAAQ,CAAvB,CAAwB,MAAO,EAC5B,SAAA,EAAM,QAAQ,AAGjB,GACA,AAAA,CAAA,EAAA,EAAA,GAAA,AAAA,EAAC,MAAD,CAAK,SAAA,AAAA,CAAA,EAAA,EAAA,GAAA,AAAA,EAAC,OAAD,CAAM,UAAU,2BAA2B,SAAA,W,E,GAEjD,AAAiB,KAAjB,EAAsB,KACrB,AAAA,CAAA,EAAA,EAAA,GAAA,AAAA,EAAC,MADF,CACM,UAAU,gBACb,QAAS,IAAM,EAAgB,IAAM,SAAA,C,G,A,EAG/C,C,G,E,Q,S,C,C,C,M,C,C,E,O,C,E,W,S,E,C,E,M,A,C,E,Y,O,Q,U,O,O,Q,C,S,C,E,O,O,C,E,S,C,E,O,G,Y,O,Q,E,W,G,Q,I,O,S,C,S,O,C,C,E,E,C,S,E,C,C,C,E,G,C,C,a,C,E,M,A,U,oC,C,S,E,C,C,C,E,I,I,E,E,E,E,M,C,I,C,I,E,C,C,E,A,C,E,U,C,E,U,E,C,E,E,Y,C,C,E,U,G,C,E,Q,C,C,C,E,O,c,C,E,A,S,C,E,I,E,A,S,C,C,C,E,G,A,U,O,G,A,O,E,O,E,I,E,C,C,O,W,C,C,G,A,K,I,E,C,I,E,E,I,C,E,G,W,G,A,U,O,E,O,C,O,A,U,+C,C,M,A,C,A,W,E,O,M,E,E,E,E,U,M,A,U,O,E,E,O,E,E,E,G,E,E,C,C,S,E,C,C,C,C,C,E,O,G,E,E,S,C,G,G,E,E,G,O,c,C,E,Y,C,S,C,C,G,C,C,S,I,M,A,C,E,O,M,C,O,M,C,I,G,S,C,E,I,I,E,E,E,U,M,C,I,C,I,E,S,C,E,C,I,I,K,E,O,S,C,c,C,I,C,E,I,C,C,C,E,C,C,C,E,A,C,C,O,C,C,E,K,C,I,C,U,C,S,E,C,C,C,E,G,A,Y,O,G,A,O,E,M,A,U,qD,C,E,S,C,O,M,C,G,E,S,C,C,Y,C,M,E,S,C,E,a,C,C,C,G,O,c,C,E,Y,C,S,C,C,G,G,E,E,E,C,S,E,C,E,M,A,C,E,O,c,C,O,c,C,I,G,S,C,E,O,E,S,E,O,c,C,E,C,E,E,C,S,E,C,C,C,E,M,A,C,E,O,c,C,O,c,C,I,G,S,C,C,C,E,O,E,S,C,E,C,C,E,E,E,C,S,I,G,a,O,S,C,Q,S,E,Q,S,C,I,C,M,C,E,G,A,Y,O,M,M,C,E,G,C,O,Q,S,C,O,C,I,C,Q,S,C,Q,E,C,W,I,C,C,C,M,E,C,M,C,C,C,C,S,E,C,C,C,C,C,E,M,C,E,I,Q,S,C,I,G,S,C,C,C,C,C,E,I,E,C,K,C,E,I,C,K,C,E,G,I,E,G,C,S,I,C,K,C,E,E,E,O,G,E,E,E,S,E,C,G,K,C,K,U,C,S,E,C,E,I,E,A,Y,O,I,I,I,K,E,M,A,C,E,S,C,E,G,A,O,G,A,K,S,Q,C,I,C,G,O,C,iB,O,E,G,A,Y,O,E,M,A,U,sD,G,A,K,I,E,C,G,E,G,C,G,O,E,G,C,G,E,G,C,E,E,C,S,I,O,E,E,U,E,I,E,W,C,C,O,E,S,C,O,M,C,E,S,C,C,Y,C,M,E,W,C,E,S,C,E,a,C,C,C,G,E,E,E,C,E,E,C,S,E,C,E,G,A,K,I,E,M,A,e,6D,O,C,C,S,E,C,E,I,E,I,O,W,I,E,E,E,G,O,E,E,Q,S,C,E,U,E,I,E,W,E,E,K,C,I,C,W,A,S,C,C,C,E,G,G,C,A,U,O,G,A,Y,O,C,E,O,E,G,A,K,I,E,M,A,U,4D,O,E,E,E,I,C,E,C,C,S,I,M,C,E,A,a,O,S,Q,G,C,Q,G,C,I,G,S,C,C,C,C,C,E,I,E,A,S,C,C,C,E,K,C,O,S,C,c,C,I,C,E,I,A,O,C,E,E,E,I,O,C,E,E,G,G,G,I,E,O,wB,C,E,U,A,E,G,C,E,G,C,I,C,U,M,C,E,E,G,E,K,C,G,K,C,I,C,U,C,S,E,C,C,C,E,C,A,M,G,E,E,M,A,G,C,E,E,M,A,E,I,I,E,E,E,A,M,G,E,E,I,C,C,E,C,C,C,E,C,O,C,C,S,E,C,C,C,E,I,E,A,a,O,Q,C,C,O,Q,C,E,C,C,a,C,G,C,E,C,G,M,O,C,I,C,E,A,S,C,C,C,E,G,G,G,A,U,O,E,O,E,E,K,G,I,E,O,S,C,Q,C,I,C,G,K,C,E,I,G,W,G,E,W,E,C,E,E,W,C,I,A,E,A,Q,G,A,Q,E,O,M,I,C,G,G,A,c,G,2C,I,C,G,O,E,E,K,G,E,E,G,G,G,A,U,O,E,M,C,C,G,C,E,C,E,I,E,E,E,W,E,M,C,E,E,E,kB,A,G,E,M,C,C,K,C,C,E,C,K,C,E,M,C,C,I,A,C,E,E,S,C,E,M,C,E,E,C,C,C,M,A,U,wI,C,I,E,E,C,E,E,C,E,M,C,E,W,E,E,I,C,E,E,E,W,I,E,E,I,G,O,E,E,I,C,C,E,E,S,C,E,E,C,E,E,C,E,E,W,G,C,G,A,M,E,M,E,E,M,E,Q,C,G,E,M,C,C,C,C,CEjHA,IwBqBWqL,EADAA,ExBpBLC,EAAejL,OAAO2G,MAAM,CAAC,KACnCsE,CAAAA,EAAa,IAAO,CAAG,IACvBA,EAAa,KAAQ,CAAG,IACxBA,EAAa,IAAO,CAAG,IACvBA,EAAa,IAAO,CAAG,IACvBA,EAAa,OAAU,CAAG,IAC1BA,EAAa,OAAU,CAAG,IAC1BA,EAAa,IAAO,CAAG,IACvB,IAAMC,EAAuBlL,OAAO2G,MAAM,CAAC,MAC3C3G,OAAOmL,IAAI,CAACF,GAAcG,OAAO,CAAC,SAAAhG,CAAG,EACjC8F,CAAoB,CAACD,CAAY,CAAC7F,EAAI,CAAC,CAAGA,CAC9C,GACA,IAAMiG,EAAe,CAAExH,KAAM,QAASyH,KAAM,cAAe,ECXrDsW,EAAiB,AAAgB,YAAhB,OAAOpW,MACzB,AAAgB,aAAhB,OAAOA,MACJxL,AAAyC,6BAAzCA,OA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","sources":["<anon>","src/js/WithSocket.jsx","node_modules/socket.io/client-dist/socket.io.js","node_modules/socket.io/node_modules/engine.io-client/node_modules/engine.io-parser/build/esm/commons.js","node_modules/socket.io/node_modules/engine.io-client/node_modules/engine.io-parser/build/esm/encodePacket.browser.js","node_modules/socket.io/node_modules/engine.io-client/node_modules/engine.io-parser/build/esm/contrib/base64-arraybuffer.js","node_modules/socket.io/node_modules/engine.io-client/node_modules/engine.io-parser/build/esm/decodePacket.browser.js","node_modules/socket.io/node_modules/engine.io-client/node_modules/engine.io-parser/build/esm/index.js","node_modules/socket.io/node_modules/@socket.io/component-emitter/index.mjs","node_modules/socket.io/node_modules/engine.io-client/build/esm/globalThis.browser.js","node_modules/socket.io/node_modules/engine.io-client/build/esm/util.js","node_modules/socket.io/node_modules/engine.io-client/build/esm/contrib/parseqs.js","node_modules/socket.io/node_modules/engine.io-client/build/esm/transport.js","node_modules/socket.io/node_modules/engine.io-client/build/esm/contrib/yeast.js","node_modules/socket.io/node_modules/engine.io-client/build/esm/contrib/has-cors.js","node_modules/socket.io/node_modules/engine.io-client/build/esm/transports/xmlhttprequest.browser.js","node_modules/socket.io/node_modules/engine.io-client/build/esm/transports/polling.js","node_modules/socket.io/node_modules/engine.io-client/build/esm/transports/websocket-constructor.browser.js","node_modules/socket.io/node_modules/engine.io-client/build/esm/transports/websocket.js","node_modules/socket.io/node_modules/engine.io-client/build/esm/transports/webtransport.js","node_modules/socket.io/node_modules/engine.io-client/build/esm/transports/index.js","node_modules/socket.io/node_modules/engine.io-client/build/esm/contrib/parseuri.js","node_modules/socket.io/node_modules/engine.io-client/build/esm/socket.js","node_modules/socket.io/node_modules/engine.io-client/build/esm/index.js","node_modules/socket.io/build/esm/url.js","node_modules/socket.io/node_modules/socket.io-parser/build/esm/is-binary.js","node_modules/socket.io/node_modules/socket.io-parser/build/esm/binary.js","node_modules/socket.io/node_modules/socket.io-parser/build/esm/index.js","node_modules/socket.io/build/esm/on.js","node_modules/socket.io/build/esm/socket.js","node_modules/socket.io/build/esm/contrib/backo2.js","node_modules/socket.io/build/esm/manager.js","node_modules/socket.io/build/esm/index.js","src/js/Paint.jsx"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire49ed\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire49ed\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"lHCVX\", function(module, exports) {\n\n$parcel$export(module.exports, \"SocketContext\", () => $97f767c3b2093b90$export$86edbdc9a1e29ae8);\n$parcel$export(module.exports, \"WithSocket\", () => $97f767c3b2093b90$export$40a57a2074eac373);\n/**\r\n * Socket.IOのsocketを子要素に提供する．\r\n * \r\n * <WithSocket nsp=\"namespace\"> ... </WitSocket>\r\n *  nsp: Socket.IOで使用するnamespaceを指定する．デフォルトは /\r\n */ // CSSの読み込み\n\nvar $c54Ow = parcelRequire(\"c54Ow\");\n\n\nvar $anUZ9 = parcelRequire(\"anUZ9\");\n\nvar $lbJE2 = parcelRequire(\"lbJE2\");\n\nvar $brsYM = parcelRequire(\"brsYM\");\nconst $97f767c3b2093b90$export$86edbdc9a1e29ae8 = /*#__PURE__*/ (0, $lbJE2.createContext)();\nconst $97f767c3b2093b90$export$40a57a2074eac373 = (props)=>{\n    const socketRef = (0, $lbJE2.useRef)(null);\n    const [connected, setConnected] = (0, $lbJE2.useState)(false);\n    const [errorMessage, setErrorMessage] = (0, $lbJE2.useState)(\"\");\n    // LoginContextからユーザ情報を取得する．\n    const user = (0, $lbJE2.useContext)((0, $brsYM.LoginContext));\n    const openSocket = ()=>{\n        // ユーザ情報があればauthHeaderをつける．\n        const authHeader = user ? {\n            auth: {\n                token: user.token,\n                username: user.username\n            }\n        } : {};\n        if (!socketRef.current) {\n            const socket = (0, $anUZ9.io)(props.nsp, {\n                reconnection: false,\n                ...authHeader\n            });\n            socket.on(\"connect\", ()=>{\n                setConnected(true);\n            });\n            socket.on(\"error\", (error)=>{\n                setErrorMessage(error.message);\n            });\n            socket.on(\"connect_error\", (error)=>{\n                setErrorMessage(error.message);\n            });\n            socket.on(\"connect_timeout\", (error)=>{\n                setErrorMessage(error.message);\n            });\n            socket.on(\"disconnect\", (reason)=>{\n                setErrorMessage(`Disconnected: ${reason}.`);\n                setConnected(false);\n            });\n            socketRef.current = socket;\n        } else {\n            setErrorMessage(\"\");\n            socketRef.current.connect();\n        }\n    };\n    const closeSocket = ()=>{\n        if (socketRef.current) socketRef.current.close();\n    };\n    // コンポーネントがマウントされた時にソケットをオープンし，アンマウントする時にソケットをクローズする．\n    // もし，画面の同期を優先するのであれば，useEffectではなく，useLayoutEffectを使う．\n    (0, $lbJE2.useEffect)(()=>{\n        if (!connected) openSocket();\n        return ()=>{\n            closeSocket();\n        };\n    // 簡単にするために，user, nsp はコンポーネントがマウントされている間は変化しないという前提で，depedancyに入れない．\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    // 接続/切断のボタンの処理\n    const connectOrDisconnect = ()=>{\n        if (connected) closeSocket();\n        else openSocket();\n    };\n    return /*#__PURE__*/ (0, $c54Ow.jsxs)(\"div\", {\n        className: \"with-socket\",\n        children: [\n            /*#__PURE__*/ (0, $c54Ow.jsxs)(\"div\", {\n                className: \"with-socket-control\",\n                children: [\n                    /*#__PURE__*/ (0, $c54Ow.jsxs)(\"span\", {\n                        className: connected ? \"\" : \"with-socket-disconnected\",\n                        children: [\n                            \"namespace: \",\n                            props.nsp\n                        ]\n                    }),\n                    /*#__PURE__*/ (0, $c54Ow.jsx)(\"button\", {\n                        type: \"button\",\n                        onClick: connectOrDisconnect,\n                        children: connected ? \"\\u5207\\u65AD\" : \"\\u63A5\\u7D9A\"\n                    })\n                ]\n            }),\n            connected ? // 接続している時は，子要素を表示する．\n            /*#__PURE__*/ (0, $c54Ow.jsx)($97f767c3b2093b90$export$86edbdc9a1e29ae8.Provider, {\n                value: socketRef,\n                children: props.children\n            }) : // 切断されている時\n            /*#__PURE__*/ (0, $c54Ow.jsx)(\"div\", {\n                children: /*#__PURE__*/ (0, $c54Ow.jsx)(\"span\", {\n                    className: \"with-socket-disconnected\",\n                    children: \"\\u63A5\\u7D9A\\u3055\\u308C\\u3066\\u3044\\u307E\\u305B\\u3093\"\n                })\n            }),\n            errorMessage === \"\" ? null : /*#__PURE__*/ (0, $c54Ow.jsx)(\"div\", {\n                className: \"error-message\",\n                onClick: ()=>setErrorMessage(\"\"),\n                children: errorMessage\n            })\n        ]\n    });\n};\n\n});\nparcelRegister(\"anUZ9\", function(module, exports) {\n/*!\n * Socket.IO v4.7.5\n * (c) 2014-2024 Guillermo Rauch\n * Released under the MIT License.\n */ (function(global, factory) {\n    module.exports = factory();\n})(module.exports, function() {\n    \"use strict\";\n    function _typeof(obj) {\n        \"@babel/helpers - typeof\";\n        return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(obj) {\n            return typeof obj;\n        } : function(obj) {\n            return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n        }, _typeof(obj);\n    }\n    function _classCallCheck(instance, Constructor) {\n        if (!(instance instanceof Constructor)) throw new TypeError(\"Cannot call a class as a function\");\n    }\n    function _defineProperties(target, props) {\n        for(var i = 0; i < props.length; i++){\n            var descriptor = props[i];\n            descriptor.enumerable = descriptor.enumerable || false;\n            descriptor.configurable = true;\n            if (\"value\" in descriptor) descriptor.writable = true;\n            Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n        }\n    }\n    function _createClass(Constructor, protoProps, staticProps) {\n        if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n        if (staticProps) _defineProperties(Constructor, staticProps);\n        Object.defineProperty(Constructor, \"prototype\", {\n            writable: false\n        });\n        return Constructor;\n    }\n    function _extends() {\n        _extends = Object.assign ? Object.assign.bind() : function(target) {\n            for(var i = 1; i < arguments.length; i++){\n                var source = arguments[i];\n                for(var key in source)if (Object.prototype.hasOwnProperty.call(source, key)) target[key] = source[key];\n            }\n            return target;\n        };\n        return _extends.apply(this, arguments);\n    }\n    function _inherits(subClass, superClass) {\n        if (typeof superClass !== \"function\" && superClass !== null) throw new TypeError(\"Super expression must either be null or a function\");\n        subClass.prototype = Object.create(superClass && superClass.prototype, {\n            constructor: {\n                value: subClass,\n                writable: true,\n                configurable: true\n            }\n        });\n        Object.defineProperty(subClass, \"prototype\", {\n            writable: false\n        });\n        if (superClass) _setPrototypeOf(subClass, superClass);\n    }\n    function _getPrototypeOf(o) {\n        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n            return o.__proto__ || Object.getPrototypeOf(o);\n        };\n        return _getPrototypeOf(o);\n    }\n    function _setPrototypeOf(o, p) {\n        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n            o.__proto__ = p;\n            return o;\n        };\n        return _setPrototypeOf(o, p);\n    }\n    function _isNativeReflectConstruct() {\n        if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n        if (Reflect.construct.sham) return false;\n        if (typeof Proxy === \"function\") return true;\n        try {\n            Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));\n            return true;\n        } catch (e) {\n            return false;\n        }\n    }\n    function _construct(Parent, args, Class) {\n        if (_isNativeReflectConstruct()) _construct = Reflect.construct.bind();\n        else _construct = function _construct(Parent, args, Class) {\n            var a = [\n                null\n            ];\n            a.push.apply(a, args);\n            var Constructor = Function.bind.apply(Parent, a);\n            var instance = new Constructor();\n            if (Class) _setPrototypeOf(instance, Class.prototype);\n            return instance;\n        };\n        return _construct.apply(null, arguments);\n    }\n    function _isNativeFunction(fn) {\n        return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n    }\n    function _wrapNativeSuper(Class) {\n        var _cache = typeof Map === \"function\" ? new Map() : undefined;\n        _wrapNativeSuper = function _wrapNativeSuper(Class) {\n            if (Class === null || !_isNativeFunction(Class)) return Class;\n            if (typeof Class !== \"function\") throw new TypeError(\"Super expression must either be null or a function\");\n            if (typeof _cache !== \"undefined\") {\n                if (_cache.has(Class)) return _cache.get(Class);\n                _cache.set(Class, Wrapper);\n            }\n            function Wrapper() {\n                return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n            }\n            Wrapper.prototype = Object.create(Class.prototype, {\n                constructor: {\n                    value: Wrapper,\n                    enumerable: false,\n                    writable: true,\n                    configurable: true\n                }\n            });\n            return _setPrototypeOf(Wrapper, Class);\n        };\n        return _wrapNativeSuper(Class);\n    }\n    function _assertThisInitialized(self1) {\n        if (self1 === void 0) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n        return self1;\n    }\n    function _possibleConstructorReturn(self1, call) {\n        if (call && (typeof call === \"object\" || typeof call === \"function\")) return call;\n        else if (call !== void 0) throw new TypeError(\"Derived constructors may only return object or undefined\");\n        return _assertThisInitialized(self1);\n    }\n    function _createSuper(Derived) {\n        var hasNativeReflectConstruct = _isNativeReflectConstruct();\n        return function _createSuperInternal() {\n            var Super = _getPrototypeOf(Derived), result;\n            if (hasNativeReflectConstruct) {\n                var NewTarget = _getPrototypeOf(this).constructor;\n                result = Reflect.construct(Super, arguments, NewTarget);\n            } else result = Super.apply(this, arguments);\n            return _possibleConstructorReturn(this, result);\n        };\n    }\n    function _superPropBase(object, property) {\n        while(!Object.prototype.hasOwnProperty.call(object, property)){\n            object = _getPrototypeOf(object);\n            if (object === null) break;\n        }\n        return object;\n    }\n    function _get() {\n        if (typeof Reflect !== \"undefined\" && Reflect.get) _get = Reflect.get.bind();\n        else _get = function _get(target, property, receiver) {\n            var base = _superPropBase(target, property);\n            if (!base) return;\n            var desc = Object.getOwnPropertyDescriptor(base, property);\n            if (desc.get) return desc.get.call(arguments.length < 3 ? target : receiver);\n            return desc.value;\n        };\n        return _get.apply(this, arguments);\n    }\n    function _unsupportedIterableToArray(o, minLen) {\n        if (!o) return;\n        if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n        var n = Object.prototype.toString.call(o).slice(8, -1);\n        if (n === \"Object\" && o.constructor) n = o.constructor.name;\n        if (n === \"Map\" || n === \"Set\") return Array.from(o);\n        if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n    }\n    function _arrayLikeToArray(arr, len) {\n        if (len == null || len > arr.length) len = arr.length;\n        for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n        return arr2;\n    }\n    function _createForOfIteratorHelper(o, allowArrayLike) {\n        var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n        if (!it) {\n            if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n                if (it) o = it;\n                var i = 0;\n                var F = function() {};\n                return {\n                    s: F,\n                    n: function() {\n                        if (i >= o.length) return {\n                            done: true\n                        };\n                        return {\n                            done: false,\n                            value: o[i++]\n                        };\n                    },\n                    e: function(e) {\n                        throw e;\n                    },\n                    f: F\n                };\n            }\n            throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n        }\n        var normalCompletion = true, didErr = false, err;\n        return {\n            s: function() {\n                it = it.call(o);\n            },\n            n: function() {\n                var step = it.next();\n                normalCompletion = step.done;\n                return step;\n            },\n            e: function(e) {\n                didErr = true;\n                err = e;\n            },\n            f: function() {\n                try {\n                    if (!normalCompletion && it.return != null) it.return();\n                } finally{\n                    if (didErr) throw err;\n                }\n            }\n        };\n    }\n    function _toPrimitive(input, hint) {\n        if (typeof input !== \"object\" || input === null) return input;\n        var prim = input[Symbol.toPrimitive];\n        if (prim !== undefined) {\n            var res = prim.call(input, hint || \"default\");\n            if (typeof res !== \"object\") return res;\n            throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n        }\n        return (hint === \"string\" ? String : Number)(input);\n    }\n    function _toPropertyKey(arg) {\n        var key = _toPrimitive(arg, \"string\");\n        return typeof key === \"symbol\" ? key : String(key);\n    }\n    var PACKET_TYPES = Object.create(null); // no Map = no polyfill\n    PACKET_TYPES[\"open\"] = \"0\";\n    PACKET_TYPES[\"close\"] = \"1\";\n    PACKET_TYPES[\"ping\"] = \"2\";\n    PACKET_TYPES[\"pong\"] = \"3\";\n    PACKET_TYPES[\"message\"] = \"4\";\n    PACKET_TYPES[\"upgrade\"] = \"5\";\n    PACKET_TYPES[\"noop\"] = \"6\";\n    var PACKET_TYPES_REVERSE = Object.create(null);\n    Object.keys(PACKET_TYPES).forEach(function(key) {\n        PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;\n    });\n    var ERROR_PACKET = {\n        type: \"error\",\n        data: \"parser error\"\n    };\n    var withNativeBlob$1 = typeof Blob === \"function\" || typeof Blob !== \"undefined\" && Object.prototype.toString.call(Blob) === \"[object BlobConstructor]\";\n    var withNativeArrayBuffer$2 = typeof ArrayBuffer === \"function\";\n    // ArrayBuffer.isView method is not defined in IE10\n    var isView$1 = function isView(obj) {\n        return typeof ArrayBuffer.isView === \"function\" ? ArrayBuffer.isView(obj) : obj && obj.buffer instanceof ArrayBuffer;\n    };\n    var encodePacket = function encodePacket(_ref, supportsBinary, callback) {\n        var type = _ref.type, data = _ref.data;\n        if (withNativeBlob$1 && data instanceof Blob) {\n            if (supportsBinary) return callback(data);\n            else return encodeBlobAsBase64(data, callback);\n        } else if (withNativeArrayBuffer$2 && (data instanceof ArrayBuffer || isView$1(data))) {\n            if (supportsBinary) return callback(data);\n            else return encodeBlobAsBase64(new Blob([\n                data\n            ]), callback);\n        }\n        // plain string\n        return callback(PACKET_TYPES[type] + (data || \"\"));\n    };\n    var encodeBlobAsBase64 = function encodeBlobAsBase64(data, callback) {\n        var fileReader = new FileReader();\n        fileReader.onload = function() {\n            var content = fileReader.result.split(\",\")[1];\n            callback(\"b\" + (content || \"\"));\n        };\n        return fileReader.readAsDataURL(data);\n    };\n    function toArray(data) {\n        if (data instanceof Uint8Array) return data;\n        else if (data instanceof ArrayBuffer) return new Uint8Array(data);\n        else return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n    }\n    var TEXT_ENCODER;\n    function encodePacketToBinary(packet, callback) {\n        if (withNativeBlob$1 && packet.data instanceof Blob) return packet.data.arrayBuffer().then(toArray).then(callback);\n        else if (withNativeArrayBuffer$2 && (packet.data instanceof ArrayBuffer || isView$1(packet.data))) return callback(toArray(packet.data));\n        encodePacket(packet, false, function(encoded) {\n            if (!TEXT_ENCODER) TEXT_ENCODER = new TextEncoder();\n            callback(TEXT_ENCODER.encode(encoded));\n        });\n    }\n    // imported from https://github.com/socketio/base64-arraybuffer\n    var chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n    // Use a lookup table to find the index.\n    var lookup$1 = typeof Uint8Array === \"undefined\" ? [] : new Uint8Array(256);\n    for(var i$1 = 0; i$1 < chars.length; i$1++)lookup$1[chars.charCodeAt(i$1)] = i$1;\n    var decode$1 = function decode(base64) {\n        var bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;\n        if (base64[base64.length - 1] === \"=\") {\n            bufferLength--;\n            if (base64[base64.length - 2] === \"=\") bufferLength--;\n        }\n        var arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);\n        for(i = 0; i < len; i += 4){\n            encoded1 = lookup$1[base64.charCodeAt(i)];\n            encoded2 = lookup$1[base64.charCodeAt(i + 1)];\n            encoded3 = lookup$1[base64.charCodeAt(i + 2)];\n            encoded4 = lookup$1[base64.charCodeAt(i + 3)];\n            bytes[p++] = encoded1 << 2 | encoded2 >> 4;\n            bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;\n            bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;\n        }\n        return arraybuffer;\n    };\n    var withNativeArrayBuffer$1 = typeof ArrayBuffer === \"function\";\n    var decodePacket = function decodePacket(encodedPacket, binaryType) {\n        if (typeof encodedPacket !== \"string\") return {\n            type: \"message\",\n            data: mapBinary(encodedPacket, binaryType)\n        };\n        var type = encodedPacket.charAt(0);\n        if (type === \"b\") return {\n            type: \"message\",\n            data: decodeBase64Packet(encodedPacket.substring(1), binaryType)\n        };\n        var packetType = PACKET_TYPES_REVERSE[type];\n        if (!packetType) return ERROR_PACKET;\n        return encodedPacket.length > 1 ? {\n            type: PACKET_TYPES_REVERSE[type],\n            data: encodedPacket.substring(1)\n        } : {\n            type: PACKET_TYPES_REVERSE[type]\n        };\n    };\n    var decodeBase64Packet = function decodeBase64Packet(data, binaryType) {\n        if (withNativeArrayBuffer$1) {\n            var decoded = decode$1(data);\n            return mapBinary(decoded, binaryType);\n        } else return {\n            base64: true,\n            data: data\n        }; // fallback for old browsers\n    };\n    var mapBinary = function mapBinary(data, binaryType) {\n        switch(binaryType){\n            case \"blob\":\n                if (data instanceof Blob) // from WebSocket + binaryType \"blob\"\n                return data;\n                else // from HTTP long-polling or WebTransport\n                return new Blob([\n                    data\n                ]);\n            case \"arraybuffer\":\n            default:\n                if (data instanceof ArrayBuffer) // from HTTP long-polling (base64) or WebSocket + binaryType \"arraybuffer\"\n                return data;\n                else // from WebTransport (Uint8Array)\n                return data.buffer;\n        }\n    };\n    var SEPARATOR = String.fromCharCode(30); // see https://en.wikipedia.org/wiki/Delimiter#ASCII_delimited_text\n    var encodePayload = function encodePayload(packets, callback) {\n        // some packets may be added to the array while encoding, so the initial length must be saved\n        var length = packets.length;\n        var encodedPackets = new Array(length);\n        var count = 0;\n        packets.forEach(function(packet, i) {\n            // force base64 encoding for binary packets\n            encodePacket(packet, false, function(encodedPacket) {\n                encodedPackets[i] = encodedPacket;\n                if (++count === length) callback(encodedPackets.join(SEPARATOR));\n            });\n        });\n    };\n    var decodePayload = function decodePayload(encodedPayload, binaryType) {\n        var encodedPackets = encodedPayload.split(SEPARATOR);\n        var packets = [];\n        for(var i = 0; i < encodedPackets.length; i++){\n            var decodedPacket = decodePacket(encodedPackets[i], binaryType);\n            packets.push(decodedPacket);\n            if (decodedPacket.type === \"error\") break;\n        }\n        return packets;\n    };\n    function createPacketEncoderStream() {\n        return new TransformStream({\n            transform: function transform(packet, controller) {\n                encodePacketToBinary(packet, function(encodedPacket) {\n                    var payloadLength = encodedPacket.length;\n                    var header;\n                    // inspired by the WebSocket format: https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers#decoding_payload_length\n                    if (payloadLength < 126) {\n                        header = new Uint8Array(1);\n                        new DataView(header.buffer).setUint8(0, payloadLength);\n                    } else if (payloadLength < 65536) {\n                        header = new Uint8Array(3);\n                        var view = new DataView(header.buffer);\n                        view.setUint8(0, 126);\n                        view.setUint16(1, payloadLength);\n                    } else {\n                        header = new Uint8Array(9);\n                        var _view = new DataView(header.buffer);\n                        _view.setUint8(0, 127);\n                        _view.setBigUint64(1, BigInt(payloadLength));\n                    }\n                    // first bit indicates whether the payload is plain text (0) or binary (1)\n                    if (packet.data && typeof packet.data !== \"string\") header[0] |= 0x80;\n                    controller.enqueue(header);\n                    controller.enqueue(encodedPacket);\n                });\n            }\n        });\n    }\n    var TEXT_DECODER;\n    function totalLength(chunks) {\n        return chunks.reduce(function(acc, chunk) {\n            return acc + chunk.length;\n        }, 0);\n    }\n    function concatChunks(chunks, size) {\n        if (chunks[0].length === size) return chunks.shift();\n        var buffer = new Uint8Array(size);\n        var j = 0;\n        for(var i = 0; i < size; i++){\n            buffer[i] = chunks[0][j++];\n            if (j === chunks[0].length) {\n                chunks.shift();\n                j = 0;\n            }\n        }\n        if (chunks.length && j < chunks[0].length) chunks[0] = chunks[0].slice(j);\n        return buffer;\n    }\n    function createPacketDecoderStream(maxPayload, binaryType) {\n        if (!TEXT_DECODER) TEXT_DECODER = new TextDecoder();\n        var chunks = [];\n        var state = 0 /* READ_HEADER */ ;\n        var expectedLength = -1;\n        var isBinary = false;\n        return new TransformStream({\n            transform: function transform(chunk, controller) {\n                chunks.push(chunk);\n                while(true){\n                    if (state === 0 /* READ_HEADER */ ) {\n                        if (totalLength(chunks) < 1) break;\n                        var header = concatChunks(chunks, 1);\n                        isBinary = (header[0] & 0x80) === 0x80;\n                        expectedLength = header[0] & 0x7f;\n                        if (expectedLength < 126) state = 3 /* READ_PAYLOAD */ ;\n                        else if (expectedLength === 126) state = 1 /* READ_EXTENDED_LENGTH_16 */ ;\n                        else state = 2 /* READ_EXTENDED_LENGTH_64 */ ;\n                    } else if (state === 1 /* READ_EXTENDED_LENGTH_16 */ ) {\n                        if (totalLength(chunks) < 2) break;\n                        var headerArray = concatChunks(chunks, 2);\n                        expectedLength = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length).getUint16(0);\n                        state = 3 /* READ_PAYLOAD */ ;\n                    } else if (state === 2 /* READ_EXTENDED_LENGTH_64 */ ) {\n                        if (totalLength(chunks) < 8) break;\n                        var _headerArray = concatChunks(chunks, 8);\n                        var view = new DataView(_headerArray.buffer, _headerArray.byteOffset, _headerArray.length);\n                        var n = view.getUint32(0);\n                        if (n > Math.pow(2, 21) - 1) {\n                            // the maximum safe integer in JavaScript is 2^53 - 1\n                            controller.enqueue(ERROR_PACKET);\n                            break;\n                        }\n                        expectedLength = n * Math.pow(2, 32) + view.getUint32(4);\n                        state = 3 /* READ_PAYLOAD */ ;\n                    } else {\n                        if (totalLength(chunks) < expectedLength) break;\n                        var data = concatChunks(chunks, expectedLength);\n                        controller.enqueue(decodePacket(isBinary ? data : TEXT_DECODER.decode(data), binaryType));\n                        state = 0 /* READ_HEADER */ ;\n                    }\n                    if (expectedLength === 0 || expectedLength > maxPayload) {\n                        controller.enqueue(ERROR_PACKET);\n                        break;\n                    }\n                }\n            }\n        });\n    }\n    var protocol$1 = 4;\n    /**\n   * Initialize a new `Emitter`.\n   *\n   * @api public\n   */ function Emitter(obj) {\n        if (obj) return mixin(obj);\n    }\n    /**\n   * Mixin the emitter properties.\n   *\n   * @param {Object} obj\n   * @return {Object}\n   * @api private\n   */ function mixin(obj) {\n        for(var key in Emitter.prototype)obj[key] = Emitter.prototype[key];\n        return obj;\n    }\n    /**\n   * Listen on the given `event` with `fn`.\n   *\n   * @param {String} event\n   * @param {Function} fn\n   * @return {Emitter}\n   * @api public\n   */ Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn) {\n        this._callbacks = this._callbacks || {};\n        (this._callbacks[\"$\" + event] = this._callbacks[\"$\" + event] || []).push(fn);\n        return this;\n    };\n    /**\n   * Adds an `event` listener that will be invoked a single\n   * time then automatically removed.\n   *\n   * @param {String} event\n   * @param {Function} fn\n   * @return {Emitter}\n   * @api public\n   */ Emitter.prototype.once = function(event, fn) {\n        function on() {\n            this.off(event, on);\n            fn.apply(this, arguments);\n        }\n        on.fn = fn;\n        this.on(event, on);\n        return this;\n    };\n    /**\n   * Remove the given callback for `event` or all\n   * registered callbacks.\n   *\n   * @param {String} event\n   * @param {Function} fn\n   * @return {Emitter}\n   * @api public\n   */ Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn) {\n        this._callbacks = this._callbacks || {};\n        // all\n        if (0 == arguments.length) {\n            this._callbacks = {};\n            return this;\n        }\n        // specific event\n        var callbacks = this._callbacks[\"$\" + event];\n        if (!callbacks) return this;\n        // remove all handlers\n        if (1 == arguments.length) {\n            delete this._callbacks[\"$\" + event];\n            return this;\n        }\n        // remove specific handler\n        var cb;\n        for(var i = 0; i < callbacks.length; i++){\n            cb = callbacks[i];\n            if (cb === fn || cb.fn === fn) {\n                callbacks.splice(i, 1);\n                break;\n            }\n        }\n        // Remove event specific arrays for event types that no\n        // one is subscribed for to avoid memory leak.\n        if (callbacks.length === 0) delete this._callbacks[\"$\" + event];\n        return this;\n    };\n    /**\n   * Emit `event` with the given args.\n   *\n   * @param {String} event\n   * @param {Mixed} ...\n   * @return {Emitter}\n   */ Emitter.prototype.emit = function(event) {\n        this._callbacks = this._callbacks || {};\n        var args = new Array(arguments.length - 1), callbacks = this._callbacks[\"$\" + event];\n        for(var i = 1; i < arguments.length; i++)args[i - 1] = arguments[i];\n        if (callbacks) {\n            callbacks = callbacks.slice(0);\n            for(var i = 0, len = callbacks.length; i < len; ++i)callbacks[i].apply(this, args);\n        }\n        return this;\n    };\n    // alias used for reserved events (protected method)\n    Emitter.prototype.emitReserved = Emitter.prototype.emit;\n    /**\n   * Return array of callbacks for `event`.\n   *\n   * @param {String} event\n   * @return {Array}\n   * @api public\n   */ Emitter.prototype.listeners = function(event) {\n        this._callbacks = this._callbacks || {};\n        return this._callbacks[\"$\" + event] || [];\n    };\n    /**\n   * Check if this emitter has `event` handlers.\n   *\n   * @param {String} event\n   * @return {Boolean}\n   * @api public\n   */ Emitter.prototype.hasListeners = function(event) {\n        return !!this.listeners(event).length;\n    };\n    var globalThisShim = function() {\n        if (typeof self !== \"undefined\") return self;\n        else if (typeof window !== \"undefined\") return window;\n        else return Function(\"return this\")();\n    }();\n    function pick(obj) {\n        for(var _len = arguments.length, attr = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)attr[_key - 1] = arguments[_key];\n        return attr.reduce(function(acc, k) {\n            if (obj.hasOwnProperty(k)) acc[k] = obj[k];\n            return acc;\n        }, {});\n    }\n    // Keep a reference to the real timeout functions so they can be used when overridden\n    var NATIVE_SET_TIMEOUT = globalThisShim.setTimeout;\n    var NATIVE_CLEAR_TIMEOUT = globalThisShim.clearTimeout;\n    function installTimerFunctions(obj, opts) {\n        if (opts.useNativeTimers) {\n            obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThisShim);\n            obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThisShim);\n        } else {\n            obj.setTimeoutFn = globalThisShim.setTimeout.bind(globalThisShim);\n            obj.clearTimeoutFn = globalThisShim.clearTimeout.bind(globalThisShim);\n        }\n    }\n    // base64 encoded buffers are about 33% bigger (https://en.wikipedia.org/wiki/Base64)\n    var BASE64_OVERHEAD = 1.33;\n    // we could also have used `new Blob([obj]).size`, but it isn't supported in IE9\n    function byteLength(obj) {\n        if (typeof obj === \"string\") return utf8Length(obj);\n        // arraybuffer or blob\n        return Math.ceil((obj.byteLength || obj.size) * BASE64_OVERHEAD);\n    }\n    function utf8Length(str) {\n        var c = 0, length = 0;\n        for(var i = 0, l = str.length; i < l; i++){\n            c = str.charCodeAt(i);\n            if (c < 0x80) length += 1;\n            else if (c < 0x800) length += 2;\n            else if (c < 0xd800 || c >= 0xe000) length += 3;\n            else {\n                i++;\n                length += 4;\n            }\n        }\n        return length;\n    }\n    // imported from https://github.com/galkn/querystring\n    /**\n   * Compiles a querystring\n   * Returns string representation of the object\n   *\n   * @param {Object}\n   * @api private\n   */ function encode$1(obj) {\n        var str = \"\";\n        for(var i in obj)if (obj.hasOwnProperty(i)) {\n            if (str.length) str += \"&\";\n            str += encodeURIComponent(i) + \"=\" + encodeURIComponent(obj[i]);\n        }\n        return str;\n    }\n    /**\n   * Parses a simple querystring into an object\n   *\n   * @param {String} qs\n   * @api private\n   */ function decode(qs) {\n        var qry = {};\n        var pairs = qs.split(\"&\");\n        for(var i = 0, l = pairs.length; i < l; i++){\n            var pair = pairs[i].split(\"=\");\n            qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);\n        }\n        return qry;\n    }\n    var TransportError = /*#__PURE__*/ function(_Error) {\n        _inherits(TransportError, _Error);\n        var _super = _createSuper(TransportError);\n        function TransportError(reason, description, context) {\n            var _this;\n            _classCallCheck(this, TransportError);\n            _this = _super.call(this, reason);\n            _this.description = description;\n            _this.context = context;\n            _this.type = \"TransportError\";\n            return _this;\n        }\n        return _createClass(TransportError);\n    }(/*#__PURE__*/ _wrapNativeSuper(Error));\n    var Transport = /*#__PURE__*/ function(_Emitter) {\n        _inherits(Transport, _Emitter);\n        var _super2 = _createSuper(Transport);\n        /**\n     * Transport abstract constructor.\n     *\n     * @param {Object} opts - options\n     * @protected\n     */ function Transport(opts) {\n            var _this2;\n            _classCallCheck(this, Transport);\n            _this2 = _super2.call(this);\n            _this2.writable = false;\n            installTimerFunctions(_assertThisInitialized(_this2), opts);\n            _this2.opts = opts;\n            _this2.query = opts.query;\n            _this2.socket = opts.socket;\n            return _this2;\n        }\n        /**\n     * Emits an error.\n     *\n     * @param {String} reason\n     * @param description\n     * @param context - the error context\n     * @return {Transport} for chaining\n     * @protected\n     */ _createClass(Transport, [\n            {\n                key: \"onError\",\n                value: function onError(reason, description, context) {\n                    _get(_getPrototypeOf(Transport.prototype), \"emitReserved\", this).call(this, \"error\", new TransportError(reason, description, context));\n                    return this;\n                }\n            },\n            {\n                key: \"open\",\n                value: function open() {\n                    this.readyState = \"opening\";\n                    this.doOpen();\n                    return this;\n                }\n            },\n            {\n                key: \"close\",\n                value: function close() {\n                    if (this.readyState === \"opening\" || this.readyState === \"open\") {\n                        this.doClose();\n                        this.onClose();\n                    }\n                    return this;\n                }\n            },\n            {\n                key: \"send\",\n                value: function send(packets) {\n                    if (this.readyState === \"open\") this.write(packets);\n                }\n            },\n            {\n                key: \"onOpen\",\n                value: function onOpen() {\n                    this.readyState = \"open\";\n                    this.writable = true;\n                    _get(_getPrototypeOf(Transport.prototype), \"emitReserved\", this).call(this, \"open\");\n                }\n            },\n            {\n                key: \"onData\",\n                value: function onData(data) {\n                    var packet = decodePacket(data, this.socket.binaryType);\n                    this.onPacket(packet);\n                }\n            },\n            {\n                key: \"onPacket\",\n                value: function onPacket(packet) {\n                    _get(_getPrototypeOf(Transport.prototype), \"emitReserved\", this).call(this, \"packet\", packet);\n                }\n            },\n            {\n                key: \"onClose\",\n                value: function onClose(details) {\n                    this.readyState = \"closed\";\n                    _get(_getPrototypeOf(Transport.prototype), \"emitReserved\", this).call(this, \"close\", details);\n                }\n            },\n            {\n                key: \"pause\",\n                value: function pause(onPause) {}\n            },\n            {\n                key: \"createUri\",\n                value: function createUri(schema) {\n                    var query = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n                    return schema + \"://\" + this._hostname() + this._port() + this.opts.path + this._query(query);\n                }\n            },\n            {\n                key: \"_hostname\",\n                value: function _hostname() {\n                    var hostname = this.opts.hostname;\n                    return hostname.indexOf(\":\") === -1 ? hostname : \"[\" + hostname + \"]\";\n                }\n            },\n            {\n                key: \"_port\",\n                value: function _port() {\n                    if (this.opts.port && (this.opts.secure && Number(this.opts.port !== 443) || !this.opts.secure && Number(this.opts.port) !== 80)) return \":\" + this.opts.port;\n                    else return \"\";\n                }\n            },\n            {\n                key: \"_query\",\n                value: function _query(query) {\n                    var encodedQuery = encode$1(query);\n                    return encodedQuery.length ? \"?\" + encodedQuery : \"\";\n                }\n            }\n        ]);\n        return Transport;\n    }(Emitter);\n    // imported from https://github.com/unshiftio/yeast\n    var alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_\".split(\"\"), length = 64, map = {};\n    var seed = 0, i = 0, prev;\n    /**\n   * Return a string representing the specified number.\n   *\n   * @param {Number} num The number to convert.\n   * @returns {String} The string representation of the number.\n   * @api public\n   */ function encode(num) {\n        var encoded = \"\";\n        do {\n            encoded = alphabet[num % length] + encoded;\n            num = Math.floor(num / length);\n        }while (num > 0);\n        return encoded;\n    }\n    /**\n   * Yeast: A tiny growing id generator.\n   *\n   * @returns {String} A unique id.\n   * @api public\n   */ function yeast() {\n        var now = encode(+new Date());\n        if (now !== prev) return seed = 0, prev = now;\n        return now + \".\" + encode(seed++);\n    }\n    //\n    // Map each character to its index.\n    //\n    for(; i < length; i++)map[alphabet[i]] = i;\n    // imported from https://github.com/component/has-cors\n    var value = false;\n    try {\n        value = typeof XMLHttpRequest !== \"undefined\" && \"withCredentials\" in new XMLHttpRequest();\n    } catch (err) {\n    // if XMLHttp support is disabled in IE then it will throw\n    // when trying to create\n    }\n    var hasCORS = value;\n    // browser shim for xmlhttprequest module\n    function XHR(opts) {\n        var xdomain = opts.xdomain;\n        // XMLHttpRequest can be disabled on IE\n        try {\n            if (\"undefined\" !== typeof XMLHttpRequest && (!xdomain || hasCORS)) return new XMLHttpRequest();\n        } catch (e) {}\n        if (!xdomain) try {\n            return new globalThisShim[[\n                \"Active\"\n            ].concat(\"Object\").join(\"X\")](\"Microsoft.XMLHTTP\");\n        } catch (e) {}\n    }\n    function createCookieJar() {}\n    function empty() {}\n    var hasXHR2 = function() {\n        var xhr = new XHR({\n            xdomain: false\n        });\n        return null != xhr.responseType;\n    }();\n    var Polling = /*#__PURE__*/ function(_Transport) {\n        _inherits(Polling, _Transport);\n        var _super = _createSuper(Polling);\n        /**\n     * XHR Polling constructor.\n     *\n     * @param {Object} opts\n     * @package\n     */ function Polling(opts) {\n            var _this;\n            _classCallCheck(this, Polling);\n            _this = _super.call(this, opts);\n            _this.polling = false;\n            if (typeof location !== \"undefined\") {\n                var isSSL = \"https:\" === location.protocol;\n                var port = location.port;\n                // some user agents have empty `location.port`\n                if (!port) port = isSSL ? \"443\" : \"80\";\n                _this.xd = typeof location !== \"undefined\" && opts.hostname !== location.hostname || port !== opts.port;\n            }\n            /**\n       * XHR supports binary\n       */ var forceBase64 = opts && opts.forceBase64;\n            _this.supportsBinary = hasXHR2 && !forceBase64;\n            if (_this.opts.withCredentials) _this.cookieJar = createCookieJar();\n            return _this;\n        }\n        _createClass(Polling, [\n            {\n                key: \"name\",\n                get: function get() {\n                    return \"polling\";\n                }\n            },\n            {\n                key: \"doOpen\",\n                value: function doOpen() {\n                    this.poll();\n                }\n            },\n            {\n                key: \"pause\",\n                value: function pause(onPause) {\n                    var _this2 = this;\n                    this.readyState = \"pausing\";\n                    var pause = function pause() {\n                        _this2.readyState = \"paused\";\n                        onPause();\n                    };\n                    if (this.polling || !this.writable) {\n                        var total = 0;\n                        if (this.polling) {\n                            total++;\n                            this.once(\"pollComplete\", function() {\n                                --total || pause();\n                            });\n                        }\n                        if (!this.writable) {\n                            total++;\n                            this.once(\"drain\", function() {\n                                --total || pause();\n                            });\n                        }\n                    } else pause();\n                }\n            },\n            {\n                key: \"poll\",\n                value: function poll() {\n                    this.polling = true;\n                    this.doPoll();\n                    this.emitReserved(\"poll\");\n                }\n            },\n            {\n                key: \"onData\",\n                value: function onData(data) {\n                    var _this3 = this;\n                    var callback = function callback(packet) {\n                        // if its the first message we consider the transport open\n                        if (\"opening\" === _this3.readyState && packet.type === \"open\") _this3.onOpen();\n                        // if its a close packet, we close the ongoing requests\n                        if (\"close\" === packet.type) {\n                            _this3.onClose({\n                                description: \"transport closed by the server\"\n                            });\n                            return false;\n                        }\n                        // otherwise bypass onData and handle the message\n                        _this3.onPacket(packet);\n                    };\n                    // decode payload\n                    decodePayload(data, this.socket.binaryType).forEach(callback);\n                    // if an event did not trigger closing\n                    if (\"closed\" !== this.readyState) {\n                        // if we got data we're not polling\n                        this.polling = false;\n                        this.emitReserved(\"pollComplete\");\n                        if (\"open\" === this.readyState) this.poll();\n                    }\n                }\n            },\n            {\n                key: \"doClose\",\n                value: function doClose() {\n                    var _this4 = this;\n                    var close = function close() {\n                        _this4.write([\n                            {\n                                type: \"close\"\n                            }\n                        ]);\n                    };\n                    if (\"open\" === this.readyState) close();\n                    else // in case we're trying to close while\n                    // handshaking is in progress (GH-164)\n                    this.once(\"open\", close);\n                }\n            },\n            {\n                key: \"write\",\n                value: function write(packets) {\n                    var _this5 = this;\n                    this.writable = false;\n                    encodePayload(packets, function(data) {\n                        _this5.doWrite(data, function() {\n                            _this5.writable = true;\n                            _this5.emitReserved(\"drain\");\n                        });\n                    });\n                }\n            },\n            {\n                key: \"uri\",\n                value: function uri() {\n                    var schema = this.opts.secure ? \"https\" : \"http\";\n                    var query = this.query || {};\n                    // cache busting is forced\n                    if (false !== this.opts.timestampRequests) query[this.opts.timestampParam] = yeast();\n                    if (!this.supportsBinary && !query.sid) query.b64 = 1;\n                    return this.createUri(schema, query);\n                }\n            },\n            {\n                key: \"request\",\n                value: function request() {\n                    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n                    _extends(opts, {\n                        xd: this.xd,\n                        cookieJar: this.cookieJar\n                    }, this.opts);\n                    return new Request(this.uri(), opts);\n                }\n            },\n            {\n                key: \"doWrite\",\n                value: function doWrite(data, fn) {\n                    var _this6 = this;\n                    var req = this.request({\n                        method: \"POST\",\n                        data: data\n                    });\n                    req.on(\"success\", fn);\n                    req.on(\"error\", function(xhrStatus, context) {\n                        _this6.onError(\"xhr post error\", xhrStatus, context);\n                    });\n                }\n            },\n            {\n                key: \"doPoll\",\n                value: function doPoll() {\n                    var _this7 = this;\n                    var req = this.request();\n                    req.on(\"data\", this.onData.bind(this));\n                    req.on(\"error\", function(xhrStatus, context) {\n                        _this7.onError(\"xhr poll error\", xhrStatus, context);\n                    });\n                    this.pollXhr = req;\n                }\n            }\n        ]);\n        return Polling;\n    }(Transport);\n    var Request = /*#__PURE__*/ function(_Emitter) {\n        _inherits(Request, _Emitter);\n        var _super2 = _createSuper(Request);\n        /**\n     * Request constructor\n     *\n     * @param {Object} options\n     * @package\n     */ function Request(uri, opts) {\n            var _this8;\n            _classCallCheck(this, Request);\n            _this8 = _super2.call(this);\n            installTimerFunctions(_assertThisInitialized(_this8), opts);\n            _this8.opts = opts;\n            _this8.method = opts.method || \"GET\";\n            _this8.uri = uri;\n            _this8.data = undefined !== opts.data ? opts.data : null;\n            _this8.create();\n            return _this8;\n        }\n        /**\n     * Creates the XHR object and sends the request.\n     *\n     * @private\n     */ _createClass(Request, [\n            {\n                key: \"create\",\n                value: function create() {\n                    var _this9 = this;\n                    var _a;\n                    var opts = pick(this.opts, \"agent\", \"pfx\", \"key\", \"passphrase\", \"cert\", \"ca\", \"ciphers\", \"rejectUnauthorized\", \"autoUnref\");\n                    opts.xdomain = !!this.opts.xd;\n                    var xhr = this.xhr = new XHR(opts);\n                    try {\n                        xhr.open(this.method, this.uri, true);\n                        try {\n                            if (this.opts.extraHeaders) {\n                                xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);\n                                for(var i in this.opts.extraHeaders)if (this.opts.extraHeaders.hasOwnProperty(i)) xhr.setRequestHeader(i, this.opts.extraHeaders[i]);\n                            }\n                        } catch (e) {}\n                        if (\"POST\" === this.method) try {\n                            xhr.setRequestHeader(\"Content-type\", \"text/plain;charset=UTF-8\");\n                        } catch (e) {}\n                        try {\n                            xhr.setRequestHeader(\"Accept\", \"*/*\");\n                        } catch (e) {}\n                        (_a = this.opts.cookieJar) === null || _a === void 0 || _a.addCookies(xhr);\n                        // ie6 check\n                        if (\"withCredentials\" in xhr) xhr.withCredentials = this.opts.withCredentials;\n                        if (this.opts.requestTimeout) xhr.timeout = this.opts.requestTimeout;\n                        xhr.onreadystatechange = function() {\n                            var _a;\n                            if (xhr.readyState === 3) (_a = _this9.opts.cookieJar) === null || _a === void 0 || _a.parseCookies(xhr);\n                            if (4 !== xhr.readyState) return;\n                            if (200 === xhr.status || 1223 === xhr.status) _this9.onLoad();\n                            else // make sure the `error` event handler that's user-set\n                            // does not throw in the same tick and gets caught here\n                            _this9.setTimeoutFn(function() {\n                                _this9.onError(typeof xhr.status === \"number\" ? xhr.status : 0);\n                            }, 0);\n                        };\n                        xhr.send(this.data);\n                    } catch (e) {\n                        // Need to defer since .create() is called directly from the constructor\n                        // and thus the 'error' event can only be only bound *after* this exception\n                        // occurs.  Therefore, also, we cannot throw here at all.\n                        this.setTimeoutFn(function() {\n                            _this9.onError(e);\n                        }, 0);\n                        return;\n                    }\n                    if (typeof document !== \"undefined\") {\n                        this.index = Request.requestsCount++;\n                        Request.requests[this.index] = this;\n                    }\n                }\n            },\n            {\n                key: \"onError\",\n                value: function onError(err) {\n                    this.emitReserved(\"error\", err, this.xhr);\n                    this.cleanup(true);\n                }\n            },\n            {\n                key: \"cleanup\",\n                value: function cleanup(fromError) {\n                    if (\"undefined\" === typeof this.xhr || null === this.xhr) return;\n                    this.xhr.onreadystatechange = empty;\n                    if (fromError) try {\n                        this.xhr.abort();\n                    } catch (e) {}\n                    if (typeof document !== \"undefined\") delete Request.requests[this.index];\n                    this.xhr = null;\n                }\n            },\n            {\n                key: \"onLoad\",\n                value: function onLoad() {\n                    var data = this.xhr.responseText;\n                    if (data !== null) {\n                        this.emitReserved(\"data\", data);\n                        this.emitReserved(\"success\");\n                        this.cleanup();\n                    }\n                }\n            },\n            {\n                key: \"abort\",\n                value: function abort() {\n                    this.cleanup();\n                }\n            }\n        ]);\n        return Request;\n    }(Emitter);\n    Request.requestsCount = 0;\n    Request.requests = {};\n    /**\n   * Aborts pending requests when unloading the window. This is needed to prevent\n   * memory leaks (e.g. when using IE) and to ensure that no spurious error is\n   * emitted.\n   */ if (typeof document !== \"undefined\") {\n        // @ts-ignore\n        if (typeof attachEvent === \"function\") // @ts-ignore\n        attachEvent(\"onunload\", unloadHandler);\n        else if (typeof addEventListener === \"function\") {\n            var terminationEvent = \"onpagehide\" in globalThisShim ? \"pagehide\" : \"unload\";\n            addEventListener(terminationEvent, unloadHandler, false);\n        }\n    }\n    function unloadHandler() {\n        for(var i in Request.requests)if (Request.requests.hasOwnProperty(i)) Request.requests[i].abort();\n    }\n    var nextTick = function() {\n        var isPromiseAvailable = typeof Promise === \"function\" && typeof Promise.resolve === \"function\";\n        if (isPromiseAvailable) return function(cb) {\n            return Promise.resolve().then(cb);\n        };\n        else return function(cb, setTimeoutFn) {\n            return setTimeoutFn(cb, 0);\n        };\n    }();\n    var WebSocket = globalThisShim.WebSocket || globalThisShim.MozWebSocket;\n    var usingBrowserWebSocket = true;\n    var defaultBinaryType = \"arraybuffer\";\n    // detect ReactNative environment\n    var isReactNative = typeof navigator !== \"undefined\" && typeof navigator.product === \"string\" && navigator.product.toLowerCase() === \"reactnative\";\n    var WS = /*#__PURE__*/ function(_Transport) {\n        _inherits(WS, _Transport);\n        var _super = _createSuper(WS);\n        /**\n     * WebSocket transport constructor.\n     *\n     * @param {Object} opts - connection options\n     * @protected\n     */ function WS(opts) {\n            var _this;\n            _classCallCheck(this, WS);\n            _this = _super.call(this, opts);\n            _this.supportsBinary = !opts.forceBase64;\n            return _this;\n        }\n        _createClass(WS, [\n            {\n                key: \"name\",\n                get: function get() {\n                    return \"websocket\";\n                }\n            },\n            {\n                key: \"doOpen\",\n                value: function doOpen() {\n                    if (!this.check()) // let probe timeout\n                    return;\n                    var uri = this.uri();\n                    var protocols = this.opts.protocols;\n                    // React Native only supports the 'headers' option, and will print a warning if anything else is passed\n                    var opts = isReactNative ? {} : pick(this.opts, \"agent\", \"perMessageDeflate\", \"pfx\", \"key\", \"passphrase\", \"cert\", \"ca\", \"ciphers\", \"rejectUnauthorized\", \"localAddress\", \"protocolVersion\", \"origin\", \"maxPayload\", \"family\", \"checkServerIdentity\");\n                    if (this.opts.extraHeaders) opts.headers = this.opts.extraHeaders;\n                    try {\n                        this.ws = usingBrowserWebSocket && !isReactNative ? protocols ? new WebSocket(uri, protocols) : new WebSocket(uri) : new WebSocket(uri, protocols, opts);\n                    } catch (err) {\n                        return this.emitReserved(\"error\", err);\n                    }\n                    this.ws.binaryType = this.socket.binaryType;\n                    this.addEventListeners();\n                }\n            },\n            {\n                key: \"addEventListeners\",\n                value: function addEventListeners() {\n                    var _this2 = this;\n                    this.ws.onopen = function() {\n                        if (_this2.opts.autoUnref) _this2.ws._socket.unref();\n                        _this2.onOpen();\n                    };\n                    this.ws.onclose = function(closeEvent) {\n                        return _this2.onClose({\n                            description: \"websocket connection closed\",\n                            context: closeEvent\n                        });\n                    };\n                    this.ws.onmessage = function(ev) {\n                        return _this2.onData(ev.data);\n                    };\n                    this.ws.onerror = function(e) {\n                        return _this2.onError(\"websocket error\", e);\n                    };\n                }\n            },\n            {\n                key: \"write\",\n                value: function write(packets) {\n                    var _this3 = this;\n                    this.writable = false;\n                    // encodePacket efficient as it uses WS framing\n                    // no need for encodePayload\n                    var _loop = function _loop() {\n                        var packet = packets[i];\n                        var lastPacket = i === packets.length - 1;\n                        encodePacket(packet, _this3.supportsBinary, function(data) {\n                            // always create a new object (GH-437)\n                            var opts = {};\n                            // Sometimes the websocket has already been closed but the browser didn't\n                            // have a chance of informing us about it yet, in that case send will\n                            // throw an error\n                            try {\n                                if (usingBrowserWebSocket) // TypeError is thrown when passing the second argument on Safari\n                                _this3.ws.send(data);\n                            } catch (e) {}\n                            if (lastPacket) // fake drain\n                            // defer to next tick to allow Socket to clear writeBuffer\n                            nextTick(function() {\n                                _this3.writable = true;\n                                _this3.emitReserved(\"drain\");\n                            }, _this3.setTimeoutFn);\n                        });\n                    };\n                    for(var i = 0; i < packets.length; i++)_loop();\n                }\n            },\n            {\n                key: \"doClose\",\n                value: function doClose() {\n                    if (typeof this.ws !== \"undefined\") {\n                        this.ws.close();\n                        this.ws = null;\n                    }\n                }\n            },\n            {\n                key: \"uri\",\n                value: function uri() {\n                    var schema = this.opts.secure ? \"wss\" : \"ws\";\n                    var query = this.query || {};\n                    // append timestamp to URI\n                    if (this.opts.timestampRequests) query[this.opts.timestampParam] = yeast();\n                    // communicate binary support capabilities\n                    if (!this.supportsBinary) query.b64 = 1;\n                    return this.createUri(schema, query);\n                }\n            },\n            {\n                key: \"check\",\n                value: function check() {\n                    return !!WebSocket;\n                }\n            }\n        ]);\n        return WS;\n    }(Transport);\n    var WT = /*#__PURE__*/ function(_Transport) {\n        _inherits(WT, _Transport);\n        var _super = _createSuper(WT);\n        function WT() {\n            _classCallCheck(this, WT);\n            return _super.apply(this, arguments);\n        }\n        _createClass(WT, [\n            {\n                key: \"name\",\n                get: function get() {\n                    return \"webtransport\";\n                }\n            },\n            {\n                key: \"doOpen\",\n                value: function doOpen() {\n                    var _this = this;\n                    // @ts-ignore\n                    if (typeof WebTransport !== \"function\") return;\n                    // @ts-ignore\n                    this.transport = new WebTransport(this.createUri(\"https\"), this.opts.transportOptions[this.name]);\n                    this.transport.closed.then(function() {\n                        _this.onClose();\n                    })[\"catch\"](function(err) {\n                        _this.onError(\"webtransport error\", err);\n                    });\n                    // note: we could have used async/await, but that would require some additional polyfills\n                    this.transport.ready.then(function() {\n                        _this.transport.createBidirectionalStream().then(function(stream) {\n                            var decoderStream = createPacketDecoderStream(Number.MAX_SAFE_INTEGER, _this.socket.binaryType);\n                            var reader = stream.readable.pipeThrough(decoderStream).getReader();\n                            var encoderStream = createPacketEncoderStream();\n                            encoderStream.readable.pipeTo(stream.writable);\n                            _this.writer = encoderStream.writable.getWriter();\n                            var read = function read() {\n                                reader.read().then(function(_ref) {\n                                    var done = _ref.done, value = _ref.value;\n                                    if (done) return;\n                                    _this.onPacket(value);\n                                    read();\n                                })[\"catch\"](function(err) {});\n                            };\n                            read();\n                            var packet = {\n                                type: \"open\"\n                            };\n                            if (_this.query.sid) packet.data = '{\"sid\":\"'.concat(_this.query.sid, '\"}');\n                            _this.writer.write(packet).then(function() {\n                                return _this.onOpen();\n                            });\n                        });\n                    });\n                }\n            },\n            {\n                key: \"write\",\n                value: function write(packets) {\n                    var _this2 = this;\n                    this.writable = false;\n                    var _loop = function _loop() {\n                        var packet = packets[i];\n                        var lastPacket = i === packets.length - 1;\n                        _this2.writer.write(packet).then(function() {\n                            if (lastPacket) nextTick(function() {\n                                _this2.writable = true;\n                                _this2.emitReserved(\"drain\");\n                            }, _this2.setTimeoutFn);\n                        });\n                    };\n                    for(var i = 0; i < packets.length; i++)_loop();\n                }\n            },\n            {\n                key: \"doClose\",\n                value: function doClose() {\n                    var _a;\n                    (_a = this.transport) === null || _a === void 0 || _a.close();\n                }\n            }\n        ]);\n        return WT;\n    }(Transport);\n    var transports = {\n        websocket: WS,\n        webtransport: WT,\n        polling: Polling\n    };\n    // imported from https://github.com/galkn/parseuri\n    /**\n   * Parses a URI\n   *\n   * Note: we could also have used the built-in URL object, but it isn't supported on all platforms.\n   *\n   * See:\n   * - https://developer.mozilla.org/en-US/docs/Web/API/URL\n   * - https://caniuse.com/url\n   * - https://www.rfc-editor.org/rfc/rfc3986#appendix-B\n   *\n   * History of the parse() method:\n   * - first commit: https://github.com/socketio/socket.io-client/commit/4ee1d5d94b3906a9c052b459f1a818b15f38f91c\n   * - export into its own module: https://github.com/socketio/engine.io-client/commit/de2c561e4564efeb78f1bdb1ba39ef81b2822cb3\n   * - reimport: https://github.com/socketio/engine.io-client/commit/df32277c3f6d622eec5ed09f493cae3f3391d242\n   *\n   * @author Steven Levithan <stevenlevithan.com> (MIT license)\n   * @api private\n   */ var re = /^(?:(?![^:@\\/?#]+:[^:@\\/]*@)(http|https|ws|wss):\\/\\/)?((?:(([^:@\\/?#]*)(?::([^:@\\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\n    var parts = [\n        \"source\",\n        \"protocol\",\n        \"authority\",\n        \"userInfo\",\n        \"user\",\n        \"password\",\n        \"host\",\n        \"port\",\n        \"relative\",\n        \"path\",\n        \"directory\",\n        \"file\",\n        \"query\",\n        \"anchor\"\n    ];\n    function parse(str) {\n        var src = str, b = str.indexOf(\"[\"), e = str.indexOf(\"]\");\n        if (b != -1 && e != -1) str = str.substring(0, b) + str.substring(b, e).replace(/:/g, \";\") + str.substring(e, str.length);\n        var m = re.exec(str || \"\"), uri = {}, i = 14;\n        while(i--)uri[parts[i]] = m[i] || \"\";\n        if (b != -1 && e != -1) {\n            uri.source = src;\n            uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, \":\");\n            uri.authority = uri.authority.replace(\"[\", \"\").replace(\"]\", \"\").replace(/;/g, \":\");\n            uri.ipv6uri = true;\n        }\n        uri.pathNames = pathNames(uri, uri[\"path\"]);\n        uri.queryKey = queryKey(uri, uri[\"query\"]);\n        return uri;\n    }\n    function pathNames(obj, path) {\n        var regx = /\\/{2,9}/g, names = path.replace(regx, \"/\").split(\"/\");\n        if (path.slice(0, 1) == \"/\" || path.length === 0) names.splice(0, 1);\n        if (path.slice(-1) == \"/\") names.splice(names.length - 1, 1);\n        return names;\n    }\n    function queryKey(uri, query) {\n        var data = {};\n        query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function($0, $1, $2) {\n            if ($1) data[$1] = $2;\n        });\n        return data;\n    }\n    var Socket$1 = /*#__PURE__*/ function(_Emitter) {\n        _inherits(Socket, _Emitter);\n        var _super = _createSuper(Socket);\n        /**\n     * Socket constructor.\n     *\n     * @param {String|Object} uri - uri or options\n     * @param {Object} opts - options\n     */ function Socket(uri) {\n            var _this;\n            var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n            _classCallCheck(this, Socket);\n            _this = _super.call(this);\n            _this.binaryType = defaultBinaryType;\n            _this.writeBuffer = [];\n            if (uri && \"object\" === _typeof(uri)) {\n                opts = uri;\n                uri = null;\n            }\n            if (uri) {\n                uri = parse(uri);\n                opts.hostname = uri.host;\n                opts.secure = uri.protocol === \"https\" || uri.protocol === \"wss\";\n                opts.port = uri.port;\n                if (uri.query) opts.query = uri.query;\n            } else if (opts.host) opts.hostname = parse(opts.host).host;\n            installTimerFunctions(_assertThisInitialized(_this), opts);\n            _this.secure = null != opts.secure ? opts.secure : typeof location !== \"undefined\" && \"https:\" === location.protocol;\n            if (opts.hostname && !opts.port) // if no port is specified manually, use the protocol default\n            opts.port = _this.secure ? \"443\" : \"80\";\n            _this.hostname = opts.hostname || (typeof location !== \"undefined\" ? location.hostname : \"localhost\");\n            _this.port = opts.port || (typeof location !== \"undefined\" && location.port ? location.port : _this.secure ? \"443\" : \"80\");\n            _this.transports = opts.transports || [\n                \"polling\",\n                \"websocket\",\n                \"webtransport\"\n            ];\n            _this.writeBuffer = [];\n            _this.prevBufferLen = 0;\n            _this.opts = _extends({\n                path: \"/engine.io\",\n                agent: false,\n                withCredentials: false,\n                upgrade: true,\n                timestampParam: \"t\",\n                rememberUpgrade: false,\n                addTrailingSlash: true,\n                rejectUnauthorized: true,\n                perMessageDeflate: {\n                    threshold: 1024\n                },\n                transportOptions: {},\n                closeOnBeforeunload: false\n            }, opts);\n            _this.opts.path = _this.opts.path.replace(/\\/$/, \"\") + (_this.opts.addTrailingSlash ? \"/\" : \"\");\n            if (typeof _this.opts.query === \"string\") _this.opts.query = decode(_this.opts.query);\n            // set on handshake\n            _this.id = null;\n            _this.upgrades = null;\n            _this.pingInterval = null;\n            _this.pingTimeout = null;\n            // set on heartbeat\n            _this.pingTimeoutTimer = null;\n            if (typeof addEventListener === \"function\") {\n                if (_this.opts.closeOnBeforeunload) {\n                    // Firefox closes the connection when the \"beforeunload\" event is emitted but not Chrome. This event listener\n                    // ensures every browser behaves the same (no \"disconnect\" event at the Socket.IO level when the page is\n                    // closed/reloaded)\n                    _this.beforeunloadEventListener = function() {\n                        if (_this.transport) {\n                            // silently close the transport\n                            _this.transport.removeAllListeners();\n                            _this.transport.close();\n                        }\n                    };\n                    addEventListener(\"beforeunload\", _this.beforeunloadEventListener, false);\n                }\n                if (_this.hostname !== \"localhost\") {\n                    _this.offlineEventListener = function() {\n                        _this.onClose(\"transport close\", {\n                            description: \"network connection lost\"\n                        });\n                    };\n                    addEventListener(\"offline\", _this.offlineEventListener, false);\n                }\n            }\n            _this.open();\n            return _this;\n        }\n        /**\n     * Creates transport of the given type.\n     *\n     * @param {String} name - transport name\n     * @return {Transport}\n     * @private\n     */ _createClass(Socket, [\n            {\n                key: \"createTransport\",\n                value: function createTransport(name) {\n                    var query = _extends({}, this.opts.query);\n                    // append engine.io protocol identifier\n                    query.EIO = protocol$1;\n                    // transport name\n                    query.transport = name;\n                    // session id if we already have one\n                    if (this.id) query.sid = this.id;\n                    var opts = _extends({}, this.opts, {\n                        query: query,\n                        socket: this,\n                        hostname: this.hostname,\n                        secure: this.secure,\n                        port: this.port\n                    }, this.opts.transportOptions[name]);\n                    return new transports[name](opts);\n                }\n            },\n            {\n                key: \"open\",\n                value: function open() {\n                    var _this2 = this;\n                    var transport;\n                    if (this.opts.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf(\"websocket\") !== -1) transport = \"websocket\";\n                    else if (0 === this.transports.length) {\n                        // Emit error on next tick so it can be listened to\n                        this.setTimeoutFn(function() {\n                            _this2.emitReserved(\"error\", \"No transports available\");\n                        }, 0);\n                        return;\n                    } else transport = this.transports[0];\n                    this.readyState = \"opening\";\n                    // Retry with the next transport if the transport is disabled (jsonp: false)\n                    try {\n                        transport = this.createTransport(transport);\n                    } catch (e) {\n                        this.transports.shift();\n                        this.open();\n                        return;\n                    }\n                    transport.open();\n                    this.setTransport(transport);\n                }\n            },\n            {\n                key: \"setTransport\",\n                value: function setTransport(transport) {\n                    var _this3 = this;\n                    if (this.transport) this.transport.removeAllListeners();\n                    // set up transport\n                    this.transport = transport;\n                    // set up transport listeners\n                    transport.on(\"drain\", this.onDrain.bind(this)).on(\"packet\", this.onPacket.bind(this)).on(\"error\", this.onError.bind(this)).on(\"close\", function(reason) {\n                        return _this3.onClose(\"transport close\", reason);\n                    });\n                }\n            },\n            {\n                key: \"probe\",\n                value: function probe(name) {\n                    var _this4 = this;\n                    var transport = this.createTransport(name);\n                    var failed = false;\n                    Socket.priorWebsocketSuccess = false;\n                    var onTransportOpen = function onTransportOpen() {\n                        if (failed) return;\n                        transport.send([\n                            {\n                                type: \"ping\",\n                                data: \"probe\"\n                            }\n                        ]);\n                        transport.once(\"packet\", function(msg) {\n                            if (failed) return;\n                            if (\"pong\" === msg.type && \"probe\" === msg.data) {\n                                _this4.upgrading = true;\n                                _this4.emitReserved(\"upgrading\", transport);\n                                if (!transport) return;\n                                Socket.priorWebsocketSuccess = \"websocket\" === transport.name;\n                                _this4.transport.pause(function() {\n                                    if (failed) return;\n                                    if (\"closed\" === _this4.readyState) return;\n                                    cleanup();\n                                    _this4.setTransport(transport);\n                                    transport.send([\n                                        {\n                                            type: \"upgrade\"\n                                        }\n                                    ]);\n                                    _this4.emitReserved(\"upgrade\", transport);\n                                    transport = null;\n                                    _this4.upgrading = false;\n                                    _this4.flush();\n                                });\n                            } else {\n                                var err = new Error(\"probe error\");\n                                // @ts-ignore\n                                err.transport = transport.name;\n                                _this4.emitReserved(\"upgradeError\", err);\n                            }\n                        });\n                    };\n                    function freezeTransport() {\n                        if (failed) return;\n                        // Any callback called by transport should be ignored since now\n                        failed = true;\n                        cleanup();\n                        transport.close();\n                        transport = null;\n                    }\n                    // Handle any error that happens while probing\n                    var onerror = function onerror(err) {\n                        var error = new Error(\"probe error: \" + err);\n                        // @ts-ignore\n                        error.transport = transport.name;\n                        freezeTransport();\n                        _this4.emitReserved(\"upgradeError\", error);\n                    };\n                    function onTransportClose() {\n                        onerror(\"transport closed\");\n                    }\n                    // When the socket is closed while we're probing\n                    function onclose() {\n                        onerror(\"socket closed\");\n                    }\n                    // When the socket is upgraded while we're probing\n                    function onupgrade(to) {\n                        if (transport && to.name !== transport.name) freezeTransport();\n                    }\n                    // Remove all listeners on the transport and on self\n                    var cleanup = function cleanup() {\n                        transport.removeListener(\"open\", onTransportOpen);\n                        transport.removeListener(\"error\", onerror);\n                        transport.removeListener(\"close\", onTransportClose);\n                        _this4.off(\"close\", onclose);\n                        _this4.off(\"upgrading\", onupgrade);\n                    };\n                    transport.once(\"open\", onTransportOpen);\n                    transport.once(\"error\", onerror);\n                    transport.once(\"close\", onTransportClose);\n                    this.once(\"close\", onclose);\n                    this.once(\"upgrading\", onupgrade);\n                    if (this.upgrades.indexOf(\"webtransport\") !== -1 && name !== \"webtransport\") // favor WebTransport\n                    this.setTimeoutFn(function() {\n                        if (!failed) transport.open();\n                    }, 200);\n                    else transport.open();\n                }\n            },\n            {\n                key: \"onOpen\",\n                value: function onOpen() {\n                    this.readyState = \"open\";\n                    Socket.priorWebsocketSuccess = \"websocket\" === this.transport.name;\n                    this.emitReserved(\"open\");\n                    this.flush();\n                    // we check for `readyState` in case an `open`\n                    // listener already closed the socket\n                    if (\"open\" === this.readyState && this.opts.upgrade) {\n                        var i = 0;\n                        var l = this.upgrades.length;\n                        for(; i < l; i++)this.probe(this.upgrades[i]);\n                    }\n                }\n            },\n            {\n                key: \"onPacket\",\n                value: function onPacket(packet) {\n                    if (\"opening\" === this.readyState || \"open\" === this.readyState || \"closing\" === this.readyState) {\n                        this.emitReserved(\"packet\", packet);\n                        // Socket is live - any packet counts\n                        this.emitReserved(\"heartbeat\");\n                        this.resetPingTimeout();\n                        switch(packet.type){\n                            case \"open\":\n                                this.onHandshake(JSON.parse(packet.data));\n                                break;\n                            case \"ping\":\n                                this.sendPacket(\"pong\");\n                                this.emitReserved(\"ping\");\n                                this.emitReserved(\"pong\");\n                                break;\n                            case \"error\":\n                                var err = new Error(\"server error\");\n                                // @ts-ignore\n                                err.code = packet.data;\n                                this.onError(err);\n                                break;\n                            case \"message\":\n                                this.emitReserved(\"data\", packet.data);\n                                this.emitReserved(\"message\", packet.data);\n                                break;\n                        }\n                    }\n                }\n            },\n            {\n                key: \"onHandshake\",\n                value: function onHandshake(data) {\n                    this.emitReserved(\"handshake\", data);\n                    this.id = data.sid;\n                    this.transport.query.sid = data.sid;\n                    this.upgrades = this.filterUpgrades(data.upgrades);\n                    this.pingInterval = data.pingInterval;\n                    this.pingTimeout = data.pingTimeout;\n                    this.maxPayload = data.maxPayload;\n                    this.onOpen();\n                    // In case open handler closes socket\n                    if (\"closed\" === this.readyState) return;\n                    this.resetPingTimeout();\n                }\n            },\n            {\n                key: \"resetPingTimeout\",\n                value: function resetPingTimeout() {\n                    var _this5 = this;\n                    this.clearTimeoutFn(this.pingTimeoutTimer);\n                    this.pingTimeoutTimer = this.setTimeoutFn(function() {\n                        _this5.onClose(\"ping timeout\");\n                    }, this.pingInterval + this.pingTimeout);\n                    if (this.opts.autoUnref) this.pingTimeoutTimer.unref();\n                }\n            },\n            {\n                key: \"onDrain\",\n                value: function onDrain() {\n                    this.writeBuffer.splice(0, this.prevBufferLen);\n                    // setting prevBufferLen = 0 is very important\n                    // for example, when upgrading, upgrade packet is sent over,\n                    // and a nonzero prevBufferLen could cause problems on `drain`\n                    this.prevBufferLen = 0;\n                    if (0 === this.writeBuffer.length) this.emitReserved(\"drain\");\n                    else this.flush();\n                }\n            },\n            {\n                key: \"flush\",\n                value: function flush() {\n                    if (\"closed\" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {\n                        var packets = this.getWritablePackets();\n                        this.transport.send(packets);\n                        // keep track of current length of writeBuffer\n                        // splice writeBuffer and callbackBuffer on `drain`\n                        this.prevBufferLen = packets.length;\n                        this.emitReserved(\"flush\");\n                    }\n                }\n            },\n            {\n                key: \"getWritablePackets\",\n                value: function getWritablePackets() {\n                    var shouldCheckPayloadSize = this.maxPayload && this.transport.name === \"polling\" && this.writeBuffer.length > 1;\n                    if (!shouldCheckPayloadSize) return this.writeBuffer;\n                    var payloadSize = 1; // first packet type\n                    for(var i = 0; i < this.writeBuffer.length; i++){\n                        var data = this.writeBuffer[i].data;\n                        if (data) payloadSize += byteLength(data);\n                        if (i > 0 && payloadSize > this.maxPayload) return this.writeBuffer.slice(0, i);\n                        payloadSize += 2; // separator + packet type\n                    }\n                    return this.writeBuffer;\n                }\n            },\n            {\n                key: \"write\",\n                value: function write(msg, options, fn) {\n                    this.sendPacket(\"message\", msg, options, fn);\n                    return this;\n                }\n            },\n            {\n                key: \"send\",\n                value: function send(msg, options, fn) {\n                    this.sendPacket(\"message\", msg, options, fn);\n                    return this;\n                }\n            },\n            {\n                key: \"sendPacket\",\n                value: function sendPacket(type, data, options, fn) {\n                    if (\"function\" === typeof data) {\n                        fn = data;\n                        data = undefined;\n                    }\n                    if (\"function\" === typeof options) {\n                        fn = options;\n                        options = null;\n                    }\n                    if (\"closing\" === this.readyState || \"closed\" === this.readyState) return;\n                    options = options || {};\n                    options.compress = false !== options.compress;\n                    var packet = {\n                        type: type,\n                        data: data,\n                        options: options\n                    };\n                    this.emitReserved(\"packetCreate\", packet);\n                    this.writeBuffer.push(packet);\n                    if (fn) this.once(\"flush\", fn);\n                    this.flush();\n                }\n            },\n            {\n                key: \"close\",\n                value: function close() {\n                    var _this6 = this;\n                    var close = function close() {\n                        _this6.onClose(\"forced close\");\n                        _this6.transport.close();\n                    };\n                    var cleanupAndClose = function cleanupAndClose() {\n                        _this6.off(\"upgrade\", cleanupAndClose);\n                        _this6.off(\"upgradeError\", cleanupAndClose);\n                        close();\n                    };\n                    var waitForUpgrade = function waitForUpgrade() {\n                        // wait for upgrade to finish since we can't send packets while pausing a transport\n                        _this6.once(\"upgrade\", cleanupAndClose);\n                        _this6.once(\"upgradeError\", cleanupAndClose);\n                    };\n                    if (\"opening\" === this.readyState || \"open\" === this.readyState) {\n                        this.readyState = \"closing\";\n                        if (this.writeBuffer.length) this.once(\"drain\", function() {\n                            if (_this6.upgrading) waitForUpgrade();\n                            else close();\n                        });\n                        else if (this.upgrading) waitForUpgrade();\n                        else close();\n                    }\n                    return this;\n                }\n            },\n            {\n                key: \"onError\",\n                value: function onError(err) {\n                    Socket.priorWebsocketSuccess = false;\n                    this.emitReserved(\"error\", err);\n                    this.onClose(\"transport error\", err);\n                }\n            },\n            {\n                key: \"onClose\",\n                value: function onClose(reason, description) {\n                    if (\"opening\" === this.readyState || \"open\" === this.readyState || \"closing\" === this.readyState) {\n                        // clear timers\n                        this.clearTimeoutFn(this.pingTimeoutTimer);\n                        // stop event from firing again for transport\n                        this.transport.removeAllListeners(\"close\");\n                        // ensure transport won't stay open\n                        this.transport.close();\n                        // ignore further transport communication\n                        this.transport.removeAllListeners();\n                        if (typeof removeEventListener === \"function\") {\n                            removeEventListener(\"beforeunload\", this.beforeunloadEventListener, false);\n                            removeEventListener(\"offline\", this.offlineEventListener, false);\n                        }\n                        // set ready state\n                        this.readyState = \"closed\";\n                        // clear session id\n                        this.id = null;\n                        // emit close event\n                        this.emitReserved(\"close\", reason, description);\n                        // clean buffers after, so users can still\n                        // grab the buffers on `close` event\n                        this.writeBuffer = [];\n                        this.prevBufferLen = 0;\n                    }\n                }\n            },\n            {\n                key: \"filterUpgrades\",\n                value: function filterUpgrades(upgrades) {\n                    var filteredUpgrades = [];\n                    var i = 0;\n                    var j = upgrades.length;\n                    for(; i < j; i++)if (~this.transports.indexOf(upgrades[i])) filteredUpgrades.push(upgrades[i]);\n                    return filteredUpgrades;\n                }\n            }\n        ]);\n        return Socket;\n    }(Emitter);\n    Socket$1.protocol = protocol$1;\n    Socket$1.protocol;\n    /**\n   * URL parser.\n   *\n   * @param uri - url\n   * @param path - the request path of the connection\n   * @param loc - An object meant to mimic window.location.\n   *        Defaults to window.location.\n   * @public\n   */ function url(uri) {\n        var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n        var loc = arguments.length > 2 ? arguments[2] : undefined;\n        var obj = uri;\n        // default to window.location\n        loc = loc || typeof location !== \"undefined\" && location;\n        if (null == uri) uri = loc.protocol + \"//\" + loc.host;\n        // relative path support\n        if (typeof uri === \"string\") {\n            if (\"/\" === uri.charAt(0)) {\n                if (\"/\" === uri.charAt(1)) uri = loc.protocol + uri;\n                else uri = loc.host + uri;\n            }\n            if (!/^(https?|wss?):\\/\\//.test(uri)) {\n                if (\"undefined\" !== typeof loc) uri = loc.protocol + \"//\" + uri;\n                else uri = \"https://\" + uri;\n            }\n            // parse\n            obj = parse(uri);\n        }\n        // make sure we treat `localhost:80` and `localhost` equally\n        if (!obj.port) {\n            if (/^(http|ws)$/.test(obj.protocol)) obj.port = \"80\";\n            else if (/^(http|ws)s$/.test(obj.protocol)) obj.port = \"443\";\n        }\n        obj.path = obj.path || \"/\";\n        var ipv6 = obj.host.indexOf(\":\") !== -1;\n        var host = ipv6 ? \"[\" + obj.host + \"]\" : obj.host;\n        // define unique id\n        obj.id = obj.protocol + \"://\" + host + \":\" + obj.port + path;\n        // define href\n        obj.href = obj.protocol + \"://\" + host + (loc && loc.port === obj.port ? \"\" : \":\" + obj.port);\n        return obj;\n    }\n    var withNativeArrayBuffer = typeof ArrayBuffer === \"function\";\n    var isView = function isView(obj) {\n        return typeof ArrayBuffer.isView === \"function\" ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;\n    };\n    var toString = Object.prototype.toString;\n    var withNativeBlob = typeof Blob === \"function\" || typeof Blob !== \"undefined\" && toString.call(Blob) === \"[object BlobConstructor]\";\n    var withNativeFile = typeof File === \"function\" || typeof File !== \"undefined\" && toString.call(File) === \"[object FileConstructor]\";\n    /**\n   * Returns true if obj is a Buffer, an ArrayBuffer, a Blob or a File.\n   *\n   * @private\n   */ function isBinary(obj) {\n        return withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj)) || withNativeBlob && obj instanceof Blob || withNativeFile && obj instanceof File;\n    }\n    function hasBinary(obj, toJSON) {\n        if (!obj || _typeof(obj) !== \"object\") return false;\n        if (Array.isArray(obj)) {\n            for(var i = 0, l = obj.length; i < l; i++){\n                if (hasBinary(obj[i])) return true;\n            }\n            return false;\n        }\n        if (isBinary(obj)) return true;\n        if (obj.toJSON && typeof obj.toJSON === \"function\" && arguments.length === 1) return hasBinary(obj.toJSON(), true);\n        for(var key in obj){\n            if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) return true;\n        }\n        return false;\n    }\n    /**\n   * Replaces every Buffer | ArrayBuffer | Blob | File in packet with a numbered placeholder.\n   *\n   * @param {Object} packet - socket.io event packet\n   * @return {Object} with deconstructed packet and list of buffers\n   * @public\n   */ function deconstructPacket(packet) {\n        var buffers = [];\n        var packetData = packet.data;\n        var pack = packet;\n        pack.data = _deconstructPacket(packetData, buffers);\n        pack.attachments = buffers.length; // number of binary 'attachments'\n        return {\n            packet: pack,\n            buffers: buffers\n        };\n    }\n    function _deconstructPacket(data, buffers) {\n        if (!data) return data;\n        if (isBinary(data)) {\n            var placeholder = {\n                _placeholder: true,\n                num: buffers.length\n            };\n            buffers.push(data);\n            return placeholder;\n        } else if (Array.isArray(data)) {\n            var newData = new Array(data.length);\n            for(var i = 0; i < data.length; i++)newData[i] = _deconstructPacket(data[i], buffers);\n            return newData;\n        } else if (_typeof(data) === \"object\" && !(data instanceof Date)) {\n            var _newData = {};\n            for(var key in data)if (Object.prototype.hasOwnProperty.call(data, key)) _newData[key] = _deconstructPacket(data[key], buffers);\n            return _newData;\n        }\n        return data;\n    }\n    /**\n   * Reconstructs a binary packet from its placeholder packet and buffers\n   *\n   * @param {Object} packet - event packet with placeholders\n   * @param {Array} buffers - binary buffers to put in placeholder positions\n   * @return {Object} reconstructed packet\n   * @public\n   */ function reconstructPacket(packet, buffers) {\n        packet.data = _reconstructPacket(packet.data, buffers);\n        delete packet.attachments; // no longer useful\n        return packet;\n    }\n    function _reconstructPacket(data, buffers) {\n        if (!data) return data;\n        if (data && data._placeholder === true) {\n            var isIndexValid = typeof data.num === \"number\" && data.num >= 0 && data.num < buffers.length;\n            if (isIndexValid) return buffers[data.num]; // appropriate buffer (should be natural order anyway)\n            else throw new Error(\"illegal attachments\");\n        } else if (Array.isArray(data)) for(var i = 0; i < data.length; i++)data[i] = _reconstructPacket(data[i], buffers);\n        else if (_typeof(data) === \"object\") {\n            for(var key in data)if (Object.prototype.hasOwnProperty.call(data, key)) data[key] = _reconstructPacket(data[key], buffers);\n        }\n        return data;\n    }\n    /**\n   * These strings must not be used as event names, as they have a special meaning.\n   */ var RESERVED_EVENTS$1 = [\n        \"connect\",\n        \"connect_error\",\n        \"disconnect\",\n        \"disconnecting\",\n        \"newListener\",\n        \"removeListener\" // used by the Node.js EventEmitter\n    ];\n    /**\n   * Protocol version.\n   *\n   * @public\n   */ var protocol = 5;\n    var PacketType;\n    (function(PacketType) {\n        PacketType[PacketType[\"CONNECT\"] = 0] = \"CONNECT\";\n        PacketType[PacketType[\"DISCONNECT\"] = 1] = \"DISCONNECT\";\n        PacketType[PacketType[\"EVENT\"] = 2] = \"EVENT\";\n        PacketType[PacketType[\"ACK\"] = 3] = \"ACK\";\n        PacketType[PacketType[\"CONNECT_ERROR\"] = 4] = \"CONNECT_ERROR\";\n        PacketType[PacketType[\"BINARY_EVENT\"] = 5] = \"BINARY_EVENT\";\n        PacketType[PacketType[\"BINARY_ACK\"] = 6] = \"BINARY_ACK\";\n    })(PacketType || (PacketType = {}));\n    /**\n   * A socket.io Encoder instance\n   */ var Encoder = /*#__PURE__*/ function() {\n        /**\n     * Encoder constructor\n     *\n     * @param {function} replacer - custom replacer to pass down to JSON.parse\n     */ function Encoder(replacer) {\n            _classCallCheck(this, Encoder);\n            this.replacer = replacer;\n        }\n        /**\n     * Encode a packet as a single string if non-binary, or as a\n     * buffer sequence, depending on packet type.\n     *\n     * @param {Object} obj - packet object\n     */ _createClass(Encoder, [\n            {\n                key: \"encode\",\n                value: function encode(obj) {\n                    if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {\n                        if (hasBinary(obj)) return this.encodeAsBinary({\n                            type: obj.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK,\n                            nsp: obj.nsp,\n                            data: obj.data,\n                            id: obj.id\n                        });\n                    }\n                    return [\n                        this.encodeAsString(obj)\n                    ];\n                }\n            },\n            {\n                key: \"encodeAsString\",\n                value: function encodeAsString(obj) {\n                    // first is type\n                    var str = \"\" + obj.type;\n                    // attachments if we have them\n                    if (obj.type === PacketType.BINARY_EVENT || obj.type === PacketType.BINARY_ACK) str += obj.attachments + \"-\";\n                    // if we have a namespace other than `/`\n                    // we append it followed by a comma `,`\n                    if (obj.nsp && \"/\" !== obj.nsp) str += obj.nsp + \",\";\n                    // immediately followed by the id\n                    if (null != obj.id) str += obj.id;\n                    // json data\n                    if (null != obj.data) str += JSON.stringify(obj.data, this.replacer);\n                    return str;\n                }\n            },\n            {\n                key: \"encodeAsBinary\",\n                value: function encodeAsBinary(obj) {\n                    var deconstruction = deconstructPacket(obj);\n                    var pack = this.encodeAsString(deconstruction.packet);\n                    var buffers = deconstruction.buffers;\n                    buffers.unshift(pack); // add packet info to beginning of data list\n                    return buffers; // write all the buffers\n                }\n            }\n        ]);\n        return Encoder;\n    }();\n    // see https://stackoverflow.com/questions/8511281/check-if-a-value-is-an-object-in-javascript\n    function isObject(value) {\n        return Object.prototype.toString.call(value) === \"[object Object]\";\n    }\n    /**\n   * A socket.io Decoder instance\n   *\n   * @return {Object} decoder\n   */ var Decoder = /*#__PURE__*/ function(_Emitter) {\n        _inherits(Decoder, _Emitter);\n        var _super = _createSuper(Decoder);\n        /**\n     * Decoder constructor\n     *\n     * @param {function} reviver - custom reviver to pass down to JSON.stringify\n     */ function Decoder(reviver) {\n            var _this;\n            _classCallCheck(this, Decoder);\n            _this = _super.call(this);\n            _this.reviver = reviver;\n            return _this;\n        }\n        /**\n     * Decodes an encoded packet string into packet JSON.\n     *\n     * @param {String} obj - encoded packet\n     */ _createClass(Decoder, [\n            {\n                key: \"add\",\n                value: function add(obj) {\n                    var packet;\n                    if (typeof obj === \"string\") {\n                        if (this.reconstructor) throw new Error(\"got plaintext data when reconstructing a packet\");\n                        packet = this.decodeString(obj);\n                        var isBinaryEvent = packet.type === PacketType.BINARY_EVENT;\n                        if (isBinaryEvent || packet.type === PacketType.BINARY_ACK) {\n                            packet.type = isBinaryEvent ? PacketType.EVENT : PacketType.ACK;\n                            // binary packet's json\n                            this.reconstructor = new BinaryReconstructor(packet);\n                            // no attachments, labeled binary but no binary data to follow\n                            if (packet.attachments === 0) _get(_getPrototypeOf(Decoder.prototype), \"emitReserved\", this).call(this, \"decoded\", packet);\n                        } else // non-binary full packet\n                        _get(_getPrototypeOf(Decoder.prototype), \"emitReserved\", this).call(this, \"decoded\", packet);\n                    } else if (isBinary(obj) || obj.base64) {\n                        // raw binary data\n                        if (!this.reconstructor) throw new Error(\"got binary data when not reconstructing a packet\");\n                        else {\n                            packet = this.reconstructor.takeBinaryData(obj);\n                            if (packet) {\n                                // received final buffer\n                                this.reconstructor = null;\n                                _get(_getPrototypeOf(Decoder.prototype), \"emitReserved\", this).call(this, \"decoded\", packet);\n                            }\n                        }\n                    } else throw new Error(\"Unknown type: \" + obj);\n                }\n            },\n            {\n                key: \"decodeString\",\n                value: function decodeString(str) {\n                    var i = 0;\n                    // look up type\n                    var p = {\n                        type: Number(str.charAt(0))\n                    };\n                    if (PacketType[p.type] === undefined) throw new Error(\"unknown packet type \" + p.type);\n                    // look up attachments if type binary\n                    if (p.type === PacketType.BINARY_EVENT || p.type === PacketType.BINARY_ACK) {\n                        var start = i + 1;\n                        while(str.charAt(++i) !== \"-\" && i != str.length);\n                        var buf = str.substring(start, i);\n                        if (buf != Number(buf) || str.charAt(i) !== \"-\") throw new Error(\"Illegal attachments\");\n                        p.attachments = Number(buf);\n                    }\n                    // look up namespace (if any)\n                    if (\"/\" === str.charAt(i + 1)) {\n                        var _start = i + 1;\n                        while(++i){\n                            var c = str.charAt(i);\n                            if (\",\" === c) break;\n                            if (i === str.length) break;\n                        }\n                        p.nsp = str.substring(_start, i);\n                    } else p.nsp = \"/\";\n                    // look up id\n                    var next = str.charAt(i + 1);\n                    if (\"\" !== next && Number(next) == next) {\n                        var _start2 = i + 1;\n                        while(++i){\n                            var _c = str.charAt(i);\n                            if (null == _c || Number(_c) != _c) {\n                                --i;\n                                break;\n                            }\n                            if (i === str.length) break;\n                        }\n                        p.id = Number(str.substring(_start2, i + 1));\n                    }\n                    // look up json data\n                    if (str.charAt(++i)) {\n                        var payload = this.tryParse(str.substr(i));\n                        if (Decoder.isPayloadValid(p.type, payload)) p.data = payload;\n                        else throw new Error(\"invalid payload\");\n                    }\n                    return p;\n                }\n            },\n            {\n                key: \"tryParse\",\n                value: function tryParse(str) {\n                    try {\n                        return JSON.parse(str, this.reviver);\n                    } catch (e) {\n                        return false;\n                    }\n                }\n            },\n            {\n                key: \"destroy\",\n                value: /**\n       * Deallocates a parser's resources\n       */ function destroy() {\n                    if (this.reconstructor) {\n                        this.reconstructor.finishedReconstruction();\n                        this.reconstructor = null;\n                    }\n                }\n            }\n        ], [\n            {\n                key: \"isPayloadValid\",\n                value: function isPayloadValid(type, payload) {\n                    switch(type){\n                        case PacketType.CONNECT:\n                            return isObject(payload);\n                        case PacketType.DISCONNECT:\n                            return payload === undefined;\n                        case PacketType.CONNECT_ERROR:\n                            return typeof payload === \"string\" || isObject(payload);\n                        case PacketType.EVENT:\n                        case PacketType.BINARY_EVENT:\n                            return Array.isArray(payload) && (typeof payload[0] === \"number\" || typeof payload[0] === \"string\" && RESERVED_EVENTS$1.indexOf(payload[0]) === -1);\n                        case PacketType.ACK:\n                        case PacketType.BINARY_ACK:\n                            return Array.isArray(payload);\n                    }\n                }\n            }\n        ]);\n        return Decoder;\n    }(Emitter);\n    /**\n   * A manager of a binary event's 'buffer sequence'. Should\n   * be constructed whenever a packet of type BINARY_EVENT is\n   * decoded.\n   *\n   * @param {Object} packet\n   * @return {BinaryReconstructor} initialized reconstructor\n   */ var BinaryReconstructor = /*#__PURE__*/ function() {\n        function BinaryReconstructor(packet) {\n            _classCallCheck(this, BinaryReconstructor);\n            this.packet = packet;\n            this.buffers = [];\n            this.reconPack = packet;\n        }\n        /**\n     * Method to be called when binary data received from connection\n     * after a BINARY_EVENT packet.\n     *\n     * @param {Buffer | ArrayBuffer} binData - the raw binary data received\n     * @return {null | Object} returns null if more binary data is expected or\n     *   a reconstructed packet object if all buffers have been received.\n     */ _createClass(BinaryReconstructor, [\n            {\n                key: \"takeBinaryData\",\n                value: function takeBinaryData(binData) {\n                    this.buffers.push(binData);\n                    if (this.buffers.length === this.reconPack.attachments) {\n                        // done with buffer list\n                        var packet = reconstructPacket(this.reconPack, this.buffers);\n                        this.finishedReconstruction();\n                        return packet;\n                    }\n                    return null;\n                }\n            },\n            {\n                key: \"finishedReconstruction\",\n                value: function finishedReconstruction() {\n                    this.reconPack = null;\n                    this.buffers = [];\n                }\n            }\n        ]);\n        return BinaryReconstructor;\n    }();\n    var parser = /*#__PURE__*/ Object.freeze({\n        __proto__: null,\n        protocol: protocol,\n        get PacketType () {\n            return PacketType;\n        },\n        Encoder: Encoder,\n        Decoder: Decoder\n    });\n    function on(obj, ev, fn) {\n        obj.on(ev, fn);\n        return function subDestroy() {\n            obj.off(ev, fn);\n        };\n    }\n    /**\n   * Internal events.\n   * These events can't be emitted by the user.\n   */ var RESERVED_EVENTS = Object.freeze({\n        connect: 1,\n        connect_error: 1,\n        disconnect: 1,\n        disconnecting: 1,\n        // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener\n        newListener: 1,\n        removeListener: 1\n    });\n    /**\n   * A Socket is the fundamental class for interacting with the server.\n   *\n   * A Socket belongs to a certain Namespace (by default /) and uses an underlying {@link Manager} to communicate.\n   *\n   * @example\n   * const socket = io();\n   *\n   * socket.on(\"connect\", () => {\n   *   console.log(\"connected\");\n   * });\n   *\n   * // send an event to the server\n   * socket.emit(\"foo\", \"bar\");\n   *\n   * socket.on(\"foobar\", () => {\n   *   // an event was received from the server\n   * });\n   *\n   * // upon disconnection\n   * socket.on(\"disconnect\", (reason) => {\n   *   console.log(`disconnected due to ${reason}`);\n   * });\n   */ var Socket = /*#__PURE__*/ function(_Emitter) {\n        _inherits(Socket, _Emitter);\n        var _super = _createSuper(Socket);\n        /**\n     * `Socket` constructor.\n     */ function Socket(io, nsp, opts) {\n            var _this;\n            _classCallCheck(this, Socket);\n            _this = _super.call(this);\n            /**\n       * Whether the socket is currently connected to the server.\n       *\n       * @example\n       * const socket = io();\n       *\n       * socket.on(\"connect\", () => {\n       *   console.log(socket.connected); // true\n       * });\n       *\n       * socket.on(\"disconnect\", () => {\n       *   console.log(socket.connected); // false\n       * });\n       */ _this.connected = false;\n            /**\n       * Whether the connection state was recovered after a temporary disconnection. In that case, any missed packets will\n       * be transmitted by the server.\n       */ _this.recovered = false;\n            /**\n       * Buffer for packets received before the CONNECT packet\n       */ _this.receiveBuffer = [];\n            /**\n       * Buffer for packets that will be sent once the socket is connected\n       */ _this.sendBuffer = [];\n            /**\n       * The queue of packets to be sent with retry in case of failure.\n       *\n       * Packets are sent one by one, each waiting for the server acknowledgement, in order to guarantee the delivery order.\n       * @private\n       */ _this._queue = [];\n            /**\n       * A sequence to generate the ID of the {@link QueuedPacket}.\n       * @private\n       */ _this._queueSeq = 0;\n            _this.ids = 0;\n            /**\n       * A map containing acknowledgement handlers.\n       *\n       * The `withError` attribute is used to differentiate handlers that accept an error as first argument:\n       *\n       * - `socket.emit(\"test\", (err, value) => { ... })` with `ackTimeout` option\n       * - `socket.timeout(5000).emit(\"test\", (err, value) => { ... })`\n       * - `const value = await socket.emitWithAck(\"test\")`\n       *\n       * From those that don't:\n       *\n       * - `socket.emit(\"test\", (value) => { ... });`\n       *\n       * In the first case, the handlers will be called with an error when:\n       *\n       * - the timeout is reached\n       * - the socket gets disconnected\n       *\n       * In the second case, the handlers will be simply discarded upon disconnection, since the client will never receive\n       * an acknowledgement from the server.\n       *\n       * @private\n       */ _this.acks = {};\n            _this.flags = {};\n            _this.io = io;\n            _this.nsp = nsp;\n            if (opts && opts.auth) _this.auth = opts.auth;\n            _this._opts = _extends({}, opts);\n            if (_this.io._autoConnect) _this.open();\n            return _this;\n        }\n        /**\n     * Whether the socket is currently disconnected\n     *\n     * @example\n     * const socket = io();\n     *\n     * socket.on(\"connect\", () => {\n     *   console.log(socket.disconnected); // false\n     * });\n     *\n     * socket.on(\"disconnect\", () => {\n     *   console.log(socket.disconnected); // true\n     * });\n     */ _createClass(Socket, [\n            {\n                key: \"disconnected\",\n                get: function get() {\n                    return !this.connected;\n                }\n            },\n            {\n                key: \"subEvents\",\n                value: function subEvents() {\n                    if (this.subs) return;\n                    var io = this.io;\n                    this.subs = [\n                        on(io, \"open\", this.onopen.bind(this)),\n                        on(io, \"packet\", this.onpacket.bind(this)),\n                        on(io, \"error\", this.onerror.bind(this)),\n                        on(io, \"close\", this.onclose.bind(this))\n                    ];\n                }\n            },\n            {\n                key: \"active\",\n                get: function get() {\n                    return !!this.subs;\n                }\n            },\n            {\n                key: \"connect\",\n                value: function connect() {\n                    if (this.connected) return this;\n                    this.subEvents();\n                    if (!this.io[\"_reconnecting\"]) this.io.open(); // ensure open\n                    if (\"open\" === this.io._readyState) this.onopen();\n                    return this;\n                }\n            },\n            {\n                key: \"open\",\n                value: function open() {\n                    return this.connect();\n                }\n            },\n            {\n                key: \"send\",\n                value: function send() {\n                    for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++)args[_key] = arguments[_key];\n                    args.unshift(\"message\");\n                    this.emit.apply(this, args);\n                    return this;\n                }\n            },\n            {\n                key: \"emit\",\n                value: function emit(ev) {\n                    if (RESERVED_EVENTS.hasOwnProperty(ev)) throw new Error('\"' + ev.toString() + '\" is a reserved event name');\n                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++)args[_key2 - 1] = arguments[_key2];\n                    args.unshift(ev);\n                    if (this._opts.retries && !this.flags.fromQueue && !this.flags[\"volatile\"]) {\n                        this._addToQueue(args);\n                        return this;\n                    }\n                    var packet = {\n                        type: PacketType.EVENT,\n                        data: args\n                    };\n                    packet.options = {};\n                    packet.options.compress = this.flags.compress !== false;\n                    // event ack callback\n                    if (\"function\" === typeof args[args.length - 1]) {\n                        var id = this.ids++;\n                        var ack = args.pop();\n                        this._registerAckCallback(id, ack);\n                        packet.id = id;\n                    }\n                    var isTransportWritable = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;\n                    var discardPacket = this.flags[\"volatile\"] && (!isTransportWritable || !this.connected);\n                    if (discardPacket) ;\n                    else if (this.connected) {\n                        this.notifyOutgoingListeners(packet);\n                        this.packet(packet);\n                    } else this.sendBuffer.push(packet);\n                    this.flags = {};\n                    return this;\n                }\n            },\n            {\n                key: \"_registerAckCallback\",\n                value: function _registerAckCallback(id, ack) {\n                    var _this2 = this;\n                    var _a;\n                    var timeout = (_a = this.flags.timeout) !== null && _a !== void 0 ? _a : this._opts.ackTimeout;\n                    if (timeout === undefined) {\n                        this.acks[id] = ack;\n                        return;\n                    }\n                    // @ts-ignore\n                    var timer = this.io.setTimeoutFn(function() {\n                        delete _this2.acks[id];\n                        for(var i = 0; i < _this2.sendBuffer.length; i++)if (_this2.sendBuffer[i].id === id) _this2.sendBuffer.splice(i, 1);\n                        ack.call(_this2, new Error(\"operation has timed out\"));\n                    }, timeout);\n                    var fn = function fn() {\n                        // @ts-ignore\n                        _this2.io.clearTimeoutFn(timer);\n                        for(var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++)args[_key3] = arguments[_key3];\n                        ack.apply(_this2, args);\n                    };\n                    fn.withError = true;\n                    this.acks[id] = fn;\n                }\n            },\n            {\n                key: \"emitWithAck\",\n                value: function emitWithAck(ev) {\n                    var _this3 = this;\n                    for(var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++)args[_key4 - 1] = arguments[_key4];\n                    return new Promise(function(resolve, reject) {\n                        var fn = function fn(arg1, arg2) {\n                            return arg1 ? reject(arg1) : resolve(arg2);\n                        };\n                        fn.withError = true;\n                        args.push(fn);\n                        _this3.emit.apply(_this3, [\n                            ev\n                        ].concat(args));\n                    });\n                }\n            },\n            {\n                key: \"_addToQueue\",\n                value: function _addToQueue(args) {\n                    var _this4 = this;\n                    var ack;\n                    if (typeof args[args.length - 1] === \"function\") ack = args.pop();\n                    var packet = {\n                        id: this._queueSeq++,\n                        tryCount: 0,\n                        pending: false,\n                        args: args,\n                        flags: _extends({\n                            fromQueue: true\n                        }, this.flags)\n                    };\n                    args.push(function(err) {\n                        if (packet !== _this4._queue[0]) // the packet has already been acknowledged\n                        return;\n                        var hasError = err !== null;\n                        if (hasError) {\n                            if (packet.tryCount > _this4._opts.retries) {\n                                _this4._queue.shift();\n                                if (ack) ack(err);\n                            }\n                        } else {\n                            _this4._queue.shift();\n                            if (ack) {\n                                for(var _len5 = arguments.length, responseArgs = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++)responseArgs[_key5 - 1] = arguments[_key5];\n                                ack.apply(void 0, [\n                                    null\n                                ].concat(responseArgs));\n                            }\n                        }\n                        packet.pending = false;\n                        return _this4._drainQueue();\n                    });\n                    this._queue.push(packet);\n                    this._drainQueue();\n                }\n            },\n            {\n                key: \"_drainQueue\",\n                value: function _drainQueue() {\n                    var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n                    if (!this.connected || this._queue.length === 0) return;\n                    var packet = this._queue[0];\n                    if (packet.pending && !force) return;\n                    packet.pending = true;\n                    packet.tryCount++;\n                    this.flags = packet.flags;\n                    this.emit.apply(this, packet.args);\n                }\n            },\n            {\n                key: \"packet\",\n                value: function packet(_packet) {\n                    _packet.nsp = this.nsp;\n                    this.io._packet(_packet);\n                }\n            },\n            {\n                key: \"onopen\",\n                value: function onopen() {\n                    var _this5 = this;\n                    if (typeof this.auth == \"function\") this.auth(function(data) {\n                        _this5._sendConnectPacket(data);\n                    });\n                    else this._sendConnectPacket(this.auth);\n                }\n            },\n            {\n                key: \"_sendConnectPacket\",\n                value: function _sendConnectPacket(data) {\n                    this.packet({\n                        type: PacketType.CONNECT,\n                        data: this._pid ? _extends({\n                            pid: this._pid,\n                            offset: this._lastOffset\n                        }, data) : data\n                    });\n                }\n            },\n            {\n                key: \"onerror\",\n                value: function onerror(err) {\n                    if (!this.connected) this.emitReserved(\"connect_error\", err);\n                }\n            },\n            {\n                key: \"onclose\",\n                value: function onclose(reason, description) {\n                    this.connected = false;\n                    delete this.id;\n                    this.emitReserved(\"disconnect\", reason, description);\n                    this._clearAcks();\n                }\n            },\n            {\n                key: \"_clearAcks\",\n                value: function _clearAcks() {\n                    var _this6 = this;\n                    Object.keys(this.acks).forEach(function(id) {\n                        var isBuffered = _this6.sendBuffer.some(function(packet) {\n                            return String(packet.id) === id;\n                        });\n                        if (!isBuffered) {\n                            // note: handlers that do not accept an error as first argument are ignored here\n                            var ack = _this6.acks[id];\n                            delete _this6.acks[id];\n                            if (ack.withError) ack.call(_this6, new Error(\"socket has been disconnected\"));\n                        }\n                    });\n                }\n            },\n            {\n                key: \"onpacket\",\n                value: function onpacket(packet) {\n                    var sameNamespace = packet.nsp === this.nsp;\n                    if (!sameNamespace) return;\n                    switch(packet.type){\n                        case PacketType.CONNECT:\n                            if (packet.data && packet.data.sid) this.onconnect(packet.data.sid, packet.data.pid);\n                            else this.emitReserved(\"connect_error\", new Error(\"It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)\"));\n                            break;\n                        case PacketType.EVENT:\n                        case PacketType.BINARY_EVENT:\n                            this.onevent(packet);\n                            break;\n                        case PacketType.ACK:\n                        case PacketType.BINARY_ACK:\n                            this.onack(packet);\n                            break;\n                        case PacketType.DISCONNECT:\n                            this.ondisconnect();\n                            break;\n                        case PacketType.CONNECT_ERROR:\n                            this.destroy();\n                            var err = new Error(packet.data.message);\n                            // @ts-ignore\n                            err.data = packet.data.data;\n                            this.emitReserved(\"connect_error\", err);\n                            break;\n                    }\n                }\n            },\n            {\n                key: \"onevent\",\n                value: function onevent(packet) {\n                    var args = packet.data || [];\n                    if (null != packet.id) args.push(this.ack(packet.id));\n                    if (this.connected) this.emitEvent(args);\n                    else this.receiveBuffer.push(Object.freeze(args));\n                }\n            },\n            {\n                key: \"emitEvent\",\n                value: function emitEvent(args) {\n                    if (this._anyListeners && this._anyListeners.length) {\n                        var listeners = this._anyListeners.slice();\n                        var _iterator = _createForOfIteratorHelper(listeners), _step;\n                        try {\n                            for(_iterator.s(); !(_step = _iterator.n()).done;){\n                                var listener = _step.value;\n                                listener.apply(this, args);\n                            }\n                        } catch (err) {\n                            _iterator.e(err);\n                        } finally{\n                            _iterator.f();\n                        }\n                    }\n                    _get(_getPrototypeOf(Socket.prototype), \"emit\", this).apply(this, args);\n                    if (this._pid && args.length && typeof args[args.length - 1] === \"string\") this._lastOffset = args[args.length - 1];\n                }\n            },\n            {\n                key: \"ack\",\n                value: function ack(id) {\n                    var self1 = this;\n                    var sent = false;\n                    return function() {\n                        // prevent double callbacks\n                        if (sent) return;\n                        sent = true;\n                        for(var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++)args[_key6] = arguments[_key6];\n                        self1.packet({\n                            type: PacketType.ACK,\n                            id: id,\n                            data: args\n                        });\n                    };\n                }\n            },\n            {\n                key: \"onack\",\n                value: function onack(packet) {\n                    var ack = this.acks[packet.id];\n                    if (typeof ack !== \"function\") return;\n                    delete this.acks[packet.id];\n                    // @ts-ignore FIXME ack is incorrectly inferred as 'never'\n                    if (ack.withError) packet.data.unshift(null);\n                    // @ts-ignore\n                    ack.apply(this, packet.data);\n                }\n            },\n            {\n                key: \"onconnect\",\n                value: function onconnect(id, pid) {\n                    this.id = id;\n                    this.recovered = pid && this._pid === pid;\n                    this._pid = pid; // defined only if connection state recovery is enabled\n                    this.connected = true;\n                    this.emitBuffered();\n                    this.emitReserved(\"connect\");\n                    this._drainQueue(true);\n                }\n            },\n            {\n                key: \"emitBuffered\",\n                value: function emitBuffered() {\n                    var _this7 = this;\n                    this.receiveBuffer.forEach(function(args) {\n                        return _this7.emitEvent(args);\n                    });\n                    this.receiveBuffer = [];\n                    this.sendBuffer.forEach(function(packet) {\n                        _this7.notifyOutgoingListeners(packet);\n                        _this7.packet(packet);\n                    });\n                    this.sendBuffer = [];\n                }\n            },\n            {\n                key: \"ondisconnect\",\n                value: function ondisconnect() {\n                    this.destroy();\n                    this.onclose(\"io server disconnect\");\n                }\n            },\n            {\n                key: \"destroy\",\n                value: function destroy() {\n                    if (this.subs) {\n                        // clean subscriptions to avoid reconnections\n                        this.subs.forEach(function(subDestroy) {\n                            return subDestroy();\n                        });\n                        this.subs = undefined;\n                    }\n                    this.io[\"_destroy\"](this);\n                }\n            },\n            {\n                key: \"disconnect\",\n                value: function disconnect() {\n                    if (this.connected) this.packet({\n                        type: PacketType.DISCONNECT\n                    });\n                    // remove socket from pool\n                    this.destroy();\n                    if (this.connected) // fire events\n                    this.onclose(\"io client disconnect\");\n                    return this;\n                }\n            },\n            {\n                key: \"close\",\n                value: function close() {\n                    return this.disconnect();\n                }\n            },\n            {\n                key: \"compress\",\n                value: function compress(_compress) {\n                    this.flags.compress = _compress;\n                    return this;\n                }\n            },\n            {\n                key: \"volatile\",\n                get: function get() {\n                    this.flags[\"volatile\"] = true;\n                    return this;\n                }\n            },\n            {\n                key: \"timeout\",\n                value: function timeout(_timeout) {\n                    this.flags.timeout = _timeout;\n                    return this;\n                }\n            },\n            {\n                key: \"onAny\",\n                value: function onAny(listener) {\n                    this._anyListeners = this._anyListeners || [];\n                    this._anyListeners.push(listener);\n                    return this;\n                }\n            },\n            {\n                key: \"prependAny\",\n                value: function prependAny(listener) {\n                    this._anyListeners = this._anyListeners || [];\n                    this._anyListeners.unshift(listener);\n                    return this;\n                }\n            },\n            {\n                key: \"offAny\",\n                value: function offAny(listener) {\n                    if (!this._anyListeners) return this;\n                    if (listener) {\n                        var listeners = this._anyListeners;\n                        for(var i = 0; i < listeners.length; i++)if (listener === listeners[i]) {\n                            listeners.splice(i, 1);\n                            return this;\n                        }\n                    } else this._anyListeners = [];\n                    return this;\n                }\n            },\n            {\n                key: \"listenersAny\",\n                value: function listenersAny() {\n                    return this._anyListeners || [];\n                }\n            },\n            {\n                key: \"onAnyOutgoing\",\n                value: function onAnyOutgoing(listener) {\n                    this._anyOutgoingListeners = this._anyOutgoingListeners || [];\n                    this._anyOutgoingListeners.push(listener);\n                    return this;\n                }\n            },\n            {\n                key: \"prependAnyOutgoing\",\n                value: function prependAnyOutgoing(listener) {\n                    this._anyOutgoingListeners = this._anyOutgoingListeners || [];\n                    this._anyOutgoingListeners.unshift(listener);\n                    return this;\n                }\n            },\n            {\n                key: \"offAnyOutgoing\",\n                value: function offAnyOutgoing(listener) {\n                    if (!this._anyOutgoingListeners) return this;\n                    if (listener) {\n                        var listeners = this._anyOutgoingListeners;\n                        for(var i = 0; i < listeners.length; i++)if (listener === listeners[i]) {\n                            listeners.splice(i, 1);\n                            return this;\n                        }\n                    } else this._anyOutgoingListeners = [];\n                    return this;\n                }\n            },\n            {\n                key: \"listenersAnyOutgoing\",\n                value: function listenersAnyOutgoing() {\n                    return this._anyOutgoingListeners || [];\n                }\n            },\n            {\n                key: \"notifyOutgoingListeners\",\n                value: function notifyOutgoingListeners(packet) {\n                    if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {\n                        var listeners = this._anyOutgoingListeners.slice();\n                        var _iterator2 = _createForOfIteratorHelper(listeners), _step2;\n                        try {\n                            for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){\n                                var listener = _step2.value;\n                                listener.apply(this, packet.data);\n                            }\n                        } catch (err) {\n                            _iterator2.e(err);\n                        } finally{\n                            _iterator2.f();\n                        }\n                    }\n                }\n            }\n        ]);\n        return Socket;\n    }(Emitter);\n    /**\n   * Initialize backoff timer with `opts`.\n   *\n   * - `min` initial timeout in milliseconds [100]\n   * - `max` max timeout [10000]\n   * - `jitter` [0]\n   * - `factor` [2]\n   *\n   * @param {Object} opts\n   * @api public\n   */ function Backoff(opts) {\n        opts = opts || {};\n        this.ms = opts.min || 100;\n        this.max = opts.max || 10000;\n        this.factor = opts.factor || 2;\n        this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;\n        this.attempts = 0;\n    }\n    /**\n   * Return the backoff duration.\n   *\n   * @return {Number}\n   * @api public\n   */ Backoff.prototype.duration = function() {\n        var ms = this.ms * Math.pow(this.factor, this.attempts++);\n        if (this.jitter) {\n            var rand = Math.random();\n            var deviation = Math.floor(rand * this.jitter * ms);\n            ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;\n        }\n        return Math.min(ms, this.max) | 0;\n    };\n    /**\n   * Reset the number of attempts.\n   *\n   * @api public\n   */ Backoff.prototype.reset = function() {\n        this.attempts = 0;\n    };\n    /**\n   * Set the minimum duration\n   *\n   * @api public\n   */ Backoff.prototype.setMin = function(min) {\n        this.ms = min;\n    };\n    /**\n   * Set the maximum duration\n   *\n   * @api public\n   */ Backoff.prototype.setMax = function(max) {\n        this.max = max;\n    };\n    /**\n   * Set the jitter\n   *\n   * @api public\n   */ Backoff.prototype.setJitter = function(jitter) {\n        this.jitter = jitter;\n    };\n    var Manager = /*#__PURE__*/ function(_Emitter) {\n        _inherits(Manager, _Emitter);\n        var _super = _createSuper(Manager);\n        function Manager(uri, opts) {\n            var _this;\n            _classCallCheck(this, Manager);\n            var _a;\n            _this = _super.call(this);\n            _this.nsps = {};\n            _this.subs = [];\n            if (uri && \"object\" === _typeof(uri)) {\n                opts = uri;\n                uri = undefined;\n            }\n            opts = opts || {};\n            opts.path = opts.path || \"/socket.io\";\n            _this.opts = opts;\n            installTimerFunctions(_assertThisInitialized(_this), opts);\n            _this.reconnection(opts.reconnection !== false);\n            _this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);\n            _this.reconnectionDelay(opts.reconnectionDelay || 1000);\n            _this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);\n            _this.randomizationFactor((_a = opts.randomizationFactor) !== null && _a !== void 0 ? _a : 0.5);\n            _this.backoff = new Backoff({\n                min: _this.reconnectionDelay(),\n                max: _this.reconnectionDelayMax(),\n                jitter: _this.randomizationFactor()\n            });\n            _this.timeout(null == opts.timeout ? 20000 : opts.timeout);\n            _this._readyState = \"closed\";\n            _this.uri = uri;\n            var _parser = opts.parser || parser;\n            _this.encoder = new _parser.Encoder();\n            _this.decoder = new _parser.Decoder();\n            _this._autoConnect = opts.autoConnect !== false;\n            if (_this._autoConnect) _this.open();\n            return _this;\n        }\n        _createClass(Manager, [\n            {\n                key: \"reconnection\",\n                value: function reconnection(v) {\n                    if (!arguments.length) return this._reconnection;\n                    this._reconnection = !!v;\n                    return this;\n                }\n            },\n            {\n                key: \"reconnectionAttempts\",\n                value: function reconnectionAttempts(v) {\n                    if (v === undefined) return this._reconnectionAttempts;\n                    this._reconnectionAttempts = v;\n                    return this;\n                }\n            },\n            {\n                key: \"reconnectionDelay\",\n                value: function reconnectionDelay(v) {\n                    var _a;\n                    if (v === undefined) return this._reconnectionDelay;\n                    this._reconnectionDelay = v;\n                    (_a = this.backoff) === null || _a === void 0 || _a.setMin(v);\n                    return this;\n                }\n            },\n            {\n                key: \"randomizationFactor\",\n                value: function randomizationFactor(v) {\n                    var _a;\n                    if (v === undefined) return this._randomizationFactor;\n                    this._randomizationFactor = v;\n                    (_a = this.backoff) === null || _a === void 0 || _a.setJitter(v);\n                    return this;\n                }\n            },\n            {\n                key: \"reconnectionDelayMax\",\n                value: function reconnectionDelayMax(v) {\n                    var _a;\n                    if (v === undefined) return this._reconnectionDelayMax;\n                    this._reconnectionDelayMax = v;\n                    (_a = this.backoff) === null || _a === void 0 || _a.setMax(v);\n                    return this;\n                }\n            },\n            {\n                key: \"timeout\",\n                value: function timeout(v) {\n                    if (!arguments.length) return this._timeout;\n                    this._timeout = v;\n                    return this;\n                }\n            },\n            {\n                key: \"maybeReconnectOnOpen\",\n                value: function maybeReconnectOnOpen() {\n                    // Only try to reconnect if it's the first time we're connecting\n                    if (!this._reconnecting && this._reconnection && this.backoff.attempts === 0) // keeps reconnection from firing twice for the same reconnection loop\n                    this.reconnect();\n                }\n            },\n            {\n                key: \"open\",\n                value: function open(fn) {\n                    var _this2 = this;\n                    if (~this._readyState.indexOf(\"open\")) return this;\n                    this.engine = new Socket$1(this.uri, this.opts);\n                    var socket = this.engine;\n                    var self1 = this;\n                    this._readyState = \"opening\";\n                    this.skipReconnect = false;\n                    // emit `open`\n                    var openSubDestroy = on(socket, \"open\", function() {\n                        self1.onopen();\n                        fn && fn();\n                    });\n                    var onError = function onError(err) {\n                        _this2.cleanup();\n                        _this2._readyState = \"closed\";\n                        _this2.emitReserved(\"error\", err);\n                        if (fn) fn(err);\n                        else // Only do this if there is no fn to handle the error\n                        _this2.maybeReconnectOnOpen();\n                    };\n                    // emit `error`\n                    var errorSub = on(socket, \"error\", onError);\n                    if (false !== this._timeout) {\n                        var timeout = this._timeout;\n                        // set timer\n                        var timer = this.setTimeoutFn(function() {\n                            openSubDestroy();\n                            onError(new Error(\"timeout\"));\n                            socket.close();\n                        }, timeout);\n                        if (this.opts.autoUnref) timer.unref();\n                        this.subs.push(function() {\n                            _this2.clearTimeoutFn(timer);\n                        });\n                    }\n                    this.subs.push(openSubDestroy);\n                    this.subs.push(errorSub);\n                    return this;\n                }\n            },\n            {\n                key: \"connect\",\n                value: function connect(fn) {\n                    return this.open(fn);\n                }\n            },\n            {\n                key: \"onopen\",\n                value: function onopen() {\n                    // clear old subs\n                    this.cleanup();\n                    // mark as open\n                    this._readyState = \"open\";\n                    this.emitReserved(\"open\");\n                    // add new subs\n                    var socket = this.engine;\n                    this.subs.push(on(socket, \"ping\", this.onping.bind(this)), on(socket, \"data\", this.ondata.bind(this)), on(socket, \"error\", this.onerror.bind(this)), on(socket, \"close\", this.onclose.bind(this)), on(this.decoder, \"decoded\", this.ondecoded.bind(this)));\n                }\n            },\n            {\n                key: \"onping\",\n                value: function onping() {\n                    this.emitReserved(\"ping\");\n                }\n            },\n            {\n                key: \"ondata\",\n                value: function ondata(data) {\n                    try {\n                        this.decoder.add(data);\n                    } catch (e) {\n                        this.onclose(\"parse error\", e);\n                    }\n                }\n            },\n            {\n                key: \"ondecoded\",\n                value: function ondecoded(packet) {\n                    var _this3 = this;\n                    // the nextTick call prevents an exception in a user-provided event listener from triggering a disconnection due to a \"parse error\"\n                    nextTick(function() {\n                        _this3.emitReserved(\"packet\", packet);\n                    }, this.setTimeoutFn);\n                }\n            },\n            {\n                key: \"onerror\",\n                value: function onerror(err) {\n                    this.emitReserved(\"error\", err);\n                }\n            },\n            {\n                key: \"socket\",\n                value: function socket(nsp, opts) {\n                    var socket = this.nsps[nsp];\n                    if (!socket) {\n                        socket = new Socket(this, nsp, opts);\n                        this.nsps[nsp] = socket;\n                    } else if (this._autoConnect && !socket.active) socket.connect();\n                    return socket;\n                }\n            },\n            {\n                key: \"_destroy\",\n                value: function _destroy(socket) {\n                    var nsps = Object.keys(this.nsps);\n                    for(var _i = 0, _nsps = nsps; _i < _nsps.length; _i++){\n                        var nsp = _nsps[_i];\n                        var _socket = this.nsps[nsp];\n                        if (_socket.active) return;\n                    }\n                    this._close();\n                }\n            },\n            {\n                key: \"_packet\",\n                value: function _packet(packet) {\n                    var encodedPackets = this.encoder.encode(packet);\n                    for(var i = 0; i < encodedPackets.length; i++)this.engine.write(encodedPackets[i], packet.options);\n                }\n            },\n            {\n                key: \"cleanup\",\n                value: function cleanup() {\n                    this.subs.forEach(function(subDestroy) {\n                        return subDestroy();\n                    });\n                    this.subs.length = 0;\n                    this.decoder.destroy();\n                }\n            },\n            {\n                key: \"_close\",\n                value: function _close() {\n                    this.skipReconnect = true;\n                    this._reconnecting = false;\n                    this.onclose(\"forced close\");\n                    if (this.engine) this.engine.close();\n                }\n            },\n            {\n                key: \"disconnect\",\n                value: function disconnect() {\n                    return this._close();\n                }\n            },\n            {\n                key: \"onclose\",\n                value: function onclose(reason, description) {\n                    this.cleanup();\n                    this.backoff.reset();\n                    this._readyState = \"closed\";\n                    this.emitReserved(\"close\", reason, description);\n                    if (this._reconnection && !this.skipReconnect) this.reconnect();\n                }\n            },\n            {\n                key: \"reconnect\",\n                value: function reconnect() {\n                    var _this4 = this;\n                    if (this._reconnecting || this.skipReconnect) return this;\n                    var self1 = this;\n                    if (this.backoff.attempts >= this._reconnectionAttempts) {\n                        this.backoff.reset();\n                        this.emitReserved(\"reconnect_failed\");\n                        this._reconnecting = false;\n                    } else {\n                        var delay = this.backoff.duration();\n                        this._reconnecting = true;\n                        var timer = this.setTimeoutFn(function() {\n                            if (self1.skipReconnect) return;\n                            _this4.emitReserved(\"reconnect_attempt\", self1.backoff.attempts);\n                            // check again for the case socket closed in above events\n                            if (self1.skipReconnect) return;\n                            self1.open(function(err) {\n                                if (err) {\n                                    self1._reconnecting = false;\n                                    self1.reconnect();\n                                    _this4.emitReserved(\"reconnect_error\", err);\n                                } else self1.onreconnect();\n                            });\n                        }, delay);\n                        if (this.opts.autoUnref) timer.unref();\n                        this.subs.push(function() {\n                            _this4.clearTimeoutFn(timer);\n                        });\n                    }\n                }\n            },\n            {\n                key: \"onreconnect\",\n                value: function onreconnect() {\n                    var attempt = this.backoff.attempts;\n                    this._reconnecting = false;\n                    this.backoff.reset();\n                    this.emitReserved(\"reconnect\", attempt);\n                }\n            }\n        ]);\n        return Manager;\n    }(Emitter);\n    /**\n   * Managers cache.\n   */ var cache = {};\n    function lookup(uri, opts) {\n        if (_typeof(uri) === \"object\") {\n            opts = uri;\n            uri = undefined;\n        }\n        opts = opts || {};\n        var parsed = url(uri, opts.path || \"/socket.io\");\n        var source = parsed.source;\n        var id = parsed.id;\n        var path = parsed.path;\n        var sameNamespace = cache[id] && path in cache[id][\"nsps\"];\n        var newConnection = opts.forceNew || opts[\"force new connection\"] || false === opts.multiplex || sameNamespace;\n        var io;\n        if (newConnection) io = new Manager(source, opts);\n        else {\n            if (!cache[id]) cache[id] = new Manager(source, opts);\n            io = cache[id];\n        }\n        if (parsed.query && !opts.query) opts.query = parsed.queryKey;\n        return io.socket(parsed.path, opts);\n    }\n    // so that \"lookup\" can be used both as a function (e.g. `io(...)`) and as a\n    // namespace (e.g. `io.connect(...)`), for backward compatibility\n    _extends(lookup, {\n        Manager: Manager,\n        Socket: Socket,\n        io: lookup,\n        connect: lookup\n    });\n    return lookup;\n});\n\n});\n\n\nparcelRegister(\"lPoRS\", function(module, exports) {\n\n$parcel$export(module.exports, \"Paint\", () => $c9a0f875e10d7256$export$fbe17ae5b75efa7);\n/**\r\n * 簡単なペイントアプリケーション\r\n *  ペイントチャットでの活用を考慮している．\r\n */ // CSSの定義を読み込む．\n\nvar $c54Ow = parcelRequire(\"c54Ow\");\n\n\nvar $lbJE2 = parcelRequire(\"lbJE2\");\nconst $c9a0f875e10d7256$export$fbe17ae5b75efa7 = /*#__PURE__*/ (0, $lbJE2.forwardRef)(({ width: // canvasの大きさのデフォルト値\nwidth = 300, height: height = 200, lineCap: // canvasの描画コンテキストの指定\nlineCap = \"round\", lineJoin: lineJoin = \"round\", lineColor: lineColor = \"#ff0000\", lineWidth: lineWidth = 1, drawLine: // ペイントチャットで使用する時，関数を指定する．\ndrawLine, clearCanvas: clearCanvas }, ref)=>{\n    // canvas要素へのref\n    const canvasRef = (0, $lbJE2.useRef)(null);\n    // 最後に描いた線の終点（次に描く線の始点）\n    const lastPosRef = (0, $lbJE2.useRef)(null);\n    // ペンの色\n    const [penColor, setPenColor] = (0, $lbJE2.useState)(lineColor);\n    // ペンのサイズ\n    const [penSize, setPenSize] = (0, $lbJE2.useState)(lineWidth);\n    // ペンの色を変更する．\n    const changeColor = (event)=>{\n        setPenColor(event.target.value);\n    };\n    // ペンのサイズを変更する．\n    const changePenSize = (event)=>{\n        setPenSize(event.target.value);\n    };\n    /// Canvasに線を描く\n    // マウスイベントの座標をCanvas内の座標に変換する．\n    const getCoords = (event)=>{\n        const canvas = canvasRef.current;\n        const rect = canvas.getBoundingClientRect();\n        const style = getComputedStyle(canvas);\n        const bleft = parseFloat(style.borderLeftWidth);\n        const btop = parseFloat(style.borderTopWidth);\n        const pleft = parseFloat(style.paddingLeft);\n        const ptop = parseFloat(style.paddingTop);\n        const offsetX = rect.left + bleft + pleft;\n        const offsetY = rect.top + btop + ptop;\n        const posx = event.clientX - offsetX;\n        const posy = event.clientY - offsetY;\n        // Canvasが拡大・縮小表示されている場合の補正を行う．\n        const bright = parseFloat(style.borderRightWidth);\n        const bbottom = parseFloat(style.borderBottomWidth);\n        const pright = parseFloat(style.paddingRight);\n        const pbottom = parseFloat(style.paddingBottom);\n        const x = posx * canvas.width / (rect.width - (bleft + bright + pleft + pright));\n        const y = posy * canvas.height / (rect.height - (btop + bbottom + ptop + pbottom));\n        return {\n            x: x,\n            y: y\n        };\n    };\n    // mousedownのイベントリスナー\n    const mousedown = (event)=>{\n        // 描画モードに入る．\n        // canvas要素外にマウスが動くことも想定し，documentに対して，mousemoveとmouseupのイベントリスナーを設定する．\n        document.addEventListener(\"mousemove\", mousemove, false);\n        document.addEventListener(\"mouseup\", mouseup, false);\n        // ブラウザによってはテキスト選択が始まるのを防ぐ．\n        event.preventDefault();\n        // マウスが押された座標を記録しておく．\n        const pos = getCoords(event);\n        lastPosRef.current = pos;\n    };\n    // mousemoveのイベントリスナー\n    const mousemove = (event)=>{\n        const pos = getCoords(event);\n        // lastPosから現在のマウスの位置まで線を描く．\n        drawLine(lastPosRef.current.x, lastPosRef.current.y, pos.x, pos.y, penColor, penSize);\n        // lastPosを更新する．\n        lastPosRef.current = pos;\n    };\n    // mouseupのイベントリスナー\n    const mouseup = ()=>{\n        // mousemoveとmouseupのイベントリスナーを削除し，描画モードを抜ける．\n        document.removeEventListener(\"mousemove\", mousemove, false);\n        document.removeEventListener(\"mouseup\", mouseup, false);\n    };\n    // (x0, y0) から (x1, y1)まで線を描く．\n    const drawLineInternal = (x0, y0, x1, y1, color, size)=>{\n        const ctx = canvasRef.current.getContext(\"2d\");\n        ctx.save();\n        ctx.lineCap = lineCap;\n        ctx.lineJoin = lineJoin;\n        ctx.strokeStyle = color;\n        ctx.lineWidth = size;\n        ctx.beginPath();\n        ctx.moveTo(x0, y0);\n        ctx.lineTo(x1, y1);\n        ctx.stroke();\n        ctx.restore();\n    };\n    // drawLineが指定されていない時は，drawLineInternalに設定する．\n    if (!drawLine) drawLine = drawLineInternal;\n    /// Canvasのクリア\n    const clearCanvasInternal = ()=>{\n        const canvas = canvasRef.current;\n        const ctx = canvas.getContext(\"2d\");\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n    };\n    // clearCanvasが指定されていない時は，clearCanvasInternalに設定する．\n    if (!clearCanvas) clearCanvas = clearCanvasInternal;\n    /// コンポーネントの外から呼び出せるメソッドを定義する．\n    // drawLineとclearCanvasを対象とする\n    (0, $lbJE2.useImperativeHandle)(ref, ()=>{\n        return {\n            drawLine: drawLineInternal,\n            clearCanvas: clearCanvasInternal\n        };\n    }, []);\n    // 画像の取得\n    const getImageDataURL = ()=>{\n        return canvasRef.current.toDataURL();\n    };\n    // 画像の設定\n    const putImageDataURL = (dataURL)=>{\n        const image = new Image();\n        image.onload = ()=>{\n            const ctx = canvasRef.current.getContext(\"2d\");\n            ctx.drawImage(image, 0, 0);\n        };\n        image.src = dataURL;\n    };\n    // コンポーネントの外から呼び出せるメソッドを定義する．\n    (0, $lbJE2.useImperativeHandle)(ref, ()=>{\n        return {\n            drawLine: drawLineInternal,\n            clearCanvas: clearCanvasInternal,\n            getImageDataURL: getImageDataURL,\n            putImageDataURL: putImageDataURL\n        };\n    }, []);\n    return /*#__PURE__*/ (0, $c54Ow.jsxs)(\"div\", {\n        className: \"paint\",\n        children: [\n            /*#__PURE__*/ (0, $c54Ow.jsx)(\"canvas\", {\n                ref: canvasRef,\n                onMouseDown: mousedown,\n                width: width,\n                height: height\n            }),\n            /*#__PURE__*/ (0, $c54Ow.jsxs)(\"div\", {\n                className: \"paint-control\",\n                children: [\n                    /*#__PURE__*/ (0, $c54Ow.jsxs)(\"label\", {\n                        children: [\n                            \"\\u8272\",\n                            /*#__PURE__*/ (0, $c54Ow.jsx)(\"input\", {\n                                type: \"color\",\n                                value: penColor,\n                                onChange: changeColor\n                            })\n                        ]\n                    }),\n                    /*#__PURE__*/ (0, $c54Ow.jsxs)(\"label\", {\n                        children: [\n                            \"\\u30DA\\u30F3\\u30B5\\u30A4\\u30BA\",\n                            /*#__PURE__*/ (0, $c54Ow.jsx)(\"input\", {\n                                type: \"number\",\n                                min: 1,\n                                max: 9,\n                                onChange: changePenSize,\n                                value: penSize\n                            })\n                        ]\n                    }),\n                    /*#__PURE__*/ (0, $c54Ow.jsx)(\"button\", {\n                        type: \"button\",\n                        onClick: clearCanvas,\n                        children: \"\\u30AF\\u30EA\\u30A2\"\n                    })\n                ]\n            })\n        ]\n    });\n});\n\n});\n\n\n//# sourceMappingURL=report02.93fe4c56.js.map\n","/**\r\n * Socket.IOのsocketを子要素に提供する．\r\n * \r\n * <WithSocket nsp=\"namespace\"> ... </WitSocket>\r\n *  nsp: Socket.IOで使用するnamespaceを指定する．デフォルトは /\r\n */\r\n// CSSの読み込み\r\nimport '../css/WithSocket.css';\r\n\r\n// socket.io.clientを使用する．\r\nimport { io } from 'socket.io-client';\r\n\r\nimport { useState, useRef, useEffect, useContext, createContext } from 'react';\r\n// useEffectの代わりに useLayoutEffectを使う．\r\n//import { useLayoutEffect } from 'react';\r\n\r\n// 簡易ログイン機能を使用することにする．\r\nimport { LoginContext } from './Authenticate';\r\n\r\n// socketをContextを使って，子要素に渡す．\r\nexport const SocketContext = createContext();\r\n\r\n// コンポーネントの定義\r\nexport const WithSocket = (props) => {\r\n  const socketRef = useRef(null);\r\n  const [connected, setConnected] = useState(false);\r\n  const [errorMessage, setErrorMessage] = useState('');\r\n\r\n  // LoginContextからユーザ情報を取得する．\r\n  const user = useContext(LoginContext);\r\n\r\n  const openSocket = () => {\r\n    // ユーザ情報があればauthHeaderをつける．\r\n    const authHeader = user ?\r\n      { auth: { token: user.token, username: user.username } } : {};\r\n    if (!socketRef.current) {\r\n      const socket = io(props.nsp, {\r\n        reconnection: false,\r\n        ...authHeader\r\n      });\r\n      socket.on('connect', () => {\r\n        setConnected(true);\r\n      })\r\n      socket.on('error', (error) => {\r\n        setErrorMessage(error.message);\r\n      });\r\n      socket.on('connect_error', (error) => {\r\n        setErrorMessage(error.message)\r\n      });\r\n      socket.on('connect_timeout', (error) => {\r\n        setErrorMessage(error.message)\r\n      });\r\n      socket.on('disconnect', (reason) => {\r\n        setErrorMessage(`Disconnected: ${reason}.`);\r\n        setConnected(false);\r\n      });\r\n      socketRef.current = socket;\r\n    } else {\r\n      setErrorMessage('');\r\n      socketRef.current.connect();\r\n    }\r\n  };\r\n\r\n  const closeSocket = () => {\r\n    if (socketRef.current) {\r\n      socketRef.current.close();\r\n    }\r\n  };\r\n\r\n  // コンポーネントがマウントされた時にソケットをオープンし，アンマウントする時にソケットをクローズする．\r\n  // もし，画面の同期を優先するのであれば，useEffectではなく，useLayoutEffectを使う．\r\n  useEffect(() => {\r\n    if (!connected) {\r\n      openSocket();\r\n    }\r\n    return () => {\r\n      closeSocket();\r\n    };\r\n    // 簡単にするために，user, nsp はコンポーネントがマウントされている間は変化しないという前提で，depedancyに入れない．\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, []);\r\n\r\n  // 接続/切断のボタンの処理\r\n  const connectOrDisconnect = () => {\r\n    if (connected) {\r\n      closeSocket();\r\n    } else {\r\n      openSocket();\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div className=\"with-socket\">\r\n      <div className=\"with-socket-control\">\r\n        <span className={(connected ? \"\" : \"with-socket-disconnected\")}>namespace: {props.nsp}</span>\r\n        <button type=\"button\" onClick={connectOrDisconnect}>\r\n          {connected ? '切断' : '接続'}\r\n        </button>\r\n      </div>\r\n      {connected ?\r\n        // 接続している時は，子要素を表示する．\r\n        <SocketContext.Provider value={socketRef}>\r\n          {props.children}\r\n        </SocketContext.Provider>\r\n        :\r\n        // 切断されている時\r\n        <div><span className=\"with-socket-disconnected\">接続されていません</span></div>\r\n      }\r\n      {errorMessage === '' ? null :\r\n        <div className=\"error-message\"\r\n          onClick={() => setErrorMessage('')}>{errorMessage}</div>}\r\n    </div>\r\n  );\r\n};\r\n","/*!\n * Socket.IO v4.7.5\n * (c) 2014-2024 Guillermo Rauch\n * Released under the MIT License.\n */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.io = factory());\n})(this, (function () { 'use strict';\n\n  function _typeof(obj) {\n    \"@babel/helpers - typeof\";\n\n    return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n      return typeof obj;\n    } : function (obj) {\n      return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    }, _typeof(obj);\n  }\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);\n    }\n  }\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    Object.defineProperty(Constructor, \"prototype\", {\n      writable: false\n    });\n    return Constructor;\n  }\n  function _extends() {\n    _extends = Object.assign ? Object.assign.bind() : function (target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i];\n        for (var key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n          }\n        }\n      }\n      return target;\n    };\n    return _extends.apply(this, arguments);\n  }\n  function _inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n      constructor: {\n        value: subClass,\n        writable: true,\n        configurable: true\n      }\n    });\n    Object.defineProperty(subClass, \"prototype\", {\n      writable: false\n    });\n    if (superClass) _setPrototypeOf(subClass, superClass);\n  }\n  function _getPrototypeOf(o) {\n    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n      return o.__proto__ || Object.getPrototypeOf(o);\n    };\n    return _getPrototypeOf(o);\n  }\n  function _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n      o.__proto__ = p;\n      return o;\n    };\n    return _setPrototypeOf(o, p);\n  }\n  function _isNativeReflectConstruct() {\n    if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n    if (Reflect.construct.sham) return false;\n    if (typeof Proxy === \"function\") return true;\n    try {\n      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n  function _construct(Parent, args, Class) {\n    if (_isNativeReflectConstruct()) {\n      _construct = Reflect.construct.bind();\n    } else {\n      _construct = function _construct(Parent, args, Class) {\n        var a = [null];\n        a.push.apply(a, args);\n        var Constructor = Function.bind.apply(Parent, a);\n        var instance = new Constructor();\n        if (Class) _setPrototypeOf(instance, Class.prototype);\n        return instance;\n      };\n    }\n    return _construct.apply(null, arguments);\n  }\n  function _isNativeFunction(fn) {\n    return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n  }\n  function _wrapNativeSuper(Class) {\n    var _cache = typeof Map === \"function\" ? new Map() : undefined;\n    _wrapNativeSuper = function _wrapNativeSuper(Class) {\n      if (Class === null || !_isNativeFunction(Class)) return Class;\n      if (typeof Class !== \"function\") {\n        throw new TypeError(\"Super expression must either be null or a function\");\n      }\n      if (typeof _cache !== \"undefined\") {\n        if (_cache.has(Class)) return _cache.get(Class);\n        _cache.set(Class, Wrapper);\n      }\n      function Wrapper() {\n        return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n      }\n      Wrapper.prototype = Object.create(Class.prototype, {\n        constructor: {\n          value: Wrapper,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      });\n      return _setPrototypeOf(Wrapper, Class);\n    };\n    return _wrapNativeSuper(Class);\n  }\n  function _assertThisInitialized(self) {\n    if (self === void 0) {\n      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n    return self;\n  }\n  function _possibleConstructorReturn(self, call) {\n    if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n      return call;\n    } else if (call !== void 0) {\n      throw new TypeError(\"Derived constructors may only return object or undefined\");\n    }\n    return _assertThisInitialized(self);\n  }\n  function _createSuper(Derived) {\n    var hasNativeReflectConstruct = _isNativeReflectConstruct();\n    return function _createSuperInternal() {\n      var Super = _getPrototypeOf(Derived),\n        result;\n      if (hasNativeReflectConstruct) {\n        var NewTarget = _getPrototypeOf(this).constructor;\n        result = Reflect.construct(Super, arguments, NewTarget);\n      } else {\n        result = Super.apply(this, arguments);\n      }\n      return _possibleConstructorReturn(this, result);\n    };\n  }\n  function _superPropBase(object, property) {\n    while (!Object.prototype.hasOwnProperty.call(object, property)) {\n      object = _getPrototypeOf(object);\n      if (object === null) break;\n    }\n    return object;\n  }\n  function _get() {\n    if (typeof Reflect !== \"undefined\" && Reflect.get) {\n      _get = Reflect.get.bind();\n    } else {\n      _get = function _get(target, property, receiver) {\n        var base = _superPropBase(target, property);\n        if (!base) return;\n        var desc = Object.getOwnPropertyDescriptor(base, property);\n        if (desc.get) {\n          return desc.get.call(arguments.length < 3 ? target : receiver);\n        }\n        return desc.value;\n      };\n    }\n    return _get.apply(this, arguments);\n  }\n  function _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n  }\n  function _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n    return arr2;\n  }\n  function _createForOfIteratorHelper(o, allowArrayLike) {\n    var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n    if (!it) {\n      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n        if (it) o = it;\n        var i = 0;\n        var F = function () {};\n        return {\n          s: F,\n          n: function () {\n            if (i >= o.length) return {\n              done: true\n            };\n            return {\n              done: false,\n              value: o[i++]\n            };\n          },\n          e: function (e) {\n            throw e;\n          },\n          f: F\n        };\n      }\n      throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n    }\n    var normalCompletion = true,\n      didErr = false,\n      err;\n    return {\n      s: function () {\n        it = it.call(o);\n      },\n      n: function () {\n        var step = it.next();\n        normalCompletion = step.done;\n        return step;\n      },\n      e: function (e) {\n        didErr = true;\n        err = e;\n      },\n      f: function () {\n        try {\n          if (!normalCompletion && it.return != null) it.return();\n        } finally {\n          if (didErr) throw err;\n        }\n      }\n    };\n  }\n  function _toPrimitive(input, hint) {\n    if (typeof input !== \"object\" || input === null) return input;\n    var prim = input[Symbol.toPrimitive];\n    if (prim !== undefined) {\n      var res = prim.call(input, hint || \"default\");\n      if (typeof res !== \"object\") return res;\n      throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (hint === \"string\" ? String : Number)(input);\n  }\n  function _toPropertyKey(arg) {\n    var key = _toPrimitive(arg, \"string\");\n    return typeof key === \"symbol\" ? key : String(key);\n  }\n\n  var PACKET_TYPES = Object.create(null); // no Map = no polyfill\n  PACKET_TYPES[\"open\"] = \"0\";\n  PACKET_TYPES[\"close\"] = \"1\";\n  PACKET_TYPES[\"ping\"] = \"2\";\n  PACKET_TYPES[\"pong\"] = \"3\";\n  PACKET_TYPES[\"message\"] = \"4\";\n  PACKET_TYPES[\"upgrade\"] = \"5\";\n  PACKET_TYPES[\"noop\"] = \"6\";\n  var PACKET_TYPES_REVERSE = Object.create(null);\n  Object.keys(PACKET_TYPES).forEach(function (key) {\n    PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;\n  });\n  var ERROR_PACKET = {\n    type: \"error\",\n    data: \"parser error\"\n  };\n\n  var withNativeBlob$1 = typeof Blob === \"function\" || typeof Blob !== \"undefined\" && Object.prototype.toString.call(Blob) === \"[object BlobConstructor]\";\n  var withNativeArrayBuffer$2 = typeof ArrayBuffer === \"function\";\n  // ArrayBuffer.isView method is not defined in IE10\n  var isView$1 = function isView(obj) {\n    return typeof ArrayBuffer.isView === \"function\" ? ArrayBuffer.isView(obj) : obj && obj.buffer instanceof ArrayBuffer;\n  };\n  var encodePacket = function encodePacket(_ref, supportsBinary, callback) {\n    var type = _ref.type,\n      data = _ref.data;\n    if (withNativeBlob$1 && data instanceof Blob) {\n      if (supportsBinary) {\n        return callback(data);\n      } else {\n        return encodeBlobAsBase64(data, callback);\n      }\n    } else if (withNativeArrayBuffer$2 && (data instanceof ArrayBuffer || isView$1(data))) {\n      if (supportsBinary) {\n        return callback(data);\n      } else {\n        return encodeBlobAsBase64(new Blob([data]), callback);\n      }\n    }\n    // plain string\n    return callback(PACKET_TYPES[type] + (data || \"\"));\n  };\n  var encodeBlobAsBase64 = function encodeBlobAsBase64(data, callback) {\n    var fileReader = new FileReader();\n    fileReader.onload = function () {\n      var content = fileReader.result.split(\",\")[1];\n      callback(\"b\" + (content || \"\"));\n    };\n    return fileReader.readAsDataURL(data);\n  };\n  function toArray(data) {\n    if (data instanceof Uint8Array) {\n      return data;\n    } else if (data instanceof ArrayBuffer) {\n      return new Uint8Array(data);\n    } else {\n      return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n    }\n  }\n  var TEXT_ENCODER;\n  function encodePacketToBinary(packet, callback) {\n    if (withNativeBlob$1 && packet.data instanceof Blob) {\n      return packet.data.arrayBuffer().then(toArray).then(callback);\n    } else if (withNativeArrayBuffer$2 && (packet.data instanceof ArrayBuffer || isView$1(packet.data))) {\n      return callback(toArray(packet.data));\n    }\n    encodePacket(packet, false, function (encoded) {\n      if (!TEXT_ENCODER) {\n        TEXT_ENCODER = new TextEncoder();\n      }\n      callback(TEXT_ENCODER.encode(encoded));\n    });\n  }\n\n  // imported from https://github.com/socketio/base64-arraybuffer\n  var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n  // Use a lookup table to find the index.\n  var lookup$1 = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);\n  for (var i$1 = 0; i$1 < chars.length; i$1++) {\n    lookup$1[chars.charCodeAt(i$1)] = i$1;\n  }\n  var decode$1 = function decode(base64) {\n    var bufferLength = base64.length * 0.75,\n      len = base64.length,\n      i,\n      p = 0,\n      encoded1,\n      encoded2,\n      encoded3,\n      encoded4;\n    if (base64[base64.length - 1] === '=') {\n      bufferLength--;\n      if (base64[base64.length - 2] === '=') {\n        bufferLength--;\n      }\n    }\n    var arraybuffer = new ArrayBuffer(bufferLength),\n      bytes = new Uint8Array(arraybuffer);\n    for (i = 0; i < len; i += 4) {\n      encoded1 = lookup$1[base64.charCodeAt(i)];\n      encoded2 = lookup$1[base64.charCodeAt(i + 1)];\n      encoded3 = lookup$1[base64.charCodeAt(i + 2)];\n      encoded4 = lookup$1[base64.charCodeAt(i + 3)];\n      bytes[p++] = encoded1 << 2 | encoded2 >> 4;\n      bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;\n      bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;\n    }\n    return arraybuffer;\n  };\n\n  var withNativeArrayBuffer$1 = typeof ArrayBuffer === \"function\";\n  var decodePacket = function decodePacket(encodedPacket, binaryType) {\n    if (typeof encodedPacket !== \"string\") {\n      return {\n        type: \"message\",\n        data: mapBinary(encodedPacket, binaryType)\n      };\n    }\n    var type = encodedPacket.charAt(0);\n    if (type === \"b\") {\n      return {\n        type: \"message\",\n        data: decodeBase64Packet(encodedPacket.substring(1), binaryType)\n      };\n    }\n    var packetType = PACKET_TYPES_REVERSE[type];\n    if (!packetType) {\n      return ERROR_PACKET;\n    }\n    return encodedPacket.length > 1 ? {\n      type: PACKET_TYPES_REVERSE[type],\n      data: encodedPacket.substring(1)\n    } : {\n      type: PACKET_TYPES_REVERSE[type]\n    };\n  };\n  var decodeBase64Packet = function decodeBase64Packet(data, binaryType) {\n    if (withNativeArrayBuffer$1) {\n      var decoded = decode$1(data);\n      return mapBinary(decoded, binaryType);\n    } else {\n      return {\n        base64: true,\n        data: data\n      }; // fallback for old browsers\n    }\n  };\n\n  var mapBinary = function mapBinary(data, binaryType) {\n    switch (binaryType) {\n      case \"blob\":\n        if (data instanceof Blob) {\n          // from WebSocket + binaryType \"blob\"\n          return data;\n        } else {\n          // from HTTP long-polling or WebTransport\n          return new Blob([data]);\n        }\n      case \"arraybuffer\":\n      default:\n        if (data instanceof ArrayBuffer) {\n          // from HTTP long-polling (base64) or WebSocket + binaryType \"arraybuffer\"\n          return data;\n        } else {\n          // from WebTransport (Uint8Array)\n          return data.buffer;\n        }\n    }\n  };\n\n  var SEPARATOR = String.fromCharCode(30); // see https://en.wikipedia.org/wiki/Delimiter#ASCII_delimited_text\n  var encodePayload = function encodePayload(packets, callback) {\n    // some packets may be added to the array while encoding, so the initial length must be saved\n    var length = packets.length;\n    var encodedPackets = new Array(length);\n    var count = 0;\n    packets.forEach(function (packet, i) {\n      // force base64 encoding for binary packets\n      encodePacket(packet, false, function (encodedPacket) {\n        encodedPackets[i] = encodedPacket;\n        if (++count === length) {\n          callback(encodedPackets.join(SEPARATOR));\n        }\n      });\n    });\n  };\n  var decodePayload = function decodePayload(encodedPayload, binaryType) {\n    var encodedPackets = encodedPayload.split(SEPARATOR);\n    var packets = [];\n    for (var i = 0; i < encodedPackets.length; i++) {\n      var decodedPacket = decodePacket(encodedPackets[i], binaryType);\n      packets.push(decodedPacket);\n      if (decodedPacket.type === \"error\") {\n        break;\n      }\n    }\n    return packets;\n  };\n  function createPacketEncoderStream() {\n    return new TransformStream({\n      transform: function transform(packet, controller) {\n        encodePacketToBinary(packet, function (encodedPacket) {\n          var payloadLength = encodedPacket.length;\n          var header;\n          // inspired by the WebSocket format: https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers#decoding_payload_length\n          if (payloadLength < 126) {\n            header = new Uint8Array(1);\n            new DataView(header.buffer).setUint8(0, payloadLength);\n          } else if (payloadLength < 65536) {\n            header = new Uint8Array(3);\n            var view = new DataView(header.buffer);\n            view.setUint8(0, 126);\n            view.setUint16(1, payloadLength);\n          } else {\n            header = new Uint8Array(9);\n            var _view = new DataView(header.buffer);\n            _view.setUint8(0, 127);\n            _view.setBigUint64(1, BigInt(payloadLength));\n          }\n          // first bit indicates whether the payload is plain text (0) or binary (1)\n          if (packet.data && typeof packet.data !== \"string\") {\n            header[0] |= 0x80;\n          }\n          controller.enqueue(header);\n          controller.enqueue(encodedPacket);\n        });\n      }\n    });\n  }\n  var TEXT_DECODER;\n  function totalLength(chunks) {\n    return chunks.reduce(function (acc, chunk) {\n      return acc + chunk.length;\n    }, 0);\n  }\n  function concatChunks(chunks, size) {\n    if (chunks[0].length === size) {\n      return chunks.shift();\n    }\n    var buffer = new Uint8Array(size);\n    var j = 0;\n    for (var i = 0; i < size; i++) {\n      buffer[i] = chunks[0][j++];\n      if (j === chunks[0].length) {\n        chunks.shift();\n        j = 0;\n      }\n    }\n    if (chunks.length && j < chunks[0].length) {\n      chunks[0] = chunks[0].slice(j);\n    }\n    return buffer;\n  }\n  function createPacketDecoderStream(maxPayload, binaryType) {\n    if (!TEXT_DECODER) {\n      TEXT_DECODER = new TextDecoder();\n    }\n    var chunks = [];\n    var state = 0 /* READ_HEADER */;\n    var expectedLength = -1;\n    var isBinary = false;\n    return new TransformStream({\n      transform: function transform(chunk, controller) {\n        chunks.push(chunk);\n        while (true) {\n          if (state === 0 /* READ_HEADER */) {\n            if (totalLength(chunks) < 1) {\n              break;\n            }\n            var header = concatChunks(chunks, 1);\n            isBinary = (header[0] & 0x80) === 0x80;\n            expectedLength = header[0] & 0x7f;\n            if (expectedLength < 126) {\n              state = 3 /* READ_PAYLOAD */;\n            } else if (expectedLength === 126) {\n              state = 1 /* READ_EXTENDED_LENGTH_16 */;\n            } else {\n              state = 2 /* READ_EXTENDED_LENGTH_64 */;\n            }\n          } else if (state === 1 /* READ_EXTENDED_LENGTH_16 */) {\n            if (totalLength(chunks) < 2) {\n              break;\n            }\n            var headerArray = concatChunks(chunks, 2);\n            expectedLength = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length).getUint16(0);\n            state = 3 /* READ_PAYLOAD */;\n          } else if (state === 2 /* READ_EXTENDED_LENGTH_64 */) {\n            if (totalLength(chunks) < 8) {\n              break;\n            }\n            var _headerArray = concatChunks(chunks, 8);\n            var view = new DataView(_headerArray.buffer, _headerArray.byteOffset, _headerArray.length);\n            var n = view.getUint32(0);\n            if (n > Math.pow(2, 53 - 32) - 1) {\n              // the maximum safe integer in JavaScript is 2^53 - 1\n              controller.enqueue(ERROR_PACKET);\n              break;\n            }\n            expectedLength = n * Math.pow(2, 32) + view.getUint32(4);\n            state = 3 /* READ_PAYLOAD */;\n          } else {\n            if (totalLength(chunks) < expectedLength) {\n              break;\n            }\n            var data = concatChunks(chunks, expectedLength);\n            controller.enqueue(decodePacket(isBinary ? data : TEXT_DECODER.decode(data), binaryType));\n            state = 0 /* READ_HEADER */;\n          }\n\n          if (expectedLength === 0 || expectedLength > maxPayload) {\n            controller.enqueue(ERROR_PACKET);\n            break;\n          }\n        }\n      }\n    });\n  }\n  var protocol$1 = 4;\n\n  /**\n   * Initialize a new `Emitter`.\n   *\n   * @api public\n   */\n\n  function Emitter(obj) {\n    if (obj) return mixin(obj);\n  }\n\n  /**\n   * Mixin the emitter properties.\n   *\n   * @param {Object} obj\n   * @return {Object}\n   * @api private\n   */\n\n  function mixin(obj) {\n    for (var key in Emitter.prototype) {\n      obj[key] = Emitter.prototype[key];\n    }\n    return obj;\n  }\n\n  /**\n   * Listen on the given `event` with `fn`.\n   *\n   * @param {String} event\n   * @param {Function} fn\n   * @return {Emitter}\n   * @api public\n   */\n\n  Emitter.prototype.on = Emitter.prototype.addEventListener = function (event, fn) {\n    this._callbacks = this._callbacks || {};\n    (this._callbacks['$' + event] = this._callbacks['$' + event] || []).push(fn);\n    return this;\n  };\n\n  /**\n   * Adds an `event` listener that will be invoked a single\n   * time then automatically removed.\n   *\n   * @param {String} event\n   * @param {Function} fn\n   * @return {Emitter}\n   * @api public\n   */\n\n  Emitter.prototype.once = function (event, fn) {\n    function on() {\n      this.off(event, on);\n      fn.apply(this, arguments);\n    }\n    on.fn = fn;\n    this.on(event, on);\n    return this;\n  };\n\n  /**\n   * Remove the given callback for `event` or all\n   * registered callbacks.\n   *\n   * @param {String} event\n   * @param {Function} fn\n   * @return {Emitter}\n   * @api public\n   */\n\n  Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function (event, fn) {\n    this._callbacks = this._callbacks || {};\n\n    // all\n    if (0 == arguments.length) {\n      this._callbacks = {};\n      return this;\n    }\n\n    // specific event\n    var callbacks = this._callbacks['$' + event];\n    if (!callbacks) return this;\n\n    // remove all handlers\n    if (1 == arguments.length) {\n      delete this._callbacks['$' + event];\n      return this;\n    }\n\n    // remove specific handler\n    var cb;\n    for (var i = 0; i < callbacks.length; i++) {\n      cb = callbacks[i];\n      if (cb === fn || cb.fn === fn) {\n        callbacks.splice(i, 1);\n        break;\n      }\n    }\n\n    // Remove event specific arrays for event types that no\n    // one is subscribed for to avoid memory leak.\n    if (callbacks.length === 0) {\n      delete this._callbacks['$' + event];\n    }\n    return this;\n  };\n\n  /**\n   * Emit `event` with the given args.\n   *\n   * @param {String} event\n   * @param {Mixed} ...\n   * @return {Emitter}\n   */\n\n  Emitter.prototype.emit = function (event) {\n    this._callbacks = this._callbacks || {};\n    var args = new Array(arguments.length - 1),\n      callbacks = this._callbacks['$' + event];\n    for (var i = 1; i < arguments.length; i++) {\n      args[i - 1] = arguments[i];\n    }\n    if (callbacks) {\n      callbacks = callbacks.slice(0);\n      for (var i = 0, len = callbacks.length; i < len; ++i) {\n        callbacks[i].apply(this, args);\n      }\n    }\n    return this;\n  };\n\n  // alias used for reserved events (protected method)\n  Emitter.prototype.emitReserved = Emitter.prototype.emit;\n\n  /**\n   * Return array of callbacks for `event`.\n   *\n   * @param {String} event\n   * @return {Array}\n   * @api public\n   */\n\n  Emitter.prototype.listeners = function (event) {\n    this._callbacks = this._callbacks || {};\n    return this._callbacks['$' + event] || [];\n  };\n\n  /**\n   * Check if this emitter has `event` handlers.\n   *\n   * @param {String} event\n   * @return {Boolean}\n   * @api public\n   */\n\n  Emitter.prototype.hasListeners = function (event) {\n    return !!this.listeners(event).length;\n  };\n\n  var globalThisShim = function () {\n    if (typeof self !== \"undefined\") {\n      return self;\n    } else if (typeof window !== \"undefined\") {\n      return window;\n    } else {\n      return Function(\"return this\")();\n    }\n  }();\n\n  function pick(obj) {\n    for (var _len = arguments.length, attr = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      attr[_key - 1] = arguments[_key];\n    }\n    return attr.reduce(function (acc, k) {\n      if (obj.hasOwnProperty(k)) {\n        acc[k] = obj[k];\n      }\n      return acc;\n    }, {});\n  }\n  // Keep a reference to the real timeout functions so they can be used when overridden\n  var NATIVE_SET_TIMEOUT = globalThisShim.setTimeout;\n  var NATIVE_CLEAR_TIMEOUT = globalThisShim.clearTimeout;\n  function installTimerFunctions(obj, opts) {\n    if (opts.useNativeTimers) {\n      obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThisShim);\n      obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThisShim);\n    } else {\n      obj.setTimeoutFn = globalThisShim.setTimeout.bind(globalThisShim);\n      obj.clearTimeoutFn = globalThisShim.clearTimeout.bind(globalThisShim);\n    }\n  }\n  // base64 encoded buffers are about 33% bigger (https://en.wikipedia.org/wiki/Base64)\n  var BASE64_OVERHEAD = 1.33;\n  // we could also have used `new Blob([obj]).size`, but it isn't supported in IE9\n  function byteLength(obj) {\n    if (typeof obj === \"string\") {\n      return utf8Length(obj);\n    }\n    // arraybuffer or blob\n    return Math.ceil((obj.byteLength || obj.size) * BASE64_OVERHEAD);\n  }\n  function utf8Length(str) {\n    var c = 0,\n      length = 0;\n    for (var i = 0, l = str.length; i < l; i++) {\n      c = str.charCodeAt(i);\n      if (c < 0x80) {\n        length += 1;\n      } else if (c < 0x800) {\n        length += 2;\n      } else if (c < 0xd800 || c >= 0xe000) {\n        length += 3;\n      } else {\n        i++;\n        length += 4;\n      }\n    }\n    return length;\n  }\n\n  // imported from https://github.com/galkn/querystring\n  /**\n   * Compiles a querystring\n   * Returns string representation of the object\n   *\n   * @param {Object}\n   * @api private\n   */\n  function encode$1(obj) {\n    var str = '';\n    for (var i in obj) {\n      if (obj.hasOwnProperty(i)) {\n        if (str.length) str += '&';\n        str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);\n      }\n    }\n    return str;\n  }\n  /**\n   * Parses a simple querystring into an object\n   *\n   * @param {String} qs\n   * @api private\n   */\n  function decode(qs) {\n    var qry = {};\n    var pairs = qs.split('&');\n    for (var i = 0, l = pairs.length; i < l; i++) {\n      var pair = pairs[i].split('=');\n      qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);\n    }\n    return qry;\n  }\n\n  var TransportError = /*#__PURE__*/function (_Error) {\n    _inherits(TransportError, _Error);\n    var _super = _createSuper(TransportError);\n    function TransportError(reason, description, context) {\n      var _this;\n      _classCallCheck(this, TransportError);\n      _this = _super.call(this, reason);\n      _this.description = description;\n      _this.context = context;\n      _this.type = \"TransportError\";\n      return _this;\n    }\n    return _createClass(TransportError);\n  }( /*#__PURE__*/_wrapNativeSuper(Error));\n  var Transport = /*#__PURE__*/function (_Emitter) {\n    _inherits(Transport, _Emitter);\n    var _super2 = _createSuper(Transport);\n    /**\n     * Transport abstract constructor.\n     *\n     * @param {Object} opts - options\n     * @protected\n     */\n    function Transport(opts) {\n      var _this2;\n      _classCallCheck(this, Transport);\n      _this2 = _super2.call(this);\n      _this2.writable = false;\n      installTimerFunctions(_assertThisInitialized(_this2), opts);\n      _this2.opts = opts;\n      _this2.query = opts.query;\n      _this2.socket = opts.socket;\n      return _this2;\n    }\n    /**\n     * Emits an error.\n     *\n     * @param {String} reason\n     * @param description\n     * @param context - the error context\n     * @return {Transport} for chaining\n     * @protected\n     */\n    _createClass(Transport, [{\n      key: \"onError\",\n      value: function onError(reason, description, context) {\n        _get(_getPrototypeOf(Transport.prototype), \"emitReserved\", this).call(this, \"error\", new TransportError(reason, description, context));\n        return this;\n      }\n      /**\n       * Opens the transport.\n       */\n    }, {\n      key: \"open\",\n      value: function open() {\n        this.readyState = \"opening\";\n        this.doOpen();\n        return this;\n      }\n      /**\n       * Closes the transport.\n       */\n    }, {\n      key: \"close\",\n      value: function close() {\n        if (this.readyState === \"opening\" || this.readyState === \"open\") {\n          this.doClose();\n          this.onClose();\n        }\n        return this;\n      }\n      /**\n       * Sends multiple packets.\n       *\n       * @param {Array} packets\n       */\n    }, {\n      key: \"send\",\n      value: function send(packets) {\n        if (this.readyState === \"open\") {\n          this.write(packets);\n        }\n      }\n      /**\n       * Called upon open\n       *\n       * @protected\n       */\n    }, {\n      key: \"onOpen\",\n      value: function onOpen() {\n        this.readyState = \"open\";\n        this.writable = true;\n        _get(_getPrototypeOf(Transport.prototype), \"emitReserved\", this).call(this, \"open\");\n      }\n      /**\n       * Called with data.\n       *\n       * @param {String} data\n       * @protected\n       */\n    }, {\n      key: \"onData\",\n      value: function onData(data) {\n        var packet = decodePacket(data, this.socket.binaryType);\n        this.onPacket(packet);\n      }\n      /**\n       * Called with a decoded packet.\n       *\n       * @protected\n       */\n    }, {\n      key: \"onPacket\",\n      value: function onPacket(packet) {\n        _get(_getPrototypeOf(Transport.prototype), \"emitReserved\", this).call(this, \"packet\", packet);\n      }\n      /**\n       * Called upon close.\n       *\n       * @protected\n       */\n    }, {\n      key: \"onClose\",\n      value: function onClose(details) {\n        this.readyState = \"closed\";\n        _get(_getPrototypeOf(Transport.prototype), \"emitReserved\", this).call(this, \"close\", details);\n      }\n      /**\n       * Pauses the transport, in order not to lose packets during an upgrade.\n       *\n       * @param onPause\n       */\n    }, {\n      key: \"pause\",\n      value: function pause(onPause) {}\n    }, {\n      key: \"createUri\",\n      value: function createUri(schema) {\n        var query = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        return schema + \"://\" + this._hostname() + this._port() + this.opts.path + this._query(query);\n      }\n    }, {\n      key: \"_hostname\",\n      value: function _hostname() {\n        var hostname = this.opts.hostname;\n        return hostname.indexOf(\":\") === -1 ? hostname : \"[\" + hostname + \"]\";\n      }\n    }, {\n      key: \"_port\",\n      value: function _port() {\n        if (this.opts.port && (this.opts.secure && Number(this.opts.port !== 443) || !this.opts.secure && Number(this.opts.port) !== 80)) {\n          return \":\" + this.opts.port;\n        } else {\n          return \"\";\n        }\n      }\n    }, {\n      key: \"_query\",\n      value: function _query(query) {\n        var encodedQuery = encode$1(query);\n        return encodedQuery.length ? \"?\" + encodedQuery : \"\";\n      }\n    }]);\n    return Transport;\n  }(Emitter);\n\n  // imported from https://github.com/unshiftio/yeast\n\n  var alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split(''),\n    length = 64,\n    map = {};\n  var seed = 0,\n    i = 0,\n    prev;\n  /**\n   * Return a string representing the specified number.\n   *\n   * @param {Number} num The number to convert.\n   * @returns {String} The string representation of the number.\n   * @api public\n   */\n  function encode(num) {\n    var encoded = '';\n    do {\n      encoded = alphabet[num % length] + encoded;\n      num = Math.floor(num / length);\n    } while (num > 0);\n    return encoded;\n  }\n  /**\n   * Yeast: A tiny growing id generator.\n   *\n   * @returns {String} A unique id.\n   * @api public\n   */\n  function yeast() {\n    var now = encode(+new Date());\n    if (now !== prev) return seed = 0, prev = now;\n    return now + '.' + encode(seed++);\n  }\n  //\n  // Map each character to its index.\n  //\n  for (; i < length; i++) map[alphabet[i]] = i;\n\n  // imported from https://github.com/component/has-cors\n  var value = false;\n  try {\n    value = typeof XMLHttpRequest !== 'undefined' && 'withCredentials' in new XMLHttpRequest();\n  } catch (err) {\n    // if XMLHttp support is disabled in IE then it will throw\n    // when trying to create\n  }\n  var hasCORS = value;\n\n  // browser shim for xmlhttprequest module\n  function XHR(opts) {\n    var xdomain = opts.xdomain;\n    // XMLHttpRequest can be disabled on IE\n    try {\n      if (\"undefined\" !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {\n        return new XMLHttpRequest();\n      }\n    } catch (e) {}\n    if (!xdomain) {\n      try {\n        return new globalThisShim[[\"Active\"].concat(\"Object\").join(\"X\")](\"Microsoft.XMLHTTP\");\n      } catch (e) {}\n    }\n  }\n  function createCookieJar() {}\n\n  function empty() {}\n  var hasXHR2 = function () {\n    var xhr = new XHR({\n      xdomain: false\n    });\n    return null != xhr.responseType;\n  }();\n  var Polling = /*#__PURE__*/function (_Transport) {\n    _inherits(Polling, _Transport);\n    var _super = _createSuper(Polling);\n    /**\n     * XHR Polling constructor.\n     *\n     * @param {Object} opts\n     * @package\n     */\n    function Polling(opts) {\n      var _this;\n      _classCallCheck(this, Polling);\n      _this = _super.call(this, opts);\n      _this.polling = false;\n      if (typeof location !== \"undefined\") {\n        var isSSL = \"https:\" === location.protocol;\n        var port = location.port;\n        // some user agents have empty `location.port`\n        if (!port) {\n          port = isSSL ? \"443\" : \"80\";\n        }\n        _this.xd = typeof location !== \"undefined\" && opts.hostname !== location.hostname || port !== opts.port;\n      }\n      /**\n       * XHR supports binary\n       */\n      var forceBase64 = opts && opts.forceBase64;\n      _this.supportsBinary = hasXHR2 && !forceBase64;\n      if (_this.opts.withCredentials) {\n        _this.cookieJar = createCookieJar();\n      }\n      return _this;\n    }\n    _createClass(Polling, [{\n      key: \"name\",\n      get: function get() {\n        return \"polling\";\n      }\n      /**\n       * Opens the socket (triggers polling). We write a PING message to determine\n       * when the transport is open.\n       *\n       * @protected\n       */\n    }, {\n      key: \"doOpen\",\n      value: function doOpen() {\n        this.poll();\n      }\n      /**\n       * Pauses polling.\n       *\n       * @param {Function} onPause - callback upon buffers are flushed and transport is paused\n       * @package\n       */\n    }, {\n      key: \"pause\",\n      value: function pause(onPause) {\n        var _this2 = this;\n        this.readyState = \"pausing\";\n        var pause = function pause() {\n          _this2.readyState = \"paused\";\n          onPause();\n        };\n        if (this.polling || !this.writable) {\n          var total = 0;\n          if (this.polling) {\n            total++;\n            this.once(\"pollComplete\", function () {\n              --total || pause();\n            });\n          }\n          if (!this.writable) {\n            total++;\n            this.once(\"drain\", function () {\n              --total || pause();\n            });\n          }\n        } else {\n          pause();\n        }\n      }\n      /**\n       * Starts polling cycle.\n       *\n       * @private\n       */\n    }, {\n      key: \"poll\",\n      value: function poll() {\n        this.polling = true;\n        this.doPoll();\n        this.emitReserved(\"poll\");\n      }\n      /**\n       * Overloads onData to detect payloads.\n       *\n       * @protected\n       */\n    }, {\n      key: \"onData\",\n      value: function onData(data) {\n        var _this3 = this;\n        var callback = function callback(packet) {\n          // if its the first message we consider the transport open\n          if (\"opening\" === _this3.readyState && packet.type === \"open\") {\n            _this3.onOpen();\n          }\n          // if its a close packet, we close the ongoing requests\n          if (\"close\" === packet.type) {\n            _this3.onClose({\n              description: \"transport closed by the server\"\n            });\n            return false;\n          }\n          // otherwise bypass onData and handle the message\n          _this3.onPacket(packet);\n        };\n        // decode payload\n        decodePayload(data, this.socket.binaryType).forEach(callback);\n        // if an event did not trigger closing\n        if (\"closed\" !== this.readyState) {\n          // if we got data we're not polling\n          this.polling = false;\n          this.emitReserved(\"pollComplete\");\n          if (\"open\" === this.readyState) {\n            this.poll();\n          }\n        }\n      }\n      /**\n       * For polling, send a close packet.\n       *\n       * @protected\n       */\n    }, {\n      key: \"doClose\",\n      value: function doClose() {\n        var _this4 = this;\n        var close = function close() {\n          _this4.write([{\n            type: \"close\"\n          }]);\n        };\n        if (\"open\" === this.readyState) {\n          close();\n        } else {\n          // in case we're trying to close while\n          // handshaking is in progress (GH-164)\n          this.once(\"open\", close);\n        }\n      }\n      /**\n       * Writes a packets payload.\n       *\n       * @param {Array} packets - data packets\n       * @protected\n       */\n    }, {\n      key: \"write\",\n      value: function write(packets) {\n        var _this5 = this;\n        this.writable = false;\n        encodePayload(packets, function (data) {\n          _this5.doWrite(data, function () {\n            _this5.writable = true;\n            _this5.emitReserved(\"drain\");\n          });\n        });\n      }\n      /**\n       * Generates uri for connection.\n       *\n       * @private\n       */\n    }, {\n      key: \"uri\",\n      value: function uri() {\n        var schema = this.opts.secure ? \"https\" : \"http\";\n        var query = this.query || {};\n        // cache busting is forced\n        if (false !== this.opts.timestampRequests) {\n          query[this.opts.timestampParam] = yeast();\n        }\n        if (!this.supportsBinary && !query.sid) {\n          query.b64 = 1;\n        }\n        return this.createUri(schema, query);\n      }\n      /**\n       * Creates a request.\n       *\n       * @param {String} method\n       * @private\n       */\n    }, {\n      key: \"request\",\n      value: function request() {\n        var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        _extends(opts, {\n          xd: this.xd,\n          cookieJar: this.cookieJar\n        }, this.opts);\n        return new Request(this.uri(), opts);\n      }\n      /**\n       * Sends data.\n       *\n       * @param {String} data to send.\n       * @param {Function} called upon flush.\n       * @private\n       */\n    }, {\n      key: \"doWrite\",\n      value: function doWrite(data, fn) {\n        var _this6 = this;\n        var req = this.request({\n          method: \"POST\",\n          data: data\n        });\n        req.on(\"success\", fn);\n        req.on(\"error\", function (xhrStatus, context) {\n          _this6.onError(\"xhr post error\", xhrStatus, context);\n        });\n      }\n      /**\n       * Starts a poll cycle.\n       *\n       * @private\n       */\n    }, {\n      key: \"doPoll\",\n      value: function doPoll() {\n        var _this7 = this;\n        var req = this.request();\n        req.on(\"data\", this.onData.bind(this));\n        req.on(\"error\", function (xhrStatus, context) {\n          _this7.onError(\"xhr poll error\", xhrStatus, context);\n        });\n        this.pollXhr = req;\n      }\n    }]);\n    return Polling;\n  }(Transport);\n  var Request = /*#__PURE__*/function (_Emitter) {\n    _inherits(Request, _Emitter);\n    var _super2 = _createSuper(Request);\n    /**\n     * Request constructor\n     *\n     * @param {Object} options\n     * @package\n     */\n    function Request(uri, opts) {\n      var _this8;\n      _classCallCheck(this, Request);\n      _this8 = _super2.call(this);\n      installTimerFunctions(_assertThisInitialized(_this8), opts);\n      _this8.opts = opts;\n      _this8.method = opts.method || \"GET\";\n      _this8.uri = uri;\n      _this8.data = undefined !== opts.data ? opts.data : null;\n      _this8.create();\n      return _this8;\n    }\n    /**\n     * Creates the XHR object and sends the request.\n     *\n     * @private\n     */\n    _createClass(Request, [{\n      key: \"create\",\n      value: function create() {\n        var _this9 = this;\n        var _a;\n        var opts = pick(this.opts, \"agent\", \"pfx\", \"key\", \"passphrase\", \"cert\", \"ca\", \"ciphers\", \"rejectUnauthorized\", \"autoUnref\");\n        opts.xdomain = !!this.opts.xd;\n        var xhr = this.xhr = new XHR(opts);\n        try {\n          xhr.open(this.method, this.uri, true);\n          try {\n            if (this.opts.extraHeaders) {\n              xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);\n              for (var i in this.opts.extraHeaders) {\n                if (this.opts.extraHeaders.hasOwnProperty(i)) {\n                  xhr.setRequestHeader(i, this.opts.extraHeaders[i]);\n                }\n              }\n            }\n          } catch (e) {}\n          if (\"POST\" === this.method) {\n            try {\n              xhr.setRequestHeader(\"Content-type\", \"text/plain;charset=UTF-8\");\n            } catch (e) {}\n          }\n          try {\n            xhr.setRequestHeader(\"Accept\", \"*/*\");\n          } catch (e) {}\n          (_a = this.opts.cookieJar) === null || _a === void 0 ? void 0 : _a.addCookies(xhr);\n          // ie6 check\n          if (\"withCredentials\" in xhr) {\n            xhr.withCredentials = this.opts.withCredentials;\n          }\n          if (this.opts.requestTimeout) {\n            xhr.timeout = this.opts.requestTimeout;\n          }\n          xhr.onreadystatechange = function () {\n            var _a;\n            if (xhr.readyState === 3) {\n              (_a = _this9.opts.cookieJar) === null || _a === void 0 ? void 0 : _a.parseCookies(xhr);\n            }\n            if (4 !== xhr.readyState) return;\n            if (200 === xhr.status || 1223 === xhr.status) {\n              _this9.onLoad();\n            } else {\n              // make sure the `error` event handler that's user-set\n              // does not throw in the same tick and gets caught here\n              _this9.setTimeoutFn(function () {\n                _this9.onError(typeof xhr.status === \"number\" ? xhr.status : 0);\n              }, 0);\n            }\n          };\n          xhr.send(this.data);\n        } catch (e) {\n          // Need to defer since .create() is called directly from the constructor\n          // and thus the 'error' event can only be only bound *after* this exception\n          // occurs.  Therefore, also, we cannot throw here at all.\n          this.setTimeoutFn(function () {\n            _this9.onError(e);\n          }, 0);\n          return;\n        }\n        if (typeof document !== \"undefined\") {\n          this.index = Request.requestsCount++;\n          Request.requests[this.index] = this;\n        }\n      }\n      /**\n       * Called upon error.\n       *\n       * @private\n       */\n    }, {\n      key: \"onError\",\n      value: function onError(err) {\n        this.emitReserved(\"error\", err, this.xhr);\n        this.cleanup(true);\n      }\n      /**\n       * Cleans up house.\n       *\n       * @private\n       */\n    }, {\n      key: \"cleanup\",\n      value: function cleanup(fromError) {\n        if (\"undefined\" === typeof this.xhr || null === this.xhr) {\n          return;\n        }\n        this.xhr.onreadystatechange = empty;\n        if (fromError) {\n          try {\n            this.xhr.abort();\n          } catch (e) {}\n        }\n        if (typeof document !== \"undefined\") {\n          delete Request.requests[this.index];\n        }\n        this.xhr = null;\n      }\n      /**\n       * Called upon load.\n       *\n       * @private\n       */\n    }, {\n      key: \"onLoad\",\n      value: function onLoad() {\n        var data = this.xhr.responseText;\n        if (data !== null) {\n          this.emitReserved(\"data\", data);\n          this.emitReserved(\"success\");\n          this.cleanup();\n        }\n      }\n      /**\n       * Aborts the request.\n       *\n       * @package\n       */\n    }, {\n      key: \"abort\",\n      value: function abort() {\n        this.cleanup();\n      }\n    }]);\n    return Request;\n  }(Emitter);\n  Request.requestsCount = 0;\n  Request.requests = {};\n  /**\n   * Aborts pending requests when unloading the window. This is needed to prevent\n   * memory leaks (e.g. when using IE) and to ensure that no spurious error is\n   * emitted.\n   */\n  if (typeof document !== \"undefined\") {\n    // @ts-ignore\n    if (typeof attachEvent === \"function\") {\n      // @ts-ignore\n      attachEvent(\"onunload\", unloadHandler);\n    } else if (typeof addEventListener === \"function\") {\n      var terminationEvent = \"onpagehide\" in globalThisShim ? \"pagehide\" : \"unload\";\n      addEventListener(terminationEvent, unloadHandler, false);\n    }\n  }\n  function unloadHandler() {\n    for (var i in Request.requests) {\n      if (Request.requests.hasOwnProperty(i)) {\n        Request.requests[i].abort();\n      }\n    }\n  }\n\n  var nextTick = function () {\n    var isPromiseAvailable = typeof Promise === \"function\" && typeof Promise.resolve === \"function\";\n    if (isPromiseAvailable) {\n      return function (cb) {\n        return Promise.resolve().then(cb);\n      };\n    } else {\n      return function (cb, setTimeoutFn) {\n        return setTimeoutFn(cb, 0);\n      };\n    }\n  }();\n  var WebSocket = globalThisShim.WebSocket || globalThisShim.MozWebSocket;\n  var usingBrowserWebSocket = true;\n  var defaultBinaryType = \"arraybuffer\";\n\n  // detect ReactNative environment\n  var isReactNative = typeof navigator !== \"undefined\" && typeof navigator.product === \"string\" && navigator.product.toLowerCase() === \"reactnative\";\n  var WS = /*#__PURE__*/function (_Transport) {\n    _inherits(WS, _Transport);\n    var _super = _createSuper(WS);\n    /**\n     * WebSocket transport constructor.\n     *\n     * @param {Object} opts - connection options\n     * @protected\n     */\n    function WS(opts) {\n      var _this;\n      _classCallCheck(this, WS);\n      _this = _super.call(this, opts);\n      _this.supportsBinary = !opts.forceBase64;\n      return _this;\n    }\n    _createClass(WS, [{\n      key: \"name\",\n      get: function get() {\n        return \"websocket\";\n      }\n    }, {\n      key: \"doOpen\",\n      value: function doOpen() {\n        if (!this.check()) {\n          // let probe timeout\n          return;\n        }\n        var uri = this.uri();\n        var protocols = this.opts.protocols;\n        // React Native only supports the 'headers' option, and will print a warning if anything else is passed\n        var opts = isReactNative ? {} : pick(this.opts, \"agent\", \"perMessageDeflate\", \"pfx\", \"key\", \"passphrase\", \"cert\", \"ca\", \"ciphers\", \"rejectUnauthorized\", \"localAddress\", \"protocolVersion\", \"origin\", \"maxPayload\", \"family\", \"checkServerIdentity\");\n        if (this.opts.extraHeaders) {\n          opts.headers = this.opts.extraHeaders;\n        }\n        try {\n          this.ws = usingBrowserWebSocket && !isReactNative ? protocols ? new WebSocket(uri, protocols) : new WebSocket(uri) : new WebSocket(uri, protocols, opts);\n        } catch (err) {\n          return this.emitReserved(\"error\", err);\n        }\n        this.ws.binaryType = this.socket.binaryType;\n        this.addEventListeners();\n      }\n      /**\n       * Adds event listeners to the socket\n       *\n       * @private\n       */\n    }, {\n      key: \"addEventListeners\",\n      value: function addEventListeners() {\n        var _this2 = this;\n        this.ws.onopen = function () {\n          if (_this2.opts.autoUnref) {\n            _this2.ws._socket.unref();\n          }\n          _this2.onOpen();\n        };\n        this.ws.onclose = function (closeEvent) {\n          return _this2.onClose({\n            description: \"websocket connection closed\",\n            context: closeEvent\n          });\n        };\n        this.ws.onmessage = function (ev) {\n          return _this2.onData(ev.data);\n        };\n        this.ws.onerror = function (e) {\n          return _this2.onError(\"websocket error\", e);\n        };\n      }\n    }, {\n      key: \"write\",\n      value: function write(packets) {\n        var _this3 = this;\n        this.writable = false;\n        // encodePacket efficient as it uses WS framing\n        // no need for encodePayload\n        var _loop = function _loop() {\n          var packet = packets[i];\n          var lastPacket = i === packets.length - 1;\n          encodePacket(packet, _this3.supportsBinary, function (data) {\n            // always create a new object (GH-437)\n            var opts = {};\n            // Sometimes the websocket has already been closed but the browser didn't\n            // have a chance of informing us about it yet, in that case send will\n            // throw an error\n            try {\n              if (usingBrowserWebSocket) {\n                // TypeError is thrown when passing the second argument on Safari\n                _this3.ws.send(data);\n              }\n            } catch (e) {}\n            if (lastPacket) {\n              // fake drain\n              // defer to next tick to allow Socket to clear writeBuffer\n              nextTick(function () {\n                _this3.writable = true;\n                _this3.emitReserved(\"drain\");\n              }, _this3.setTimeoutFn);\n            }\n          });\n        };\n        for (var i = 0; i < packets.length; i++) {\n          _loop();\n        }\n      }\n    }, {\n      key: \"doClose\",\n      value: function doClose() {\n        if (typeof this.ws !== \"undefined\") {\n          this.ws.close();\n          this.ws = null;\n        }\n      }\n      /**\n       * Generates uri for connection.\n       *\n       * @private\n       */\n    }, {\n      key: \"uri\",\n      value: function uri() {\n        var schema = this.opts.secure ? \"wss\" : \"ws\";\n        var query = this.query || {};\n        // append timestamp to URI\n        if (this.opts.timestampRequests) {\n          query[this.opts.timestampParam] = yeast();\n        }\n        // communicate binary support capabilities\n        if (!this.supportsBinary) {\n          query.b64 = 1;\n        }\n        return this.createUri(schema, query);\n      }\n      /**\n       * Feature detection for WebSocket.\n       *\n       * @return {Boolean} whether this transport is available.\n       * @private\n       */\n    }, {\n      key: \"check\",\n      value: function check() {\n        return !!WebSocket;\n      }\n    }]);\n    return WS;\n  }(Transport);\n\n  var WT = /*#__PURE__*/function (_Transport) {\n    _inherits(WT, _Transport);\n    var _super = _createSuper(WT);\n    function WT() {\n      _classCallCheck(this, WT);\n      return _super.apply(this, arguments);\n    }\n    _createClass(WT, [{\n      key: \"name\",\n      get: function get() {\n        return \"webtransport\";\n      }\n    }, {\n      key: \"doOpen\",\n      value: function doOpen() {\n        var _this = this;\n        // @ts-ignore\n        if (typeof WebTransport !== \"function\") {\n          return;\n        }\n        // @ts-ignore\n        this.transport = new WebTransport(this.createUri(\"https\"), this.opts.transportOptions[this.name]);\n        this.transport.closed.then(function () {\n          _this.onClose();\n        })[\"catch\"](function (err) {\n          _this.onError(\"webtransport error\", err);\n        });\n        // note: we could have used async/await, but that would require some additional polyfills\n        this.transport.ready.then(function () {\n          _this.transport.createBidirectionalStream().then(function (stream) {\n            var decoderStream = createPacketDecoderStream(Number.MAX_SAFE_INTEGER, _this.socket.binaryType);\n            var reader = stream.readable.pipeThrough(decoderStream).getReader();\n            var encoderStream = createPacketEncoderStream();\n            encoderStream.readable.pipeTo(stream.writable);\n            _this.writer = encoderStream.writable.getWriter();\n            var read = function read() {\n              reader.read().then(function (_ref) {\n                var done = _ref.done,\n                  value = _ref.value;\n                if (done) {\n                  return;\n                }\n                _this.onPacket(value);\n                read();\n              })[\"catch\"](function (err) {});\n            };\n            read();\n            var packet = {\n              type: \"open\"\n            };\n            if (_this.query.sid) {\n              packet.data = \"{\\\"sid\\\":\\\"\".concat(_this.query.sid, \"\\\"}\");\n            }\n            _this.writer.write(packet).then(function () {\n              return _this.onOpen();\n            });\n          });\n        });\n      }\n    }, {\n      key: \"write\",\n      value: function write(packets) {\n        var _this2 = this;\n        this.writable = false;\n        var _loop = function _loop() {\n          var packet = packets[i];\n          var lastPacket = i === packets.length - 1;\n          _this2.writer.write(packet).then(function () {\n            if (lastPacket) {\n              nextTick(function () {\n                _this2.writable = true;\n                _this2.emitReserved(\"drain\");\n              }, _this2.setTimeoutFn);\n            }\n          });\n        };\n        for (var i = 0; i < packets.length; i++) {\n          _loop();\n        }\n      }\n    }, {\n      key: \"doClose\",\n      value: function doClose() {\n        var _a;\n        (_a = this.transport) === null || _a === void 0 ? void 0 : _a.close();\n      }\n    }]);\n    return WT;\n  }(Transport);\n\n  var transports = {\n    websocket: WS,\n    webtransport: WT,\n    polling: Polling\n  };\n\n  // imported from https://github.com/galkn/parseuri\n  /**\n   * Parses a URI\n   *\n   * Note: we could also have used the built-in URL object, but it isn't supported on all platforms.\n   *\n   * See:\n   * - https://developer.mozilla.org/en-US/docs/Web/API/URL\n   * - https://caniuse.com/url\n   * - https://www.rfc-editor.org/rfc/rfc3986#appendix-B\n   *\n   * History of the parse() method:\n   * - first commit: https://github.com/socketio/socket.io-client/commit/4ee1d5d94b3906a9c052b459f1a818b15f38f91c\n   * - export into its own module: https://github.com/socketio/engine.io-client/commit/de2c561e4564efeb78f1bdb1ba39ef81b2822cb3\n   * - reimport: https://github.com/socketio/engine.io-client/commit/df32277c3f6d622eec5ed09f493cae3f3391d242\n   *\n   * @author Steven Levithan <stevenlevithan.com> (MIT license)\n   * @api private\n   */\n  var re = /^(?:(?![^:@\\/?#]+:[^:@\\/]*@)(http|https|ws|wss):\\/\\/)?((?:(([^:@\\/?#]*)(?::([^:@\\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\n  var parts = ['source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'];\n  function parse(str) {\n    var src = str,\n      b = str.indexOf('['),\n      e = str.indexOf(']');\n    if (b != -1 && e != -1) {\n      str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);\n    }\n    var m = re.exec(str || ''),\n      uri = {},\n      i = 14;\n    while (i--) {\n      uri[parts[i]] = m[i] || '';\n    }\n    if (b != -1 && e != -1) {\n      uri.source = src;\n      uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');\n      uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');\n      uri.ipv6uri = true;\n    }\n    uri.pathNames = pathNames(uri, uri['path']);\n    uri.queryKey = queryKey(uri, uri['query']);\n    return uri;\n  }\n  function pathNames(obj, path) {\n    var regx = /\\/{2,9}/g,\n      names = path.replace(regx, \"/\").split(\"/\");\n    if (path.slice(0, 1) == '/' || path.length === 0) {\n      names.splice(0, 1);\n    }\n    if (path.slice(-1) == '/') {\n      names.splice(names.length - 1, 1);\n    }\n    return names;\n  }\n  function queryKey(uri, query) {\n    var data = {};\n    query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function ($0, $1, $2) {\n      if ($1) {\n        data[$1] = $2;\n      }\n    });\n    return data;\n  }\n\n  var Socket$1 = /*#__PURE__*/function (_Emitter) {\n    _inherits(Socket, _Emitter);\n    var _super = _createSuper(Socket);\n    /**\n     * Socket constructor.\n     *\n     * @param {String|Object} uri - uri or options\n     * @param {Object} opts - options\n     */\n    function Socket(uri) {\n      var _this;\n      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      _classCallCheck(this, Socket);\n      _this = _super.call(this);\n      _this.binaryType = defaultBinaryType;\n      _this.writeBuffer = [];\n      if (uri && \"object\" === _typeof(uri)) {\n        opts = uri;\n        uri = null;\n      }\n      if (uri) {\n        uri = parse(uri);\n        opts.hostname = uri.host;\n        opts.secure = uri.protocol === \"https\" || uri.protocol === \"wss\";\n        opts.port = uri.port;\n        if (uri.query) opts.query = uri.query;\n      } else if (opts.host) {\n        opts.hostname = parse(opts.host).host;\n      }\n      installTimerFunctions(_assertThisInitialized(_this), opts);\n      _this.secure = null != opts.secure ? opts.secure : typeof location !== \"undefined\" && \"https:\" === location.protocol;\n      if (opts.hostname && !opts.port) {\n        // if no port is specified manually, use the protocol default\n        opts.port = _this.secure ? \"443\" : \"80\";\n      }\n      _this.hostname = opts.hostname || (typeof location !== \"undefined\" ? location.hostname : \"localhost\");\n      _this.port = opts.port || (typeof location !== \"undefined\" && location.port ? location.port : _this.secure ? \"443\" : \"80\");\n      _this.transports = opts.transports || [\"polling\", \"websocket\", \"webtransport\"];\n      _this.writeBuffer = [];\n      _this.prevBufferLen = 0;\n      _this.opts = _extends({\n        path: \"/engine.io\",\n        agent: false,\n        withCredentials: false,\n        upgrade: true,\n        timestampParam: \"t\",\n        rememberUpgrade: false,\n        addTrailingSlash: true,\n        rejectUnauthorized: true,\n        perMessageDeflate: {\n          threshold: 1024\n        },\n        transportOptions: {},\n        closeOnBeforeunload: false\n      }, opts);\n      _this.opts.path = _this.opts.path.replace(/\\/$/, \"\") + (_this.opts.addTrailingSlash ? \"/\" : \"\");\n      if (typeof _this.opts.query === \"string\") {\n        _this.opts.query = decode(_this.opts.query);\n      }\n      // set on handshake\n      _this.id = null;\n      _this.upgrades = null;\n      _this.pingInterval = null;\n      _this.pingTimeout = null;\n      // set on heartbeat\n      _this.pingTimeoutTimer = null;\n      if (typeof addEventListener === \"function\") {\n        if (_this.opts.closeOnBeforeunload) {\n          // Firefox closes the connection when the \"beforeunload\" event is emitted but not Chrome. This event listener\n          // ensures every browser behaves the same (no \"disconnect\" event at the Socket.IO level when the page is\n          // closed/reloaded)\n          _this.beforeunloadEventListener = function () {\n            if (_this.transport) {\n              // silently close the transport\n              _this.transport.removeAllListeners();\n              _this.transport.close();\n            }\n          };\n          addEventListener(\"beforeunload\", _this.beforeunloadEventListener, false);\n        }\n        if (_this.hostname !== \"localhost\") {\n          _this.offlineEventListener = function () {\n            _this.onClose(\"transport close\", {\n              description: \"network connection lost\"\n            });\n          };\n          addEventListener(\"offline\", _this.offlineEventListener, false);\n        }\n      }\n      _this.open();\n      return _this;\n    }\n    /**\n     * Creates transport of the given type.\n     *\n     * @param {String} name - transport name\n     * @return {Transport}\n     * @private\n     */\n    _createClass(Socket, [{\n      key: \"createTransport\",\n      value: function createTransport(name) {\n        var query = _extends({}, this.opts.query);\n        // append engine.io protocol identifier\n        query.EIO = protocol$1;\n        // transport name\n        query.transport = name;\n        // session id if we already have one\n        if (this.id) query.sid = this.id;\n        var opts = _extends({}, this.opts, {\n          query: query,\n          socket: this,\n          hostname: this.hostname,\n          secure: this.secure,\n          port: this.port\n        }, this.opts.transportOptions[name]);\n        return new transports[name](opts);\n      }\n      /**\n       * Initializes transport to use and starts probe.\n       *\n       * @private\n       */\n    }, {\n      key: \"open\",\n      value: function open() {\n        var _this2 = this;\n        var transport;\n        if (this.opts.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf(\"websocket\") !== -1) {\n          transport = \"websocket\";\n        } else if (0 === this.transports.length) {\n          // Emit error on next tick so it can be listened to\n          this.setTimeoutFn(function () {\n            _this2.emitReserved(\"error\", \"No transports available\");\n          }, 0);\n          return;\n        } else {\n          transport = this.transports[0];\n        }\n        this.readyState = \"opening\";\n        // Retry with the next transport if the transport is disabled (jsonp: false)\n        try {\n          transport = this.createTransport(transport);\n        } catch (e) {\n          this.transports.shift();\n          this.open();\n          return;\n        }\n        transport.open();\n        this.setTransport(transport);\n      }\n      /**\n       * Sets the current transport. Disables the existing one (if any).\n       *\n       * @private\n       */\n    }, {\n      key: \"setTransport\",\n      value: function setTransport(transport) {\n        var _this3 = this;\n        if (this.transport) {\n          this.transport.removeAllListeners();\n        }\n        // set up transport\n        this.transport = transport;\n        // set up transport listeners\n        transport.on(\"drain\", this.onDrain.bind(this)).on(\"packet\", this.onPacket.bind(this)).on(\"error\", this.onError.bind(this)).on(\"close\", function (reason) {\n          return _this3.onClose(\"transport close\", reason);\n        });\n      }\n      /**\n       * Probes a transport.\n       *\n       * @param {String} name - transport name\n       * @private\n       */\n    }, {\n      key: \"probe\",\n      value: function probe(name) {\n        var _this4 = this;\n        var transport = this.createTransport(name);\n        var failed = false;\n        Socket.priorWebsocketSuccess = false;\n        var onTransportOpen = function onTransportOpen() {\n          if (failed) return;\n          transport.send([{\n            type: \"ping\",\n            data: \"probe\"\n          }]);\n          transport.once(\"packet\", function (msg) {\n            if (failed) return;\n            if (\"pong\" === msg.type && \"probe\" === msg.data) {\n              _this4.upgrading = true;\n              _this4.emitReserved(\"upgrading\", transport);\n              if (!transport) return;\n              Socket.priorWebsocketSuccess = \"websocket\" === transport.name;\n              _this4.transport.pause(function () {\n                if (failed) return;\n                if (\"closed\" === _this4.readyState) return;\n                cleanup();\n                _this4.setTransport(transport);\n                transport.send([{\n                  type: \"upgrade\"\n                }]);\n                _this4.emitReserved(\"upgrade\", transport);\n                transport = null;\n                _this4.upgrading = false;\n                _this4.flush();\n              });\n            } else {\n              var err = new Error(\"probe error\");\n              // @ts-ignore\n              err.transport = transport.name;\n              _this4.emitReserved(\"upgradeError\", err);\n            }\n          });\n        };\n        function freezeTransport() {\n          if (failed) return;\n          // Any callback called by transport should be ignored since now\n          failed = true;\n          cleanup();\n          transport.close();\n          transport = null;\n        }\n        // Handle any error that happens while probing\n        var onerror = function onerror(err) {\n          var error = new Error(\"probe error: \" + err);\n          // @ts-ignore\n          error.transport = transport.name;\n          freezeTransport();\n          _this4.emitReserved(\"upgradeError\", error);\n        };\n        function onTransportClose() {\n          onerror(\"transport closed\");\n        }\n        // When the socket is closed while we're probing\n        function onclose() {\n          onerror(\"socket closed\");\n        }\n        // When the socket is upgraded while we're probing\n        function onupgrade(to) {\n          if (transport && to.name !== transport.name) {\n            freezeTransport();\n          }\n        }\n        // Remove all listeners on the transport and on self\n        var cleanup = function cleanup() {\n          transport.removeListener(\"open\", onTransportOpen);\n          transport.removeListener(\"error\", onerror);\n          transport.removeListener(\"close\", onTransportClose);\n          _this4.off(\"close\", onclose);\n          _this4.off(\"upgrading\", onupgrade);\n        };\n        transport.once(\"open\", onTransportOpen);\n        transport.once(\"error\", onerror);\n        transport.once(\"close\", onTransportClose);\n        this.once(\"close\", onclose);\n        this.once(\"upgrading\", onupgrade);\n        if (this.upgrades.indexOf(\"webtransport\") !== -1 && name !== \"webtransport\") {\n          // favor WebTransport\n          this.setTimeoutFn(function () {\n            if (!failed) {\n              transport.open();\n            }\n          }, 200);\n        } else {\n          transport.open();\n        }\n      }\n      /**\n       * Called when connection is deemed open.\n       *\n       * @private\n       */\n    }, {\n      key: \"onOpen\",\n      value: function onOpen() {\n        this.readyState = \"open\";\n        Socket.priorWebsocketSuccess = \"websocket\" === this.transport.name;\n        this.emitReserved(\"open\");\n        this.flush();\n        // we check for `readyState` in case an `open`\n        // listener already closed the socket\n        if (\"open\" === this.readyState && this.opts.upgrade) {\n          var i = 0;\n          var l = this.upgrades.length;\n          for (; i < l; i++) {\n            this.probe(this.upgrades[i]);\n          }\n        }\n      }\n      /**\n       * Handles a packet.\n       *\n       * @private\n       */\n    }, {\n      key: \"onPacket\",\n      value: function onPacket(packet) {\n        if (\"opening\" === this.readyState || \"open\" === this.readyState || \"closing\" === this.readyState) {\n          this.emitReserved(\"packet\", packet);\n          // Socket is live - any packet counts\n          this.emitReserved(\"heartbeat\");\n          this.resetPingTimeout();\n          switch (packet.type) {\n            case \"open\":\n              this.onHandshake(JSON.parse(packet.data));\n              break;\n            case \"ping\":\n              this.sendPacket(\"pong\");\n              this.emitReserved(\"ping\");\n              this.emitReserved(\"pong\");\n              break;\n            case \"error\":\n              var err = new Error(\"server error\");\n              // @ts-ignore\n              err.code = packet.data;\n              this.onError(err);\n              break;\n            case \"message\":\n              this.emitReserved(\"data\", packet.data);\n              this.emitReserved(\"message\", packet.data);\n              break;\n          }\n        }\n      }\n      /**\n       * Called upon handshake completion.\n       *\n       * @param {Object} data - handshake obj\n       * @private\n       */\n    }, {\n      key: \"onHandshake\",\n      value: function onHandshake(data) {\n        this.emitReserved(\"handshake\", data);\n        this.id = data.sid;\n        this.transport.query.sid = data.sid;\n        this.upgrades = this.filterUpgrades(data.upgrades);\n        this.pingInterval = data.pingInterval;\n        this.pingTimeout = data.pingTimeout;\n        this.maxPayload = data.maxPayload;\n        this.onOpen();\n        // In case open handler closes socket\n        if (\"closed\" === this.readyState) return;\n        this.resetPingTimeout();\n      }\n      /**\n       * Sets and resets ping timeout timer based on server pings.\n       *\n       * @private\n       */\n    }, {\n      key: \"resetPingTimeout\",\n      value: function resetPingTimeout() {\n        var _this5 = this;\n        this.clearTimeoutFn(this.pingTimeoutTimer);\n        this.pingTimeoutTimer = this.setTimeoutFn(function () {\n          _this5.onClose(\"ping timeout\");\n        }, this.pingInterval + this.pingTimeout);\n        if (this.opts.autoUnref) {\n          this.pingTimeoutTimer.unref();\n        }\n      }\n      /**\n       * Called on `drain` event\n       *\n       * @private\n       */\n    }, {\n      key: \"onDrain\",\n      value: function onDrain() {\n        this.writeBuffer.splice(0, this.prevBufferLen);\n        // setting prevBufferLen = 0 is very important\n        // for example, when upgrading, upgrade packet is sent over,\n        // and a nonzero prevBufferLen could cause problems on `drain`\n        this.prevBufferLen = 0;\n        if (0 === this.writeBuffer.length) {\n          this.emitReserved(\"drain\");\n        } else {\n          this.flush();\n        }\n      }\n      /**\n       * Flush write buffers.\n       *\n       * @private\n       */\n    }, {\n      key: \"flush\",\n      value: function flush() {\n        if (\"closed\" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {\n          var packets = this.getWritablePackets();\n          this.transport.send(packets);\n          // keep track of current length of writeBuffer\n          // splice writeBuffer and callbackBuffer on `drain`\n          this.prevBufferLen = packets.length;\n          this.emitReserved(\"flush\");\n        }\n      }\n      /**\n       * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP\n       * long-polling)\n       *\n       * @private\n       */\n    }, {\n      key: \"getWritablePackets\",\n      value: function getWritablePackets() {\n        var shouldCheckPayloadSize = this.maxPayload && this.transport.name === \"polling\" && this.writeBuffer.length > 1;\n        if (!shouldCheckPayloadSize) {\n          return this.writeBuffer;\n        }\n        var payloadSize = 1; // first packet type\n        for (var i = 0; i < this.writeBuffer.length; i++) {\n          var data = this.writeBuffer[i].data;\n          if (data) {\n            payloadSize += byteLength(data);\n          }\n          if (i > 0 && payloadSize > this.maxPayload) {\n            return this.writeBuffer.slice(0, i);\n          }\n          payloadSize += 2; // separator + packet type\n        }\n\n        return this.writeBuffer;\n      }\n      /**\n       * Sends a message.\n       *\n       * @param {String} msg - message.\n       * @param {Object} options.\n       * @param {Function} callback function.\n       * @return {Socket} for chaining.\n       */\n    }, {\n      key: \"write\",\n      value: function write(msg, options, fn) {\n        this.sendPacket(\"message\", msg, options, fn);\n        return this;\n      }\n    }, {\n      key: \"send\",\n      value: function send(msg, options, fn) {\n        this.sendPacket(\"message\", msg, options, fn);\n        return this;\n      }\n      /**\n       * Sends a packet.\n       *\n       * @param {String} type: packet type.\n       * @param {String} data.\n       * @param {Object} options.\n       * @param {Function} fn - callback function.\n       * @private\n       */\n    }, {\n      key: \"sendPacket\",\n      value: function sendPacket(type, data, options, fn) {\n        if (\"function\" === typeof data) {\n          fn = data;\n          data = undefined;\n        }\n        if (\"function\" === typeof options) {\n          fn = options;\n          options = null;\n        }\n        if (\"closing\" === this.readyState || \"closed\" === this.readyState) {\n          return;\n        }\n        options = options || {};\n        options.compress = false !== options.compress;\n        var packet = {\n          type: type,\n          data: data,\n          options: options\n        };\n        this.emitReserved(\"packetCreate\", packet);\n        this.writeBuffer.push(packet);\n        if (fn) this.once(\"flush\", fn);\n        this.flush();\n      }\n      /**\n       * Closes the connection.\n       */\n    }, {\n      key: \"close\",\n      value: function close() {\n        var _this6 = this;\n        var close = function close() {\n          _this6.onClose(\"forced close\");\n          _this6.transport.close();\n        };\n        var cleanupAndClose = function cleanupAndClose() {\n          _this6.off(\"upgrade\", cleanupAndClose);\n          _this6.off(\"upgradeError\", cleanupAndClose);\n          close();\n        };\n        var waitForUpgrade = function waitForUpgrade() {\n          // wait for upgrade to finish since we can't send packets while pausing a transport\n          _this6.once(\"upgrade\", cleanupAndClose);\n          _this6.once(\"upgradeError\", cleanupAndClose);\n        };\n        if (\"opening\" === this.readyState || \"open\" === this.readyState) {\n          this.readyState = \"closing\";\n          if (this.writeBuffer.length) {\n            this.once(\"drain\", function () {\n              if (_this6.upgrading) {\n                waitForUpgrade();\n              } else {\n                close();\n              }\n            });\n          } else if (this.upgrading) {\n            waitForUpgrade();\n          } else {\n            close();\n          }\n        }\n        return this;\n      }\n      /**\n       * Called upon transport error\n       *\n       * @private\n       */\n    }, {\n      key: \"onError\",\n      value: function onError(err) {\n        Socket.priorWebsocketSuccess = false;\n        this.emitReserved(\"error\", err);\n        this.onClose(\"transport error\", err);\n      }\n      /**\n       * Called upon transport close.\n       *\n       * @private\n       */\n    }, {\n      key: \"onClose\",\n      value: function onClose(reason, description) {\n        if (\"opening\" === this.readyState || \"open\" === this.readyState || \"closing\" === this.readyState) {\n          // clear timers\n          this.clearTimeoutFn(this.pingTimeoutTimer);\n          // stop event from firing again for transport\n          this.transport.removeAllListeners(\"close\");\n          // ensure transport won't stay open\n          this.transport.close();\n          // ignore further transport communication\n          this.transport.removeAllListeners();\n          if (typeof removeEventListener === \"function\") {\n            removeEventListener(\"beforeunload\", this.beforeunloadEventListener, false);\n            removeEventListener(\"offline\", this.offlineEventListener, false);\n          }\n          // set ready state\n          this.readyState = \"closed\";\n          // clear session id\n          this.id = null;\n          // emit close event\n          this.emitReserved(\"close\", reason, description);\n          // clean buffers after, so users can still\n          // grab the buffers on `close` event\n          this.writeBuffer = [];\n          this.prevBufferLen = 0;\n        }\n      }\n      /**\n       * Filters upgrades, returning only those matching client transports.\n       *\n       * @param {Array} upgrades - server upgrades\n       * @private\n       */\n    }, {\n      key: \"filterUpgrades\",\n      value: function filterUpgrades(upgrades) {\n        var filteredUpgrades = [];\n        var i = 0;\n        var j = upgrades.length;\n        for (; i < j; i++) {\n          if (~this.transports.indexOf(upgrades[i])) filteredUpgrades.push(upgrades[i]);\n        }\n        return filteredUpgrades;\n      }\n    }]);\n    return Socket;\n  }(Emitter);\n  Socket$1.protocol = protocol$1;\n\n  Socket$1.protocol;\n\n  /**\n   * URL parser.\n   *\n   * @param uri - url\n   * @param path - the request path of the connection\n   * @param loc - An object meant to mimic window.location.\n   *        Defaults to window.location.\n   * @public\n   */\n  function url(uri) {\n    var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    var loc = arguments.length > 2 ? arguments[2] : undefined;\n    var obj = uri;\n    // default to window.location\n    loc = loc || typeof location !== \"undefined\" && location;\n    if (null == uri) uri = loc.protocol + \"//\" + loc.host;\n    // relative path support\n    if (typeof uri === \"string\") {\n      if (\"/\" === uri.charAt(0)) {\n        if (\"/\" === uri.charAt(1)) {\n          uri = loc.protocol + uri;\n        } else {\n          uri = loc.host + uri;\n        }\n      }\n      if (!/^(https?|wss?):\\/\\//.test(uri)) {\n        if (\"undefined\" !== typeof loc) {\n          uri = loc.protocol + \"//\" + uri;\n        } else {\n          uri = \"https://\" + uri;\n        }\n      }\n      // parse\n      obj = parse(uri);\n    }\n    // make sure we treat `localhost:80` and `localhost` equally\n    if (!obj.port) {\n      if (/^(http|ws)$/.test(obj.protocol)) {\n        obj.port = \"80\";\n      } else if (/^(http|ws)s$/.test(obj.protocol)) {\n        obj.port = \"443\";\n      }\n    }\n    obj.path = obj.path || \"/\";\n    var ipv6 = obj.host.indexOf(\":\") !== -1;\n    var host = ipv6 ? \"[\" + obj.host + \"]\" : obj.host;\n    // define unique id\n    obj.id = obj.protocol + \"://\" + host + \":\" + obj.port + path;\n    // define href\n    obj.href = obj.protocol + \"://\" + host + (loc && loc.port === obj.port ? \"\" : \":\" + obj.port);\n    return obj;\n  }\n\n  var withNativeArrayBuffer = typeof ArrayBuffer === \"function\";\n  var isView = function isView(obj) {\n    return typeof ArrayBuffer.isView === \"function\" ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;\n  };\n  var toString = Object.prototype.toString;\n  var withNativeBlob = typeof Blob === \"function\" || typeof Blob !== \"undefined\" && toString.call(Blob) === \"[object BlobConstructor]\";\n  var withNativeFile = typeof File === \"function\" || typeof File !== \"undefined\" && toString.call(File) === \"[object FileConstructor]\";\n  /**\n   * Returns true if obj is a Buffer, an ArrayBuffer, a Blob or a File.\n   *\n   * @private\n   */\n  function isBinary(obj) {\n    return withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj)) || withNativeBlob && obj instanceof Blob || withNativeFile && obj instanceof File;\n  }\n  function hasBinary(obj, toJSON) {\n    if (!obj || _typeof(obj) !== \"object\") {\n      return false;\n    }\n    if (Array.isArray(obj)) {\n      for (var i = 0, l = obj.length; i < l; i++) {\n        if (hasBinary(obj[i])) {\n          return true;\n        }\n      }\n      return false;\n    }\n    if (isBinary(obj)) {\n      return true;\n    }\n    if (obj.toJSON && typeof obj.toJSON === \"function\" && arguments.length === 1) {\n      return hasBinary(obj.toJSON(), true);\n    }\n    for (var key in obj) {\n      if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Replaces every Buffer | ArrayBuffer | Blob | File in packet with a numbered placeholder.\n   *\n   * @param {Object} packet - socket.io event packet\n   * @return {Object} with deconstructed packet and list of buffers\n   * @public\n   */\n  function deconstructPacket(packet) {\n    var buffers = [];\n    var packetData = packet.data;\n    var pack = packet;\n    pack.data = _deconstructPacket(packetData, buffers);\n    pack.attachments = buffers.length; // number of binary 'attachments'\n    return {\n      packet: pack,\n      buffers: buffers\n    };\n  }\n  function _deconstructPacket(data, buffers) {\n    if (!data) return data;\n    if (isBinary(data)) {\n      var placeholder = {\n        _placeholder: true,\n        num: buffers.length\n      };\n      buffers.push(data);\n      return placeholder;\n    } else if (Array.isArray(data)) {\n      var newData = new Array(data.length);\n      for (var i = 0; i < data.length; i++) {\n        newData[i] = _deconstructPacket(data[i], buffers);\n      }\n      return newData;\n    } else if (_typeof(data) === \"object\" && !(data instanceof Date)) {\n      var _newData = {};\n      for (var key in data) {\n        if (Object.prototype.hasOwnProperty.call(data, key)) {\n          _newData[key] = _deconstructPacket(data[key], buffers);\n        }\n      }\n      return _newData;\n    }\n    return data;\n  }\n  /**\n   * Reconstructs a binary packet from its placeholder packet and buffers\n   *\n   * @param {Object} packet - event packet with placeholders\n   * @param {Array} buffers - binary buffers to put in placeholder positions\n   * @return {Object} reconstructed packet\n   * @public\n   */\n  function reconstructPacket(packet, buffers) {\n    packet.data = _reconstructPacket(packet.data, buffers);\n    delete packet.attachments; // no longer useful\n    return packet;\n  }\n  function _reconstructPacket(data, buffers) {\n    if (!data) return data;\n    if (data && data._placeholder === true) {\n      var isIndexValid = typeof data.num === \"number\" && data.num >= 0 && data.num < buffers.length;\n      if (isIndexValid) {\n        return buffers[data.num]; // appropriate buffer (should be natural order anyway)\n      } else {\n        throw new Error(\"illegal attachments\");\n      }\n    } else if (Array.isArray(data)) {\n      for (var i = 0; i < data.length; i++) {\n        data[i] = _reconstructPacket(data[i], buffers);\n      }\n    } else if (_typeof(data) === \"object\") {\n      for (var key in data) {\n        if (Object.prototype.hasOwnProperty.call(data, key)) {\n          data[key] = _reconstructPacket(data[key], buffers);\n        }\n      }\n    }\n    return data;\n  }\n\n  /**\n   * These strings must not be used as event names, as they have a special meaning.\n   */\n  var RESERVED_EVENTS$1 = [\"connect\", \"connect_error\", \"disconnect\", \"disconnecting\", \"newListener\", \"removeListener\" // used by the Node.js EventEmitter\n  ];\n  /**\n   * Protocol version.\n   *\n   * @public\n   */\n  var protocol = 5;\n  var PacketType;\n  (function (PacketType) {\n    PacketType[PacketType[\"CONNECT\"] = 0] = \"CONNECT\";\n    PacketType[PacketType[\"DISCONNECT\"] = 1] = \"DISCONNECT\";\n    PacketType[PacketType[\"EVENT\"] = 2] = \"EVENT\";\n    PacketType[PacketType[\"ACK\"] = 3] = \"ACK\";\n    PacketType[PacketType[\"CONNECT_ERROR\"] = 4] = \"CONNECT_ERROR\";\n    PacketType[PacketType[\"BINARY_EVENT\"] = 5] = \"BINARY_EVENT\";\n    PacketType[PacketType[\"BINARY_ACK\"] = 6] = \"BINARY_ACK\";\n  })(PacketType || (PacketType = {}));\n  /**\n   * A socket.io Encoder instance\n   */\n  var Encoder = /*#__PURE__*/function () {\n    /**\n     * Encoder constructor\n     *\n     * @param {function} replacer - custom replacer to pass down to JSON.parse\n     */\n    function Encoder(replacer) {\n      _classCallCheck(this, Encoder);\n      this.replacer = replacer;\n    }\n    /**\n     * Encode a packet as a single string if non-binary, or as a\n     * buffer sequence, depending on packet type.\n     *\n     * @param {Object} obj - packet object\n     */\n    _createClass(Encoder, [{\n      key: \"encode\",\n      value: function encode(obj) {\n        if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {\n          if (hasBinary(obj)) {\n            return this.encodeAsBinary({\n              type: obj.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK,\n              nsp: obj.nsp,\n              data: obj.data,\n              id: obj.id\n            });\n          }\n        }\n        return [this.encodeAsString(obj)];\n      }\n      /**\n       * Encode packet as string.\n       */\n    }, {\n      key: \"encodeAsString\",\n      value: function encodeAsString(obj) {\n        // first is type\n        var str = \"\" + obj.type;\n        // attachments if we have them\n        if (obj.type === PacketType.BINARY_EVENT || obj.type === PacketType.BINARY_ACK) {\n          str += obj.attachments + \"-\";\n        }\n        // if we have a namespace other than `/`\n        // we append it followed by a comma `,`\n        if (obj.nsp && \"/\" !== obj.nsp) {\n          str += obj.nsp + \",\";\n        }\n        // immediately followed by the id\n        if (null != obj.id) {\n          str += obj.id;\n        }\n        // json data\n        if (null != obj.data) {\n          str += JSON.stringify(obj.data, this.replacer);\n        }\n        return str;\n      }\n      /**\n       * Encode packet as 'buffer sequence' by removing blobs, and\n       * deconstructing packet into object with placeholders and\n       * a list of buffers.\n       */\n    }, {\n      key: \"encodeAsBinary\",\n      value: function encodeAsBinary(obj) {\n        var deconstruction = deconstructPacket(obj);\n        var pack = this.encodeAsString(deconstruction.packet);\n        var buffers = deconstruction.buffers;\n        buffers.unshift(pack); // add packet info to beginning of data list\n        return buffers; // write all the buffers\n      }\n    }]);\n    return Encoder;\n  }();\n  // see https://stackoverflow.com/questions/8511281/check-if-a-value-is-an-object-in-javascript\n  function isObject(value) {\n    return Object.prototype.toString.call(value) === \"[object Object]\";\n  }\n  /**\n   * A socket.io Decoder instance\n   *\n   * @return {Object} decoder\n   */\n  var Decoder = /*#__PURE__*/function (_Emitter) {\n    _inherits(Decoder, _Emitter);\n    var _super = _createSuper(Decoder);\n    /**\n     * Decoder constructor\n     *\n     * @param {function} reviver - custom reviver to pass down to JSON.stringify\n     */\n    function Decoder(reviver) {\n      var _this;\n      _classCallCheck(this, Decoder);\n      _this = _super.call(this);\n      _this.reviver = reviver;\n      return _this;\n    }\n    /**\n     * Decodes an encoded packet string into packet JSON.\n     *\n     * @param {String} obj - encoded packet\n     */\n    _createClass(Decoder, [{\n      key: \"add\",\n      value: function add(obj) {\n        var packet;\n        if (typeof obj === \"string\") {\n          if (this.reconstructor) {\n            throw new Error(\"got plaintext data when reconstructing a packet\");\n          }\n          packet = this.decodeString(obj);\n          var isBinaryEvent = packet.type === PacketType.BINARY_EVENT;\n          if (isBinaryEvent || packet.type === PacketType.BINARY_ACK) {\n            packet.type = isBinaryEvent ? PacketType.EVENT : PacketType.ACK;\n            // binary packet's json\n            this.reconstructor = new BinaryReconstructor(packet);\n            // no attachments, labeled binary but no binary data to follow\n            if (packet.attachments === 0) {\n              _get(_getPrototypeOf(Decoder.prototype), \"emitReserved\", this).call(this, \"decoded\", packet);\n            }\n          } else {\n            // non-binary full packet\n            _get(_getPrototypeOf(Decoder.prototype), \"emitReserved\", this).call(this, \"decoded\", packet);\n          }\n        } else if (isBinary(obj) || obj.base64) {\n          // raw binary data\n          if (!this.reconstructor) {\n            throw new Error(\"got binary data when not reconstructing a packet\");\n          } else {\n            packet = this.reconstructor.takeBinaryData(obj);\n            if (packet) {\n              // received final buffer\n              this.reconstructor = null;\n              _get(_getPrototypeOf(Decoder.prototype), \"emitReserved\", this).call(this, \"decoded\", packet);\n            }\n          }\n        } else {\n          throw new Error(\"Unknown type: \" + obj);\n        }\n      }\n      /**\n       * Decode a packet String (JSON data)\n       *\n       * @param {String} str\n       * @return {Object} packet\n       */\n    }, {\n      key: \"decodeString\",\n      value: function decodeString(str) {\n        var i = 0;\n        // look up type\n        var p = {\n          type: Number(str.charAt(0))\n        };\n        if (PacketType[p.type] === undefined) {\n          throw new Error(\"unknown packet type \" + p.type);\n        }\n        // look up attachments if type binary\n        if (p.type === PacketType.BINARY_EVENT || p.type === PacketType.BINARY_ACK) {\n          var start = i + 1;\n          while (str.charAt(++i) !== \"-\" && i != str.length) {}\n          var buf = str.substring(start, i);\n          if (buf != Number(buf) || str.charAt(i) !== \"-\") {\n            throw new Error(\"Illegal attachments\");\n          }\n          p.attachments = Number(buf);\n        }\n        // look up namespace (if any)\n        if (\"/\" === str.charAt(i + 1)) {\n          var _start = i + 1;\n          while (++i) {\n            var c = str.charAt(i);\n            if (\",\" === c) break;\n            if (i === str.length) break;\n          }\n          p.nsp = str.substring(_start, i);\n        } else {\n          p.nsp = \"/\";\n        }\n        // look up id\n        var next = str.charAt(i + 1);\n        if (\"\" !== next && Number(next) == next) {\n          var _start2 = i + 1;\n          while (++i) {\n            var _c = str.charAt(i);\n            if (null == _c || Number(_c) != _c) {\n              --i;\n              break;\n            }\n            if (i === str.length) break;\n          }\n          p.id = Number(str.substring(_start2, i + 1));\n        }\n        // look up json data\n        if (str.charAt(++i)) {\n          var payload = this.tryParse(str.substr(i));\n          if (Decoder.isPayloadValid(p.type, payload)) {\n            p.data = payload;\n          } else {\n            throw new Error(\"invalid payload\");\n          }\n        }\n        return p;\n      }\n    }, {\n      key: \"tryParse\",\n      value: function tryParse(str) {\n        try {\n          return JSON.parse(str, this.reviver);\n        } catch (e) {\n          return false;\n        }\n      }\n    }, {\n      key: \"destroy\",\n      value:\n      /**\n       * Deallocates a parser's resources\n       */\n      function destroy() {\n        if (this.reconstructor) {\n          this.reconstructor.finishedReconstruction();\n          this.reconstructor = null;\n        }\n      }\n    }], [{\n      key: \"isPayloadValid\",\n      value: function isPayloadValid(type, payload) {\n        switch (type) {\n          case PacketType.CONNECT:\n            return isObject(payload);\n          case PacketType.DISCONNECT:\n            return payload === undefined;\n          case PacketType.CONNECT_ERROR:\n            return typeof payload === \"string\" || isObject(payload);\n          case PacketType.EVENT:\n          case PacketType.BINARY_EVENT:\n            return Array.isArray(payload) && (typeof payload[0] === \"number\" || typeof payload[0] === \"string\" && RESERVED_EVENTS$1.indexOf(payload[0]) === -1);\n          case PacketType.ACK:\n          case PacketType.BINARY_ACK:\n            return Array.isArray(payload);\n        }\n      }\n    }]);\n    return Decoder;\n  }(Emitter);\n  /**\n   * A manager of a binary event's 'buffer sequence'. Should\n   * be constructed whenever a packet of type BINARY_EVENT is\n   * decoded.\n   *\n   * @param {Object} packet\n   * @return {BinaryReconstructor} initialized reconstructor\n   */\n  var BinaryReconstructor = /*#__PURE__*/function () {\n    function BinaryReconstructor(packet) {\n      _classCallCheck(this, BinaryReconstructor);\n      this.packet = packet;\n      this.buffers = [];\n      this.reconPack = packet;\n    }\n    /**\n     * Method to be called when binary data received from connection\n     * after a BINARY_EVENT packet.\n     *\n     * @param {Buffer | ArrayBuffer} binData - the raw binary data received\n     * @return {null | Object} returns null if more binary data is expected or\n     *   a reconstructed packet object if all buffers have been received.\n     */\n    _createClass(BinaryReconstructor, [{\n      key: \"takeBinaryData\",\n      value: function takeBinaryData(binData) {\n        this.buffers.push(binData);\n        if (this.buffers.length === this.reconPack.attachments) {\n          // done with buffer list\n          var packet = reconstructPacket(this.reconPack, this.buffers);\n          this.finishedReconstruction();\n          return packet;\n        }\n        return null;\n      }\n      /**\n       * Cleans up binary packet reconstruction variables.\n       */\n    }, {\n      key: \"finishedReconstruction\",\n      value: function finishedReconstruction() {\n        this.reconPack = null;\n        this.buffers = [];\n      }\n    }]);\n    return BinaryReconstructor;\n  }();\n\n  var parser = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    protocol: protocol,\n    get PacketType () { return PacketType; },\n    Encoder: Encoder,\n    Decoder: Decoder\n  });\n\n  function on(obj, ev, fn) {\n    obj.on(ev, fn);\n    return function subDestroy() {\n      obj.off(ev, fn);\n    };\n  }\n\n  /**\n   * Internal events.\n   * These events can't be emitted by the user.\n   */\n  var RESERVED_EVENTS = Object.freeze({\n    connect: 1,\n    connect_error: 1,\n    disconnect: 1,\n    disconnecting: 1,\n    // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener\n    newListener: 1,\n    removeListener: 1\n  });\n  /**\n   * A Socket is the fundamental class for interacting with the server.\n   *\n   * A Socket belongs to a certain Namespace (by default /) and uses an underlying {@link Manager} to communicate.\n   *\n   * @example\n   * const socket = io();\n   *\n   * socket.on(\"connect\", () => {\n   *   console.log(\"connected\");\n   * });\n   *\n   * // send an event to the server\n   * socket.emit(\"foo\", \"bar\");\n   *\n   * socket.on(\"foobar\", () => {\n   *   // an event was received from the server\n   * });\n   *\n   * // upon disconnection\n   * socket.on(\"disconnect\", (reason) => {\n   *   console.log(`disconnected due to ${reason}`);\n   * });\n   */\n  var Socket = /*#__PURE__*/function (_Emitter) {\n    _inherits(Socket, _Emitter);\n    var _super = _createSuper(Socket);\n    /**\n     * `Socket` constructor.\n     */\n    function Socket(io, nsp, opts) {\n      var _this;\n      _classCallCheck(this, Socket);\n      _this = _super.call(this);\n      /**\n       * Whether the socket is currently connected to the server.\n       *\n       * @example\n       * const socket = io();\n       *\n       * socket.on(\"connect\", () => {\n       *   console.log(socket.connected); // true\n       * });\n       *\n       * socket.on(\"disconnect\", () => {\n       *   console.log(socket.connected); // false\n       * });\n       */\n      _this.connected = false;\n      /**\n       * Whether the connection state was recovered after a temporary disconnection. In that case, any missed packets will\n       * be transmitted by the server.\n       */\n      _this.recovered = false;\n      /**\n       * Buffer for packets received before the CONNECT packet\n       */\n      _this.receiveBuffer = [];\n      /**\n       * Buffer for packets that will be sent once the socket is connected\n       */\n      _this.sendBuffer = [];\n      /**\n       * The queue of packets to be sent with retry in case of failure.\n       *\n       * Packets are sent one by one, each waiting for the server acknowledgement, in order to guarantee the delivery order.\n       * @private\n       */\n      _this._queue = [];\n      /**\n       * A sequence to generate the ID of the {@link QueuedPacket}.\n       * @private\n       */\n      _this._queueSeq = 0;\n      _this.ids = 0;\n      /**\n       * A map containing acknowledgement handlers.\n       *\n       * The `withError` attribute is used to differentiate handlers that accept an error as first argument:\n       *\n       * - `socket.emit(\"test\", (err, value) => { ... })` with `ackTimeout` option\n       * - `socket.timeout(5000).emit(\"test\", (err, value) => { ... })`\n       * - `const value = await socket.emitWithAck(\"test\")`\n       *\n       * From those that don't:\n       *\n       * - `socket.emit(\"test\", (value) => { ... });`\n       *\n       * In the first case, the handlers will be called with an error when:\n       *\n       * - the timeout is reached\n       * - the socket gets disconnected\n       *\n       * In the second case, the handlers will be simply discarded upon disconnection, since the client will never receive\n       * an acknowledgement from the server.\n       *\n       * @private\n       */\n      _this.acks = {};\n      _this.flags = {};\n      _this.io = io;\n      _this.nsp = nsp;\n      if (opts && opts.auth) {\n        _this.auth = opts.auth;\n      }\n      _this._opts = _extends({}, opts);\n      if (_this.io._autoConnect) _this.open();\n      return _this;\n    }\n    /**\n     * Whether the socket is currently disconnected\n     *\n     * @example\n     * const socket = io();\n     *\n     * socket.on(\"connect\", () => {\n     *   console.log(socket.disconnected); // false\n     * });\n     *\n     * socket.on(\"disconnect\", () => {\n     *   console.log(socket.disconnected); // true\n     * });\n     */\n    _createClass(Socket, [{\n      key: \"disconnected\",\n      get: function get() {\n        return !this.connected;\n      }\n      /**\n       * Subscribe to open, close and packet events\n       *\n       * @private\n       */\n    }, {\n      key: \"subEvents\",\n      value: function subEvents() {\n        if (this.subs) return;\n        var io = this.io;\n        this.subs = [on(io, \"open\", this.onopen.bind(this)), on(io, \"packet\", this.onpacket.bind(this)), on(io, \"error\", this.onerror.bind(this)), on(io, \"close\", this.onclose.bind(this))];\n      }\n      /**\n       * Whether the Socket will try to reconnect when its Manager connects or reconnects.\n       *\n       * @example\n       * const socket = io();\n       *\n       * console.log(socket.active); // true\n       *\n       * socket.on(\"disconnect\", (reason) => {\n       *   if (reason === \"io server disconnect\") {\n       *     // the disconnection was initiated by the server, you need to manually reconnect\n       *     console.log(socket.active); // false\n       *   }\n       *   // else the socket will automatically try to reconnect\n       *   console.log(socket.active); // true\n       * });\n       */\n    }, {\n      key: \"active\",\n      get: function get() {\n        return !!this.subs;\n      }\n      /**\n       * \"Opens\" the socket.\n       *\n       * @example\n       * const socket = io({\n       *   autoConnect: false\n       * });\n       *\n       * socket.connect();\n       */\n    }, {\n      key: \"connect\",\n      value: function connect() {\n        if (this.connected) return this;\n        this.subEvents();\n        if (!this.io[\"_reconnecting\"]) this.io.open(); // ensure open\n        if (\"open\" === this.io._readyState) this.onopen();\n        return this;\n      }\n      /**\n       * Alias for {@link connect()}.\n       */\n    }, {\n      key: \"open\",\n      value: function open() {\n        return this.connect();\n      }\n      /**\n       * Sends a `message` event.\n       *\n       * This method mimics the WebSocket.send() method.\n       *\n       * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send\n       *\n       * @example\n       * socket.send(\"hello\");\n       *\n       * // this is equivalent to\n       * socket.emit(\"message\", \"hello\");\n       *\n       * @return self\n       */\n    }, {\n      key: \"send\",\n      value: function send() {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n        args.unshift(\"message\");\n        this.emit.apply(this, args);\n        return this;\n      }\n      /**\n       * Override `emit`.\n       * If the event is in `events`, it's emitted normally.\n       *\n       * @example\n       * socket.emit(\"hello\", \"world\");\n       *\n       * // all serializable datastructures are supported (no need to call JSON.stringify)\n       * socket.emit(\"hello\", 1, \"2\", { 3: [\"4\"], 5: Uint8Array.from([6]) });\n       *\n       * // with an acknowledgement from the server\n       * socket.emit(\"hello\", \"world\", (val) => {\n       *   // ...\n       * });\n       *\n       * @return self\n       */\n    }, {\n      key: \"emit\",\n      value: function emit(ev) {\n        if (RESERVED_EVENTS.hasOwnProperty(ev)) {\n          throw new Error('\"' + ev.toString() + '\" is a reserved event name');\n        }\n        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n          args[_key2 - 1] = arguments[_key2];\n        }\n        args.unshift(ev);\n        if (this._opts.retries && !this.flags.fromQueue && !this.flags[\"volatile\"]) {\n          this._addToQueue(args);\n          return this;\n        }\n        var packet = {\n          type: PacketType.EVENT,\n          data: args\n        };\n        packet.options = {};\n        packet.options.compress = this.flags.compress !== false;\n        // event ack callback\n        if (\"function\" === typeof args[args.length - 1]) {\n          var id = this.ids++;\n          var ack = args.pop();\n          this._registerAckCallback(id, ack);\n          packet.id = id;\n        }\n        var isTransportWritable = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;\n        var discardPacket = this.flags[\"volatile\"] && (!isTransportWritable || !this.connected);\n        if (discardPacket) ; else if (this.connected) {\n          this.notifyOutgoingListeners(packet);\n          this.packet(packet);\n        } else {\n          this.sendBuffer.push(packet);\n        }\n        this.flags = {};\n        return this;\n      }\n      /**\n       * @private\n       */\n    }, {\n      key: \"_registerAckCallback\",\n      value: function _registerAckCallback(id, ack) {\n        var _this2 = this;\n        var _a;\n        var timeout = (_a = this.flags.timeout) !== null && _a !== void 0 ? _a : this._opts.ackTimeout;\n        if (timeout === undefined) {\n          this.acks[id] = ack;\n          return;\n        }\n        // @ts-ignore\n        var timer = this.io.setTimeoutFn(function () {\n          delete _this2.acks[id];\n          for (var i = 0; i < _this2.sendBuffer.length; i++) {\n            if (_this2.sendBuffer[i].id === id) {\n              _this2.sendBuffer.splice(i, 1);\n            }\n          }\n          ack.call(_this2, new Error(\"operation has timed out\"));\n        }, timeout);\n        var fn = function fn() {\n          // @ts-ignore\n          _this2.io.clearTimeoutFn(timer);\n          for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n            args[_key3] = arguments[_key3];\n          }\n          ack.apply(_this2, args);\n        };\n        fn.withError = true;\n        this.acks[id] = fn;\n      }\n      /**\n       * Emits an event and waits for an acknowledgement\n       *\n       * @example\n       * // without timeout\n       * const response = await socket.emitWithAck(\"hello\", \"world\");\n       *\n       * // with a specific timeout\n       * try {\n       *   const response = await socket.timeout(1000).emitWithAck(\"hello\", \"world\");\n       * } catch (err) {\n       *   // the server did not acknowledge the event in the given delay\n       * }\n       *\n       * @return a Promise that will be fulfilled when the server acknowledges the event\n       */\n    }, {\n      key: \"emitWithAck\",\n      value: function emitWithAck(ev) {\n        var _this3 = this;\n        for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n          args[_key4 - 1] = arguments[_key4];\n        }\n        return new Promise(function (resolve, reject) {\n          var fn = function fn(arg1, arg2) {\n            return arg1 ? reject(arg1) : resolve(arg2);\n          };\n          fn.withError = true;\n          args.push(fn);\n          _this3.emit.apply(_this3, [ev].concat(args));\n        });\n      }\n      /**\n       * Add the packet to the queue.\n       * @param args\n       * @private\n       */\n    }, {\n      key: \"_addToQueue\",\n      value: function _addToQueue(args) {\n        var _this4 = this;\n        var ack;\n        if (typeof args[args.length - 1] === \"function\") {\n          ack = args.pop();\n        }\n        var packet = {\n          id: this._queueSeq++,\n          tryCount: 0,\n          pending: false,\n          args: args,\n          flags: _extends({\n            fromQueue: true\n          }, this.flags)\n        };\n        args.push(function (err) {\n          if (packet !== _this4._queue[0]) {\n            // the packet has already been acknowledged\n            return;\n          }\n          var hasError = err !== null;\n          if (hasError) {\n            if (packet.tryCount > _this4._opts.retries) {\n              _this4._queue.shift();\n              if (ack) {\n                ack(err);\n              }\n            }\n          } else {\n            _this4._queue.shift();\n            if (ack) {\n              for (var _len5 = arguments.length, responseArgs = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n                responseArgs[_key5 - 1] = arguments[_key5];\n              }\n              ack.apply(void 0, [null].concat(responseArgs));\n            }\n          }\n          packet.pending = false;\n          return _this4._drainQueue();\n        });\n        this._queue.push(packet);\n        this._drainQueue();\n      }\n      /**\n       * Send the first packet of the queue, and wait for an acknowledgement from the server.\n       * @param force - whether to resend a packet that has not been acknowledged yet\n       *\n       * @private\n       */\n    }, {\n      key: \"_drainQueue\",\n      value: function _drainQueue() {\n        var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n        if (!this.connected || this._queue.length === 0) {\n          return;\n        }\n        var packet = this._queue[0];\n        if (packet.pending && !force) {\n          return;\n        }\n        packet.pending = true;\n        packet.tryCount++;\n        this.flags = packet.flags;\n        this.emit.apply(this, packet.args);\n      }\n      /**\n       * Sends a packet.\n       *\n       * @param packet\n       * @private\n       */\n    }, {\n      key: \"packet\",\n      value: function packet(_packet) {\n        _packet.nsp = this.nsp;\n        this.io._packet(_packet);\n      }\n      /**\n       * Called upon engine `open`.\n       *\n       * @private\n       */\n    }, {\n      key: \"onopen\",\n      value: function onopen() {\n        var _this5 = this;\n        if (typeof this.auth == \"function\") {\n          this.auth(function (data) {\n            _this5._sendConnectPacket(data);\n          });\n        } else {\n          this._sendConnectPacket(this.auth);\n        }\n      }\n      /**\n       * Sends a CONNECT packet to initiate the Socket.IO session.\n       *\n       * @param data\n       * @private\n       */\n    }, {\n      key: \"_sendConnectPacket\",\n      value: function _sendConnectPacket(data) {\n        this.packet({\n          type: PacketType.CONNECT,\n          data: this._pid ? _extends({\n            pid: this._pid,\n            offset: this._lastOffset\n          }, data) : data\n        });\n      }\n      /**\n       * Called upon engine or manager `error`.\n       *\n       * @param err\n       * @private\n       */\n    }, {\n      key: \"onerror\",\n      value: function onerror(err) {\n        if (!this.connected) {\n          this.emitReserved(\"connect_error\", err);\n        }\n      }\n      /**\n       * Called upon engine `close`.\n       *\n       * @param reason\n       * @param description\n       * @private\n       */\n    }, {\n      key: \"onclose\",\n      value: function onclose(reason, description) {\n        this.connected = false;\n        delete this.id;\n        this.emitReserved(\"disconnect\", reason, description);\n        this._clearAcks();\n      }\n      /**\n       * Clears the acknowledgement handlers upon disconnection, since the client will never receive an acknowledgement from\n       * the server.\n       *\n       * @private\n       */\n    }, {\n      key: \"_clearAcks\",\n      value: function _clearAcks() {\n        var _this6 = this;\n        Object.keys(this.acks).forEach(function (id) {\n          var isBuffered = _this6.sendBuffer.some(function (packet) {\n            return String(packet.id) === id;\n          });\n          if (!isBuffered) {\n            // note: handlers that do not accept an error as first argument are ignored here\n            var ack = _this6.acks[id];\n            delete _this6.acks[id];\n            if (ack.withError) {\n              ack.call(_this6, new Error(\"socket has been disconnected\"));\n            }\n          }\n        });\n      }\n      /**\n       * Called with socket packet.\n       *\n       * @param packet\n       * @private\n       */\n    }, {\n      key: \"onpacket\",\n      value: function onpacket(packet) {\n        var sameNamespace = packet.nsp === this.nsp;\n        if (!sameNamespace) return;\n        switch (packet.type) {\n          case PacketType.CONNECT:\n            if (packet.data && packet.data.sid) {\n              this.onconnect(packet.data.sid, packet.data.pid);\n            } else {\n              this.emitReserved(\"connect_error\", new Error(\"It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)\"));\n            }\n            break;\n          case PacketType.EVENT:\n          case PacketType.BINARY_EVENT:\n            this.onevent(packet);\n            break;\n          case PacketType.ACK:\n          case PacketType.BINARY_ACK:\n            this.onack(packet);\n            break;\n          case PacketType.DISCONNECT:\n            this.ondisconnect();\n            break;\n          case PacketType.CONNECT_ERROR:\n            this.destroy();\n            var err = new Error(packet.data.message);\n            // @ts-ignore\n            err.data = packet.data.data;\n            this.emitReserved(\"connect_error\", err);\n            break;\n        }\n      }\n      /**\n       * Called upon a server event.\n       *\n       * @param packet\n       * @private\n       */\n    }, {\n      key: \"onevent\",\n      value: function onevent(packet) {\n        var args = packet.data || [];\n        if (null != packet.id) {\n          args.push(this.ack(packet.id));\n        }\n        if (this.connected) {\n          this.emitEvent(args);\n        } else {\n          this.receiveBuffer.push(Object.freeze(args));\n        }\n      }\n    }, {\n      key: \"emitEvent\",\n      value: function emitEvent(args) {\n        if (this._anyListeners && this._anyListeners.length) {\n          var listeners = this._anyListeners.slice();\n          var _iterator = _createForOfIteratorHelper(listeners),\n            _step;\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var listener = _step.value;\n              listener.apply(this, args);\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n        }\n        _get(_getPrototypeOf(Socket.prototype), \"emit\", this).apply(this, args);\n        if (this._pid && args.length && typeof args[args.length - 1] === \"string\") {\n          this._lastOffset = args[args.length - 1];\n        }\n      }\n      /**\n       * Produces an ack callback to emit with an event.\n       *\n       * @private\n       */\n    }, {\n      key: \"ack\",\n      value: function ack(id) {\n        var self = this;\n        var sent = false;\n        return function () {\n          // prevent double callbacks\n          if (sent) return;\n          sent = true;\n          for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n            args[_key6] = arguments[_key6];\n          }\n          self.packet({\n            type: PacketType.ACK,\n            id: id,\n            data: args\n          });\n        };\n      }\n      /**\n       * Called upon a server acknowledgement.\n       *\n       * @param packet\n       * @private\n       */\n    }, {\n      key: \"onack\",\n      value: function onack(packet) {\n        var ack = this.acks[packet.id];\n        if (typeof ack !== \"function\") {\n          return;\n        }\n        delete this.acks[packet.id];\n        // @ts-ignore FIXME ack is incorrectly inferred as 'never'\n        if (ack.withError) {\n          packet.data.unshift(null);\n        }\n        // @ts-ignore\n        ack.apply(this, packet.data);\n      }\n      /**\n       * Called upon server connect.\n       *\n       * @private\n       */\n    }, {\n      key: \"onconnect\",\n      value: function onconnect(id, pid) {\n        this.id = id;\n        this.recovered = pid && this._pid === pid;\n        this._pid = pid; // defined only if connection state recovery is enabled\n        this.connected = true;\n        this.emitBuffered();\n        this.emitReserved(\"connect\");\n        this._drainQueue(true);\n      }\n      /**\n       * Emit buffered events (received and emitted).\n       *\n       * @private\n       */\n    }, {\n      key: \"emitBuffered\",\n      value: function emitBuffered() {\n        var _this7 = this;\n        this.receiveBuffer.forEach(function (args) {\n          return _this7.emitEvent(args);\n        });\n        this.receiveBuffer = [];\n        this.sendBuffer.forEach(function (packet) {\n          _this7.notifyOutgoingListeners(packet);\n          _this7.packet(packet);\n        });\n        this.sendBuffer = [];\n      }\n      /**\n       * Called upon server disconnect.\n       *\n       * @private\n       */\n    }, {\n      key: \"ondisconnect\",\n      value: function ondisconnect() {\n        this.destroy();\n        this.onclose(\"io server disconnect\");\n      }\n      /**\n       * Called upon forced client/server side disconnections,\n       * this method ensures the manager stops tracking us and\n       * that reconnections don't get triggered for this.\n       *\n       * @private\n       */\n    }, {\n      key: \"destroy\",\n      value: function destroy() {\n        if (this.subs) {\n          // clean subscriptions to avoid reconnections\n          this.subs.forEach(function (subDestroy) {\n            return subDestroy();\n          });\n          this.subs = undefined;\n        }\n        this.io[\"_destroy\"](this);\n      }\n      /**\n       * Disconnects the socket manually. In that case, the socket will not try to reconnect.\n       *\n       * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.\n       *\n       * @example\n       * const socket = io();\n       *\n       * socket.on(\"disconnect\", (reason) => {\n       *   // console.log(reason); prints \"io client disconnect\"\n       * });\n       *\n       * socket.disconnect();\n       *\n       * @return self\n       */\n    }, {\n      key: \"disconnect\",\n      value: function disconnect() {\n        if (this.connected) {\n          this.packet({\n            type: PacketType.DISCONNECT\n          });\n        }\n        // remove socket from pool\n        this.destroy();\n        if (this.connected) {\n          // fire events\n          this.onclose(\"io client disconnect\");\n        }\n        return this;\n      }\n      /**\n       * Alias for {@link disconnect()}.\n       *\n       * @return self\n       */\n    }, {\n      key: \"close\",\n      value: function close() {\n        return this.disconnect();\n      }\n      /**\n       * Sets the compress flag.\n       *\n       * @example\n       * socket.compress(false).emit(\"hello\");\n       *\n       * @param compress - if `true`, compresses the sending data\n       * @return self\n       */\n    }, {\n      key: \"compress\",\n      value: function compress(_compress) {\n        this.flags.compress = _compress;\n        return this;\n      }\n      /**\n       * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not\n       * ready to send messages.\n       *\n       * @example\n       * socket.volatile.emit(\"hello\"); // the server may or may not receive it\n       *\n       * @returns self\n       */\n    }, {\n      key: \"volatile\",\n      get: function get() {\n        this.flags[\"volatile\"] = true;\n        return this;\n      }\n      /**\n       * Sets a modifier for a subsequent event emission that the callback will be called with an error when the\n       * given number of milliseconds have elapsed without an acknowledgement from the server:\n       *\n       * @example\n       * socket.timeout(5000).emit(\"my-event\", (err) => {\n       *   if (err) {\n       *     // the server did not acknowledge the event in the given delay\n       *   }\n       * });\n       *\n       * @returns self\n       */\n    }, {\n      key: \"timeout\",\n      value: function timeout(_timeout) {\n        this.flags.timeout = _timeout;\n        return this;\n      }\n      /**\n       * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n       * callback.\n       *\n       * @example\n       * socket.onAny((event, ...args) => {\n       *   console.log(`got ${event}`);\n       * });\n       *\n       * @param listener\n       */\n    }, {\n      key: \"onAny\",\n      value: function onAny(listener) {\n        this._anyListeners = this._anyListeners || [];\n        this._anyListeners.push(listener);\n        return this;\n      }\n      /**\n       * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n       * callback. The listener is added to the beginning of the listeners array.\n       *\n       * @example\n       * socket.prependAny((event, ...args) => {\n       *   console.log(`got event ${event}`);\n       * });\n       *\n       * @param listener\n       */\n    }, {\n      key: \"prependAny\",\n      value: function prependAny(listener) {\n        this._anyListeners = this._anyListeners || [];\n        this._anyListeners.unshift(listener);\n        return this;\n      }\n      /**\n       * Removes the listener that will be fired when any event is emitted.\n       *\n       * @example\n       * const catchAllListener = (event, ...args) => {\n       *   console.log(`got event ${event}`);\n       * }\n       *\n       * socket.onAny(catchAllListener);\n       *\n       * // remove a specific listener\n       * socket.offAny(catchAllListener);\n       *\n       * // or remove all listeners\n       * socket.offAny();\n       *\n       * @param listener\n       */\n    }, {\n      key: \"offAny\",\n      value: function offAny(listener) {\n        if (!this._anyListeners) {\n          return this;\n        }\n        if (listener) {\n          var listeners = this._anyListeners;\n          for (var i = 0; i < listeners.length; i++) {\n            if (listener === listeners[i]) {\n              listeners.splice(i, 1);\n              return this;\n            }\n          }\n        } else {\n          this._anyListeners = [];\n        }\n        return this;\n      }\n      /**\n       * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,\n       * e.g. to remove listeners.\n       */\n    }, {\n      key: \"listenersAny\",\n      value: function listenersAny() {\n        return this._anyListeners || [];\n      }\n      /**\n       * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n       * callback.\n       *\n       * Note: acknowledgements sent to the server are not included.\n       *\n       * @example\n       * socket.onAnyOutgoing((event, ...args) => {\n       *   console.log(`sent event ${event}`);\n       * });\n       *\n       * @param listener\n       */\n    }, {\n      key: \"onAnyOutgoing\",\n      value: function onAnyOutgoing(listener) {\n        this._anyOutgoingListeners = this._anyOutgoingListeners || [];\n        this._anyOutgoingListeners.push(listener);\n        return this;\n      }\n      /**\n       * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n       * callback. The listener is added to the beginning of the listeners array.\n       *\n       * Note: acknowledgements sent to the server are not included.\n       *\n       * @example\n       * socket.prependAnyOutgoing((event, ...args) => {\n       *   console.log(`sent event ${event}`);\n       * });\n       *\n       * @param listener\n       */\n    }, {\n      key: \"prependAnyOutgoing\",\n      value: function prependAnyOutgoing(listener) {\n        this._anyOutgoingListeners = this._anyOutgoingListeners || [];\n        this._anyOutgoingListeners.unshift(listener);\n        return this;\n      }\n      /**\n       * Removes the listener that will be fired when any event is emitted.\n       *\n       * @example\n       * const catchAllListener = (event, ...args) => {\n       *   console.log(`sent event ${event}`);\n       * }\n       *\n       * socket.onAnyOutgoing(catchAllListener);\n       *\n       * // remove a specific listener\n       * socket.offAnyOutgoing(catchAllListener);\n       *\n       * // or remove all listeners\n       * socket.offAnyOutgoing();\n       *\n       * @param [listener] - the catch-all listener (optional)\n       */\n    }, {\n      key: \"offAnyOutgoing\",\n      value: function offAnyOutgoing(listener) {\n        if (!this._anyOutgoingListeners) {\n          return this;\n        }\n        if (listener) {\n          var listeners = this._anyOutgoingListeners;\n          for (var i = 0; i < listeners.length; i++) {\n            if (listener === listeners[i]) {\n              listeners.splice(i, 1);\n              return this;\n            }\n          }\n        } else {\n          this._anyOutgoingListeners = [];\n        }\n        return this;\n      }\n      /**\n       * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,\n       * e.g. to remove listeners.\n       */\n    }, {\n      key: \"listenersAnyOutgoing\",\n      value: function listenersAnyOutgoing() {\n        return this._anyOutgoingListeners || [];\n      }\n      /**\n       * Notify the listeners for each packet sent\n       *\n       * @param packet\n       *\n       * @private\n       */\n    }, {\n      key: \"notifyOutgoingListeners\",\n      value: function notifyOutgoingListeners(packet) {\n        if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {\n          var listeners = this._anyOutgoingListeners.slice();\n          var _iterator2 = _createForOfIteratorHelper(listeners),\n            _step2;\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var listener = _step2.value;\n              listener.apply(this, packet.data);\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n        }\n      }\n    }]);\n    return Socket;\n  }(Emitter);\n\n  /**\n   * Initialize backoff timer with `opts`.\n   *\n   * - `min` initial timeout in milliseconds [100]\n   * - `max` max timeout [10000]\n   * - `jitter` [0]\n   * - `factor` [2]\n   *\n   * @param {Object} opts\n   * @api public\n   */\n  function Backoff(opts) {\n    opts = opts || {};\n    this.ms = opts.min || 100;\n    this.max = opts.max || 10000;\n    this.factor = opts.factor || 2;\n    this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;\n    this.attempts = 0;\n  }\n  /**\n   * Return the backoff duration.\n   *\n   * @return {Number}\n   * @api public\n   */\n  Backoff.prototype.duration = function () {\n    var ms = this.ms * Math.pow(this.factor, this.attempts++);\n    if (this.jitter) {\n      var rand = Math.random();\n      var deviation = Math.floor(rand * this.jitter * ms);\n      ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;\n    }\n    return Math.min(ms, this.max) | 0;\n  };\n  /**\n   * Reset the number of attempts.\n   *\n   * @api public\n   */\n  Backoff.prototype.reset = function () {\n    this.attempts = 0;\n  };\n  /**\n   * Set the minimum duration\n   *\n   * @api public\n   */\n  Backoff.prototype.setMin = function (min) {\n    this.ms = min;\n  };\n  /**\n   * Set the maximum duration\n   *\n   * @api public\n   */\n  Backoff.prototype.setMax = function (max) {\n    this.max = max;\n  };\n  /**\n   * Set the jitter\n   *\n   * @api public\n   */\n  Backoff.prototype.setJitter = function (jitter) {\n    this.jitter = jitter;\n  };\n\n  var Manager = /*#__PURE__*/function (_Emitter) {\n    _inherits(Manager, _Emitter);\n    var _super = _createSuper(Manager);\n    function Manager(uri, opts) {\n      var _this;\n      _classCallCheck(this, Manager);\n      var _a;\n      _this = _super.call(this);\n      _this.nsps = {};\n      _this.subs = [];\n      if (uri && \"object\" === _typeof(uri)) {\n        opts = uri;\n        uri = undefined;\n      }\n      opts = opts || {};\n      opts.path = opts.path || \"/socket.io\";\n      _this.opts = opts;\n      installTimerFunctions(_assertThisInitialized(_this), opts);\n      _this.reconnection(opts.reconnection !== false);\n      _this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);\n      _this.reconnectionDelay(opts.reconnectionDelay || 1000);\n      _this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);\n      _this.randomizationFactor((_a = opts.randomizationFactor) !== null && _a !== void 0 ? _a : 0.5);\n      _this.backoff = new Backoff({\n        min: _this.reconnectionDelay(),\n        max: _this.reconnectionDelayMax(),\n        jitter: _this.randomizationFactor()\n      });\n      _this.timeout(null == opts.timeout ? 20000 : opts.timeout);\n      _this._readyState = \"closed\";\n      _this.uri = uri;\n      var _parser = opts.parser || parser;\n      _this.encoder = new _parser.Encoder();\n      _this.decoder = new _parser.Decoder();\n      _this._autoConnect = opts.autoConnect !== false;\n      if (_this._autoConnect) _this.open();\n      return _this;\n    }\n    _createClass(Manager, [{\n      key: \"reconnection\",\n      value: function reconnection(v) {\n        if (!arguments.length) return this._reconnection;\n        this._reconnection = !!v;\n        return this;\n      }\n    }, {\n      key: \"reconnectionAttempts\",\n      value: function reconnectionAttempts(v) {\n        if (v === undefined) return this._reconnectionAttempts;\n        this._reconnectionAttempts = v;\n        return this;\n      }\n    }, {\n      key: \"reconnectionDelay\",\n      value: function reconnectionDelay(v) {\n        var _a;\n        if (v === undefined) return this._reconnectionDelay;\n        this._reconnectionDelay = v;\n        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMin(v);\n        return this;\n      }\n    }, {\n      key: \"randomizationFactor\",\n      value: function randomizationFactor(v) {\n        var _a;\n        if (v === undefined) return this._randomizationFactor;\n        this._randomizationFactor = v;\n        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setJitter(v);\n        return this;\n      }\n    }, {\n      key: \"reconnectionDelayMax\",\n      value: function reconnectionDelayMax(v) {\n        var _a;\n        if (v === undefined) return this._reconnectionDelayMax;\n        this._reconnectionDelayMax = v;\n        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMax(v);\n        return this;\n      }\n    }, {\n      key: \"timeout\",\n      value: function timeout(v) {\n        if (!arguments.length) return this._timeout;\n        this._timeout = v;\n        return this;\n      }\n      /**\n       * Starts trying to reconnect if reconnection is enabled and we have not\n       * started reconnecting yet\n       *\n       * @private\n       */\n    }, {\n      key: \"maybeReconnectOnOpen\",\n      value: function maybeReconnectOnOpen() {\n        // Only try to reconnect if it's the first time we're connecting\n        if (!this._reconnecting && this._reconnection && this.backoff.attempts === 0) {\n          // keeps reconnection from firing twice for the same reconnection loop\n          this.reconnect();\n        }\n      }\n      /**\n       * Sets the current transport `socket`.\n       *\n       * @param {Function} fn - optional, callback\n       * @return self\n       * @public\n       */\n    }, {\n      key: \"open\",\n      value: function open(fn) {\n        var _this2 = this;\n        if (~this._readyState.indexOf(\"open\")) return this;\n        this.engine = new Socket$1(this.uri, this.opts);\n        var socket = this.engine;\n        var self = this;\n        this._readyState = \"opening\";\n        this.skipReconnect = false;\n        // emit `open`\n        var openSubDestroy = on(socket, \"open\", function () {\n          self.onopen();\n          fn && fn();\n        });\n        var onError = function onError(err) {\n          _this2.cleanup();\n          _this2._readyState = \"closed\";\n          _this2.emitReserved(\"error\", err);\n          if (fn) {\n            fn(err);\n          } else {\n            // Only do this if there is no fn to handle the error\n            _this2.maybeReconnectOnOpen();\n          }\n        };\n        // emit `error`\n        var errorSub = on(socket, \"error\", onError);\n        if (false !== this._timeout) {\n          var timeout = this._timeout;\n          // set timer\n          var timer = this.setTimeoutFn(function () {\n            openSubDestroy();\n            onError(new Error(\"timeout\"));\n            socket.close();\n          }, timeout);\n          if (this.opts.autoUnref) {\n            timer.unref();\n          }\n          this.subs.push(function () {\n            _this2.clearTimeoutFn(timer);\n          });\n        }\n        this.subs.push(openSubDestroy);\n        this.subs.push(errorSub);\n        return this;\n      }\n      /**\n       * Alias for open()\n       *\n       * @return self\n       * @public\n       */\n    }, {\n      key: \"connect\",\n      value: function connect(fn) {\n        return this.open(fn);\n      }\n      /**\n       * Called upon transport open.\n       *\n       * @private\n       */\n    }, {\n      key: \"onopen\",\n      value: function onopen() {\n        // clear old subs\n        this.cleanup();\n        // mark as open\n        this._readyState = \"open\";\n        this.emitReserved(\"open\");\n        // add new subs\n        var socket = this.engine;\n        this.subs.push(on(socket, \"ping\", this.onping.bind(this)), on(socket, \"data\", this.ondata.bind(this)), on(socket, \"error\", this.onerror.bind(this)), on(socket, \"close\", this.onclose.bind(this)), on(this.decoder, \"decoded\", this.ondecoded.bind(this)));\n      }\n      /**\n       * Called upon a ping.\n       *\n       * @private\n       */\n    }, {\n      key: \"onping\",\n      value: function onping() {\n        this.emitReserved(\"ping\");\n      }\n      /**\n       * Called with data.\n       *\n       * @private\n       */\n    }, {\n      key: \"ondata\",\n      value: function ondata(data) {\n        try {\n          this.decoder.add(data);\n        } catch (e) {\n          this.onclose(\"parse error\", e);\n        }\n      }\n      /**\n       * Called when parser fully decodes a packet.\n       *\n       * @private\n       */\n    }, {\n      key: \"ondecoded\",\n      value: function ondecoded(packet) {\n        var _this3 = this;\n        // the nextTick call prevents an exception in a user-provided event listener from triggering a disconnection due to a \"parse error\"\n        nextTick(function () {\n          _this3.emitReserved(\"packet\", packet);\n        }, this.setTimeoutFn);\n      }\n      /**\n       * Called upon socket error.\n       *\n       * @private\n       */\n    }, {\n      key: \"onerror\",\n      value: function onerror(err) {\n        this.emitReserved(\"error\", err);\n      }\n      /**\n       * Creates a new socket for the given `nsp`.\n       *\n       * @return {Socket}\n       * @public\n       */\n    }, {\n      key: \"socket\",\n      value: function socket(nsp, opts) {\n        var socket = this.nsps[nsp];\n        if (!socket) {\n          socket = new Socket(this, nsp, opts);\n          this.nsps[nsp] = socket;\n        } else if (this._autoConnect && !socket.active) {\n          socket.connect();\n        }\n        return socket;\n      }\n      /**\n       * Called upon a socket close.\n       *\n       * @param socket\n       * @private\n       */\n    }, {\n      key: \"_destroy\",\n      value: function _destroy(socket) {\n        var nsps = Object.keys(this.nsps);\n        for (var _i = 0, _nsps = nsps; _i < _nsps.length; _i++) {\n          var nsp = _nsps[_i];\n          var _socket = this.nsps[nsp];\n          if (_socket.active) {\n            return;\n          }\n        }\n        this._close();\n      }\n      /**\n       * Writes a packet.\n       *\n       * @param packet\n       * @private\n       */\n    }, {\n      key: \"_packet\",\n      value: function _packet(packet) {\n        var encodedPackets = this.encoder.encode(packet);\n        for (var i = 0; i < encodedPackets.length; i++) {\n          this.engine.write(encodedPackets[i], packet.options);\n        }\n      }\n      /**\n       * Clean up transport subscriptions and packet buffer.\n       *\n       * @private\n       */\n    }, {\n      key: \"cleanup\",\n      value: function cleanup() {\n        this.subs.forEach(function (subDestroy) {\n          return subDestroy();\n        });\n        this.subs.length = 0;\n        this.decoder.destroy();\n      }\n      /**\n       * Close the current socket.\n       *\n       * @private\n       */\n    }, {\n      key: \"_close\",\n      value: function _close() {\n        this.skipReconnect = true;\n        this._reconnecting = false;\n        this.onclose(\"forced close\");\n        if (this.engine) this.engine.close();\n      }\n      /**\n       * Alias for close()\n       *\n       * @private\n       */\n    }, {\n      key: \"disconnect\",\n      value: function disconnect() {\n        return this._close();\n      }\n      /**\n       * Called upon engine close.\n       *\n       * @private\n       */\n    }, {\n      key: \"onclose\",\n      value: function onclose(reason, description) {\n        this.cleanup();\n        this.backoff.reset();\n        this._readyState = \"closed\";\n        this.emitReserved(\"close\", reason, description);\n        if (this._reconnection && !this.skipReconnect) {\n          this.reconnect();\n        }\n      }\n      /**\n       * Attempt a reconnection.\n       *\n       * @private\n       */\n    }, {\n      key: \"reconnect\",\n      value: function reconnect() {\n        var _this4 = this;\n        if (this._reconnecting || this.skipReconnect) return this;\n        var self = this;\n        if (this.backoff.attempts >= this._reconnectionAttempts) {\n          this.backoff.reset();\n          this.emitReserved(\"reconnect_failed\");\n          this._reconnecting = false;\n        } else {\n          var delay = this.backoff.duration();\n          this._reconnecting = true;\n          var timer = this.setTimeoutFn(function () {\n            if (self.skipReconnect) return;\n            _this4.emitReserved(\"reconnect_attempt\", self.backoff.attempts);\n            // check again for the case socket closed in above events\n            if (self.skipReconnect) return;\n            self.open(function (err) {\n              if (err) {\n                self._reconnecting = false;\n                self.reconnect();\n                _this4.emitReserved(\"reconnect_error\", err);\n              } else {\n                self.onreconnect();\n              }\n            });\n          }, delay);\n          if (this.opts.autoUnref) {\n            timer.unref();\n          }\n          this.subs.push(function () {\n            _this4.clearTimeoutFn(timer);\n          });\n        }\n      }\n      /**\n       * Called upon successful reconnect.\n       *\n       * @private\n       */\n    }, {\n      key: \"onreconnect\",\n      value: function onreconnect() {\n        var attempt = this.backoff.attempts;\n        this._reconnecting = false;\n        this.backoff.reset();\n        this.emitReserved(\"reconnect\", attempt);\n      }\n    }]);\n    return Manager;\n  }(Emitter);\n\n  /**\n   * Managers cache.\n   */\n  var cache = {};\n  function lookup(uri, opts) {\n    if (_typeof(uri) === \"object\") {\n      opts = uri;\n      uri = undefined;\n    }\n    opts = opts || {};\n    var parsed = url(uri, opts.path || \"/socket.io\");\n    var source = parsed.source;\n    var id = parsed.id;\n    var path = parsed.path;\n    var sameNamespace = cache[id] && path in cache[id][\"nsps\"];\n    var newConnection = opts.forceNew || opts[\"force new connection\"] || false === opts.multiplex || sameNamespace;\n    var io;\n    if (newConnection) {\n      io = new Manager(source, opts);\n    } else {\n      if (!cache[id]) {\n        cache[id] = new Manager(source, opts);\n      }\n      io = cache[id];\n    }\n    if (parsed.query && !opts.query) {\n      opts.query = parsed.queryKey;\n    }\n    return io.socket(parsed.path, opts);\n  }\n  // so that \"lookup\" can be used both as a function (e.g. `io(...)`) and as a\n  // namespace (e.g. `io.connect(...)`), for backward compatibility\n  _extends(lookup, {\n    Manager: Manager,\n    Socket: Socket,\n    io: lookup,\n    connect: lookup\n  });\n\n  return lookup;\n\n}));\n//# sourceMappingURL=socket.io.js.map\n","const PACKET_TYPES = Object.create(null); // no Map = no polyfill\nPACKET_TYPES[\"open\"] = \"0\";\nPACKET_TYPES[\"close\"] = \"1\";\nPACKET_TYPES[\"ping\"] = \"2\";\nPACKET_TYPES[\"pong\"] = \"3\";\nPACKET_TYPES[\"message\"] = \"4\";\nPACKET_TYPES[\"upgrade\"] = \"5\";\nPACKET_TYPES[\"noop\"] = \"6\";\nconst PACKET_TYPES_REVERSE = Object.create(null);\nObject.keys(PACKET_TYPES).forEach(key => {\n    PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;\n});\nconst ERROR_PACKET = { type: \"error\", data: \"parser error\" };\nexport { PACKET_TYPES, PACKET_TYPES_REVERSE, ERROR_PACKET };\n","import { PACKET_TYPES } from \"./commons.js\";\nconst withNativeBlob = typeof Blob === \"function\" ||\n    (typeof Blob !== \"undefined\" &&\n        Object.prototype.toString.call(Blob) === \"[object BlobConstructor]\");\nconst withNativeArrayBuffer = typeof ArrayBuffer === \"function\";\n// ArrayBuffer.isView method is not defined in IE10\nconst isView = obj => {\n    return typeof ArrayBuffer.isView === \"function\"\n        ? ArrayBuffer.isView(obj)\n        : obj && obj.buffer instanceof ArrayBuffer;\n};\nconst encodePacket = ({ type, data }, supportsBinary, callback) => {\n    if (withNativeBlob && data instanceof Blob) {\n        if (supportsBinary) {\n            return callback(data);\n        }\n        else {\n            return encodeBlobAsBase64(data, callback);\n        }\n    }\n    else if (withNativeArrayBuffer &&\n        (data instanceof ArrayBuffer || isView(data))) {\n        if (supportsBinary) {\n            return callback(data);\n        }\n        else {\n            return encodeBlobAsBase64(new Blob([data]), callback);\n        }\n    }\n    // plain string\n    return callback(PACKET_TYPES[type] + (data || \"\"));\n};\nconst encodeBlobAsBase64 = (data, callback) => {\n    const fileReader = new FileReader();\n    fileReader.onload = function () {\n        const content = fileReader.result.split(\",\")[1];\n        callback(\"b\" + (content || \"\"));\n    };\n    return fileReader.readAsDataURL(data);\n};\nfunction toArray(data) {\n    if (data instanceof Uint8Array) {\n        return data;\n    }\n    else if (data instanceof ArrayBuffer) {\n        return new Uint8Array(data);\n    }\n    else {\n        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);\n    }\n}\nlet TEXT_ENCODER;\nexport function encodePacketToBinary(packet, callback) {\n    if (withNativeBlob && packet.data instanceof Blob) {\n        return packet.data\n            .arrayBuffer()\n            .then(toArray)\n            .then(callback);\n    }\n    else if (withNativeArrayBuffer &&\n        (packet.data instanceof ArrayBuffer || isView(packet.data))) {\n        return callback(toArray(packet.data));\n    }\n    encodePacket(packet, false, encoded => {\n        if (!TEXT_ENCODER) {\n            TEXT_ENCODER = new TextEncoder();\n        }\n        callback(TEXT_ENCODER.encode(encoded));\n    });\n}\nexport { encodePacket };\n","// imported from https://github.com/socketio/base64-arraybuffer\nconst chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n// Use a lookup table to find the index.\nconst lookup = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);\nfor (let i = 0; i < chars.length; i++) {\n    lookup[chars.charCodeAt(i)] = i;\n}\nexport const encode = (arraybuffer) => {\n    let bytes = new Uint8Array(arraybuffer), i, len = bytes.length, base64 = '';\n    for (i = 0; i < len; i += 3) {\n        base64 += chars[bytes[i] >> 2];\n        base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n        base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\n        base64 += chars[bytes[i + 2] & 63];\n    }\n    if (len % 3 === 2) {\n        base64 = base64.substring(0, base64.length - 1) + '=';\n    }\n    else if (len % 3 === 1) {\n        base64 = base64.substring(0, base64.length - 2) + '==';\n    }\n    return base64;\n};\nexport const decode = (base64) => {\n    let bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;\n    if (base64[base64.length - 1] === '=') {\n        bufferLength--;\n        if (base64[base64.length - 2] === '=') {\n            bufferLength--;\n        }\n    }\n    const arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);\n    for (i = 0; i < len; i += 4) {\n        encoded1 = lookup[base64.charCodeAt(i)];\n        encoded2 = lookup[base64.charCodeAt(i + 1)];\n        encoded3 = lookup[base64.charCodeAt(i + 2)];\n        encoded4 = lookup[base64.charCodeAt(i + 3)];\n        bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);\n        bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);\n        bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);\n    }\n    return arraybuffer;\n};\n","import { ERROR_PACKET, PACKET_TYPES_REVERSE } from \"./commons.js\";\nimport { decode } from \"./contrib/base64-arraybuffer.js\";\nconst withNativeArrayBuffer = typeof ArrayBuffer === \"function\";\nexport const decodePacket = (encodedPacket, binaryType) => {\n    if (typeof encodedPacket !== \"string\") {\n        return {\n            type: \"message\",\n            data: mapBinary(encodedPacket, binaryType)\n        };\n    }\n    const type = encodedPacket.charAt(0);\n    if (type === \"b\") {\n        return {\n            type: \"message\",\n            data: decodeBase64Packet(encodedPacket.substring(1), binaryType)\n        };\n    }\n    const packetType = PACKET_TYPES_REVERSE[type];\n    if (!packetType) {\n        return ERROR_PACKET;\n    }\n    return encodedPacket.length > 1\n        ? {\n            type: PACKET_TYPES_REVERSE[type],\n            data: encodedPacket.substring(1)\n        }\n        : {\n            type: PACKET_TYPES_REVERSE[type]\n        };\n};\nconst decodeBase64Packet = (data, binaryType) => {\n    if (withNativeArrayBuffer) {\n        const decoded = decode(data);\n        return mapBinary(decoded, binaryType);\n    }\n    else {\n        return { base64: true, data }; // fallback for old browsers\n    }\n};\nconst mapBinary = (data, binaryType) => {\n    switch (binaryType) {\n        case \"blob\":\n            if (data instanceof Blob) {\n                // from WebSocket + binaryType \"blob\"\n                return data;\n            }\n            else {\n                // from HTTP long-polling or WebTransport\n                return new Blob([data]);\n            }\n        case \"arraybuffer\":\n        default:\n            if (data instanceof ArrayBuffer) {\n                // from HTTP long-polling (base64) or WebSocket + binaryType \"arraybuffer\"\n                return data;\n            }\n            else {\n                // from WebTransport (Uint8Array)\n                return data.buffer;\n            }\n    }\n};\n","import { encodePacket, encodePacketToBinary } from \"./encodePacket.js\";\nimport { decodePacket } from \"./decodePacket.js\";\nimport { ERROR_PACKET } from \"./commons.js\";\nconst SEPARATOR = String.fromCharCode(30); // see https://en.wikipedia.org/wiki/Delimiter#ASCII_delimited_text\nconst encodePayload = (packets, callback) => {\n    // some packets may be added to the array while encoding, so the initial length must be saved\n    const length = packets.length;\n    const encodedPackets = new Array(length);\n    let count = 0;\n    packets.forEach((packet, i) => {\n        // force base64 encoding for binary packets\n        encodePacket(packet, false, encodedPacket => {\n            encodedPackets[i] = encodedPacket;\n            if (++count === length) {\n                callback(encodedPackets.join(SEPARATOR));\n            }\n        });\n    });\n};\nconst decodePayload = (encodedPayload, binaryType) => {\n    const encodedPackets = encodedPayload.split(SEPARATOR);\n    const packets = [];\n    for (let i = 0; i < encodedPackets.length; i++) {\n        const decodedPacket = decodePacket(encodedPackets[i], binaryType);\n        packets.push(decodedPacket);\n        if (decodedPacket.type === \"error\") {\n            break;\n        }\n    }\n    return packets;\n};\nexport function createPacketEncoderStream() {\n    return new TransformStream({\n        transform(packet, controller) {\n            encodePacketToBinary(packet, encodedPacket => {\n                const payloadLength = encodedPacket.length;\n                let header;\n                // inspired by the WebSocket format: https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API/Writing_WebSocket_servers#decoding_payload_length\n                if (payloadLength < 126) {\n                    header = new Uint8Array(1);\n                    new DataView(header.buffer).setUint8(0, payloadLength);\n                }\n                else if (payloadLength < 65536) {\n                    header = new Uint8Array(3);\n                    const view = new DataView(header.buffer);\n                    view.setUint8(0, 126);\n                    view.setUint16(1, payloadLength);\n                }\n                else {\n                    header = new Uint8Array(9);\n                    const view = new DataView(header.buffer);\n                    view.setUint8(0, 127);\n                    view.setBigUint64(1, BigInt(payloadLength));\n                }\n                // first bit indicates whether the payload is plain text (0) or binary (1)\n                if (packet.data && typeof packet.data !== \"string\") {\n                    header[0] |= 0x80;\n                }\n                controller.enqueue(header);\n                controller.enqueue(encodedPacket);\n            });\n        }\n    });\n}\nlet TEXT_DECODER;\nfunction totalLength(chunks) {\n    return chunks.reduce((acc, chunk) => acc + chunk.length, 0);\n}\nfunction concatChunks(chunks, size) {\n    if (chunks[0].length === size) {\n        return chunks.shift();\n    }\n    const buffer = new Uint8Array(size);\n    let j = 0;\n    for (let i = 0; i < size; i++) {\n        buffer[i] = chunks[0][j++];\n        if (j === chunks[0].length) {\n            chunks.shift();\n            j = 0;\n        }\n    }\n    if (chunks.length && j < chunks[0].length) {\n        chunks[0] = chunks[0].slice(j);\n    }\n    return buffer;\n}\nexport function createPacketDecoderStream(maxPayload, binaryType) {\n    if (!TEXT_DECODER) {\n        TEXT_DECODER = new TextDecoder();\n    }\n    const chunks = [];\n    let state = 0 /* READ_HEADER */;\n    let expectedLength = -1;\n    let isBinary = false;\n    return new TransformStream({\n        transform(chunk, controller) {\n            chunks.push(chunk);\n            while (true) {\n                if (state === 0 /* READ_HEADER */) {\n                    if (totalLength(chunks) < 1) {\n                        break;\n                    }\n                    const header = concatChunks(chunks, 1);\n                    isBinary = (header[0] & 0x80) === 0x80;\n                    expectedLength = header[0] & 0x7f;\n                    if (expectedLength < 126) {\n                        state = 3 /* READ_PAYLOAD */;\n                    }\n                    else if (expectedLength === 126) {\n                        state = 1 /* READ_EXTENDED_LENGTH_16 */;\n                    }\n                    else {\n                        state = 2 /* READ_EXTENDED_LENGTH_64 */;\n                    }\n                }\n                else if (state === 1 /* READ_EXTENDED_LENGTH_16 */) {\n                    if (totalLength(chunks) < 2) {\n                        break;\n                    }\n                    const headerArray = concatChunks(chunks, 2);\n                    expectedLength = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length).getUint16(0);\n                    state = 3 /* READ_PAYLOAD */;\n                }\n                else if (state === 2 /* READ_EXTENDED_LENGTH_64 */) {\n                    if (totalLength(chunks) < 8) {\n                        break;\n                    }\n                    const headerArray = concatChunks(chunks, 8);\n                    const view = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length);\n                    const n = view.getUint32(0);\n                    if (n > Math.pow(2, 53 - 32) - 1) {\n                        // the maximum safe integer in JavaScript is 2^53 - 1\n                        controller.enqueue(ERROR_PACKET);\n                        break;\n                    }\n                    expectedLength = n * Math.pow(2, 32) + view.getUint32(4);\n                    state = 3 /* READ_PAYLOAD */;\n                }\n                else {\n                    if (totalLength(chunks) < expectedLength) {\n                        break;\n                    }\n                    const data = concatChunks(chunks, expectedLength);\n                    controller.enqueue(decodePacket(isBinary ? data : TEXT_DECODER.decode(data), binaryType));\n                    state = 0 /* READ_HEADER */;\n                }\n                if (expectedLength === 0 || expectedLength > maxPayload) {\n                    controller.enqueue(ERROR_PACKET);\n                    break;\n                }\n            }\n        }\n    });\n}\nexport const protocol = 4;\nexport { encodePacket, encodePayload, decodePacket, decodePayload };\n","/**\n * Initialize a new `Emitter`.\n *\n * @api public\n */\n\nexport function Emitter(obj) {\n  if (obj) return mixin(obj);\n}\n\n/**\n * Mixin the emitter properties.\n *\n * @param {Object} obj\n * @return {Object}\n * @api private\n */\n\nfunction mixin(obj) {\n  for (var key in Emitter.prototype) {\n    obj[key] = Emitter.prototype[key];\n  }\n  return obj;\n}\n\n/**\n * Listen on the given `event` with `fn`.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.on =\nEmitter.prototype.addEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])\n    .push(fn);\n  return this;\n};\n\n/**\n * Adds an `event` listener that will be invoked a single\n * time then automatically removed.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.once = function(event, fn){\n  function on() {\n    this.off(event, on);\n    fn.apply(this, arguments);\n  }\n\n  on.fn = fn;\n  this.on(event, on);\n  return this;\n};\n\n/**\n * Remove the given callback for `event` or all\n * registered callbacks.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.off =\nEmitter.prototype.removeListener =\nEmitter.prototype.removeAllListeners =\nEmitter.prototype.removeEventListener = function(event, fn){\n  this._callbacks = this._callbacks || {};\n\n  // all\n  if (0 == arguments.length) {\n    this._callbacks = {};\n    return this;\n  }\n\n  // specific event\n  var callbacks = this._callbacks['$' + event];\n  if (!callbacks) return this;\n\n  // remove all handlers\n  if (1 == arguments.length) {\n    delete this._callbacks['$' + event];\n    return this;\n  }\n\n  // remove specific handler\n  var cb;\n  for (var i = 0; i < callbacks.length; i++) {\n    cb = callbacks[i];\n    if (cb === fn || cb.fn === fn) {\n      callbacks.splice(i, 1);\n      break;\n    }\n  }\n\n  // Remove event specific arrays for event types that no\n  // one is subscribed for to avoid memory leak.\n  if (callbacks.length === 0) {\n    delete this._callbacks['$' + event];\n  }\n\n  return this;\n};\n\n/**\n * Emit `event` with the given args.\n *\n * @param {String} event\n * @param {Mixed} ...\n * @return {Emitter}\n */\n\nEmitter.prototype.emit = function(event){\n  this._callbacks = this._callbacks || {};\n\n  var args = new Array(arguments.length - 1)\n    , callbacks = this._callbacks['$' + event];\n\n  for (var i = 1; i < arguments.length; i++) {\n    args[i - 1] = arguments[i];\n  }\n\n  if (callbacks) {\n    callbacks = callbacks.slice(0);\n    for (var i = 0, len = callbacks.length; i < len; ++i) {\n      callbacks[i].apply(this, args);\n    }\n  }\n\n  return this;\n};\n\n// alias used for reserved events (protected method)\nEmitter.prototype.emitReserved = Emitter.prototype.emit;\n\n/**\n * Return array of callbacks for `event`.\n *\n * @param {String} event\n * @return {Array}\n * @api public\n */\n\nEmitter.prototype.listeners = function(event){\n  this._callbacks = this._callbacks || {};\n  return this._callbacks['$' + event] || [];\n};\n\n/**\n * Check if this emitter has `event` handlers.\n *\n * @param {String} event\n * @return {Boolean}\n * @api public\n */\n\nEmitter.prototype.hasListeners = function(event){\n  return !! this.listeners(event).length;\n};\n","export const globalThisShim = (() => {\n    if (typeof self !== \"undefined\") {\n        return self;\n    }\n    else if (typeof window !== \"undefined\") {\n        return window;\n    }\n    else {\n        return Function(\"return this\")();\n    }\n})();\n","import { globalThisShim as globalThis } from \"./globalThis.js\";\nexport function pick(obj, ...attr) {\n    return attr.reduce((acc, k) => {\n        if (obj.hasOwnProperty(k)) {\n            acc[k] = obj[k];\n        }\n        return acc;\n    }, {});\n}\n// Keep a reference to the real timeout functions so they can be used when overridden\nconst NATIVE_SET_TIMEOUT = globalThis.setTimeout;\nconst NATIVE_CLEAR_TIMEOUT = globalThis.clearTimeout;\nexport function installTimerFunctions(obj, opts) {\n    if (opts.useNativeTimers) {\n        obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThis);\n        obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThis);\n    }\n    else {\n        obj.setTimeoutFn = globalThis.setTimeout.bind(globalThis);\n        obj.clearTimeoutFn = globalThis.clearTimeout.bind(globalThis);\n    }\n}\n// base64 encoded buffers are about 33% bigger (https://en.wikipedia.org/wiki/Base64)\nconst BASE64_OVERHEAD = 1.33;\n// we could also have used `new Blob([obj]).size`, but it isn't supported in IE9\nexport function byteLength(obj) {\n    if (typeof obj === \"string\") {\n        return utf8Length(obj);\n    }\n    // arraybuffer or blob\n    return Math.ceil((obj.byteLength || obj.size) * BASE64_OVERHEAD);\n}\nfunction utf8Length(str) {\n    let c = 0, length = 0;\n    for (let i = 0, l = str.length; i < l; i++) {\n        c = str.charCodeAt(i);\n        if (c < 0x80) {\n            length += 1;\n        }\n        else if (c < 0x800) {\n            length += 2;\n        }\n        else if (c < 0xd800 || c >= 0xe000) {\n            length += 3;\n        }\n        else {\n            i++;\n            length += 4;\n        }\n    }\n    return length;\n}\n","// imported from https://github.com/galkn/querystring\n/**\n * Compiles a querystring\n * Returns string representation of the object\n *\n * @param {Object}\n * @api private\n */\nexport function encode(obj) {\n    let str = '';\n    for (let i in obj) {\n        if (obj.hasOwnProperty(i)) {\n            if (str.length)\n                str += '&';\n            str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);\n        }\n    }\n    return str;\n}\n/**\n * Parses a simple querystring into an object\n *\n * @param {String} qs\n * @api private\n */\nexport function decode(qs) {\n    let qry = {};\n    let pairs = qs.split('&');\n    for (let i = 0, l = pairs.length; i < l; i++) {\n        let pair = pairs[i].split('=');\n        qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);\n    }\n    return qry;\n}\n","import { decodePacket } from \"engine.io-parser\";\nimport { Emitter } from \"@socket.io/component-emitter\";\nimport { installTimerFunctions } from \"./util.js\";\nimport { encode } from \"./contrib/parseqs.js\";\nclass TransportError extends Error {\n    constructor(reason, description, context) {\n        super(reason);\n        this.description = description;\n        this.context = context;\n        this.type = \"TransportError\";\n    }\n}\nexport class Transport extends Emitter {\n    /**\n     * Transport abstract constructor.\n     *\n     * @param {Object} opts - options\n     * @protected\n     */\n    constructor(opts) {\n        super();\n        this.writable = false;\n        installTimerFunctions(this, opts);\n        this.opts = opts;\n        this.query = opts.query;\n        this.socket = opts.socket;\n    }\n    /**\n     * Emits an error.\n     *\n     * @param {String} reason\n     * @param description\n     * @param context - the error context\n     * @return {Transport} for chaining\n     * @protected\n     */\n    onError(reason, description, context) {\n        super.emitReserved(\"error\", new TransportError(reason, description, context));\n        return this;\n    }\n    /**\n     * Opens the transport.\n     */\n    open() {\n        this.readyState = \"opening\";\n        this.doOpen();\n        return this;\n    }\n    /**\n     * Closes the transport.\n     */\n    close() {\n        if (this.readyState === \"opening\" || this.readyState === \"open\") {\n            this.doClose();\n            this.onClose();\n        }\n        return this;\n    }\n    /**\n     * Sends multiple packets.\n     *\n     * @param {Array} packets\n     */\n    send(packets) {\n        if (this.readyState === \"open\") {\n            this.write(packets);\n        }\n        else {\n            // this might happen if the transport was silently closed in the beforeunload event handler\n        }\n    }\n    /**\n     * Called upon open\n     *\n     * @protected\n     */\n    onOpen() {\n        this.readyState = \"open\";\n        this.writable = true;\n        super.emitReserved(\"open\");\n    }\n    /**\n     * Called with data.\n     *\n     * @param {String} data\n     * @protected\n     */\n    onData(data) {\n        const packet = decodePacket(data, this.socket.binaryType);\n        this.onPacket(packet);\n    }\n    /**\n     * Called with a decoded packet.\n     *\n     * @protected\n     */\n    onPacket(packet) {\n        super.emitReserved(\"packet\", packet);\n    }\n    /**\n     * Called upon close.\n     *\n     * @protected\n     */\n    onClose(details) {\n        this.readyState = \"closed\";\n        super.emitReserved(\"close\", details);\n    }\n    /**\n     * Pauses the transport, in order not to lose packets during an upgrade.\n     *\n     * @param onPause\n     */\n    pause(onPause) { }\n    createUri(schema, query = {}) {\n        return (schema +\n            \"://\" +\n            this._hostname() +\n            this._port() +\n            this.opts.path +\n            this._query(query));\n    }\n    _hostname() {\n        const hostname = this.opts.hostname;\n        return hostname.indexOf(\":\") === -1 ? hostname : \"[\" + hostname + \"]\";\n    }\n    _port() {\n        if (this.opts.port &&\n            ((this.opts.secure && Number(this.opts.port !== 443)) ||\n                (!this.opts.secure && Number(this.opts.port) !== 80))) {\n            return \":\" + this.opts.port;\n        }\n        else {\n            return \"\";\n        }\n    }\n    _query(query) {\n        const encodedQuery = encode(query);\n        return encodedQuery.length ? \"?\" + encodedQuery : \"\";\n    }\n}\n","// imported from https://github.com/unshiftio/yeast\n'use strict';\nconst alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_'.split(''), length = 64, map = {};\nlet seed = 0, i = 0, prev;\n/**\n * Return a string representing the specified number.\n *\n * @param {Number} num The number to convert.\n * @returns {String} The string representation of the number.\n * @api public\n */\nexport function encode(num) {\n    let encoded = '';\n    do {\n        encoded = alphabet[num % length] + encoded;\n        num = Math.floor(num / length);\n    } while (num > 0);\n    return encoded;\n}\n/**\n * Return the integer value specified by the given string.\n *\n * @param {String} str The string to convert.\n * @returns {Number} The integer value represented by the string.\n * @api public\n */\nexport function decode(str) {\n    let decoded = 0;\n    for (i = 0; i < str.length; i++) {\n        decoded = decoded * length + map[str.charAt(i)];\n    }\n    return decoded;\n}\n/**\n * Yeast: A tiny growing id generator.\n *\n * @returns {String} A unique id.\n * @api public\n */\nexport function yeast() {\n    const now = encode(+new Date());\n    if (now !== prev)\n        return seed = 0, prev = now;\n    return now + '.' + encode(seed++);\n}\n//\n// Map each character to its index.\n//\nfor (; i < length; i++)\n    map[alphabet[i]] = i;\n","// imported from https://github.com/component/has-cors\nlet value = false;\ntry {\n    value = typeof XMLHttpRequest !== 'undefined' &&\n        'withCredentials' in new XMLHttpRequest();\n}\ncatch (err) {\n    // if XMLHttp support is disabled in IE then it will throw\n    // when trying to create\n}\nexport const hasCORS = value;\n","// browser shim for xmlhttprequest module\nimport { hasCORS } from \"../contrib/has-cors.js\";\nimport { globalThisShim as globalThis } from \"../globalThis.js\";\nexport function XHR(opts) {\n    const xdomain = opts.xdomain;\n    // XMLHttpRequest can be disabled on IE\n    try {\n        if (\"undefined\" !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {\n            return new XMLHttpRequest();\n        }\n    }\n    catch (e) { }\n    if (!xdomain) {\n        try {\n            return new globalThis[[\"Active\"].concat(\"Object\").join(\"X\")](\"Microsoft.XMLHTTP\");\n        }\n        catch (e) { }\n    }\n}\nexport function createCookieJar() { }\n","import { Transport } from \"../transport.js\";\nimport { yeast } from \"../contrib/yeast.js\";\nimport { encodePayload, decodePayload } from \"engine.io-parser\";\nimport { createCookieJar, XHR as XMLHttpRequest, } from \"./xmlhttprequest.js\";\nimport { Emitter } from \"@socket.io/component-emitter\";\nimport { installTimerFunctions, pick } from \"../util.js\";\nimport { globalThisShim as globalThis } from \"../globalThis.js\";\nfunction empty() { }\nconst hasXHR2 = (function () {\n    const xhr = new XMLHttpRequest({\n        xdomain: false,\n    });\n    return null != xhr.responseType;\n})();\nexport class Polling extends Transport {\n    /**\n     * XHR Polling constructor.\n     *\n     * @param {Object} opts\n     * @package\n     */\n    constructor(opts) {\n        super(opts);\n        this.polling = false;\n        if (typeof location !== \"undefined\") {\n            const isSSL = \"https:\" === location.protocol;\n            let port = location.port;\n            // some user agents have empty `location.port`\n            if (!port) {\n                port = isSSL ? \"443\" : \"80\";\n            }\n            this.xd =\n                (typeof location !== \"undefined\" &&\n                    opts.hostname !== location.hostname) ||\n                    port !== opts.port;\n        }\n        /**\n         * XHR supports binary\n         */\n        const forceBase64 = opts && opts.forceBase64;\n        this.supportsBinary = hasXHR2 && !forceBase64;\n        if (this.opts.withCredentials) {\n            this.cookieJar = createCookieJar();\n        }\n    }\n    get name() {\n        return \"polling\";\n    }\n    /**\n     * Opens the socket (triggers polling). We write a PING message to determine\n     * when the transport is open.\n     *\n     * @protected\n     */\n    doOpen() {\n        this.poll();\n    }\n    /**\n     * Pauses polling.\n     *\n     * @param {Function} onPause - callback upon buffers are flushed and transport is paused\n     * @package\n     */\n    pause(onPause) {\n        this.readyState = \"pausing\";\n        const pause = () => {\n            this.readyState = \"paused\";\n            onPause();\n        };\n        if (this.polling || !this.writable) {\n            let total = 0;\n            if (this.polling) {\n                total++;\n                this.once(\"pollComplete\", function () {\n                    --total || pause();\n                });\n            }\n            if (!this.writable) {\n                total++;\n                this.once(\"drain\", function () {\n                    --total || pause();\n                });\n            }\n        }\n        else {\n            pause();\n        }\n    }\n    /**\n     * Starts polling cycle.\n     *\n     * @private\n     */\n    poll() {\n        this.polling = true;\n        this.doPoll();\n        this.emitReserved(\"poll\");\n    }\n    /**\n     * Overloads onData to detect payloads.\n     *\n     * @protected\n     */\n    onData(data) {\n        const callback = (packet) => {\n            // if its the first message we consider the transport open\n            if (\"opening\" === this.readyState && packet.type === \"open\") {\n                this.onOpen();\n            }\n            // if its a close packet, we close the ongoing requests\n            if (\"close\" === packet.type) {\n                this.onClose({ description: \"transport closed by the server\" });\n                return false;\n            }\n            // otherwise bypass onData and handle the message\n            this.onPacket(packet);\n        };\n        // decode payload\n        decodePayload(data, this.socket.binaryType).forEach(callback);\n        // if an event did not trigger closing\n        if (\"closed\" !== this.readyState) {\n            // if we got data we're not polling\n            this.polling = false;\n            this.emitReserved(\"pollComplete\");\n            if (\"open\" === this.readyState) {\n                this.poll();\n            }\n            else {\n            }\n        }\n    }\n    /**\n     * For polling, send a close packet.\n     *\n     * @protected\n     */\n    doClose() {\n        const close = () => {\n            this.write([{ type: \"close\" }]);\n        };\n        if (\"open\" === this.readyState) {\n            close();\n        }\n        else {\n            // in case we're trying to close while\n            // handshaking is in progress (GH-164)\n            this.once(\"open\", close);\n        }\n    }\n    /**\n     * Writes a packets payload.\n     *\n     * @param {Array} packets - data packets\n     * @protected\n     */\n    write(packets) {\n        this.writable = false;\n        encodePayload(packets, (data) => {\n            this.doWrite(data, () => {\n                this.writable = true;\n                this.emitReserved(\"drain\");\n            });\n        });\n    }\n    /**\n     * Generates uri for connection.\n     *\n     * @private\n     */\n    uri() {\n        const schema = this.opts.secure ? \"https\" : \"http\";\n        const query = this.query || {};\n        // cache busting is forced\n        if (false !== this.opts.timestampRequests) {\n            query[this.opts.timestampParam] = yeast();\n        }\n        if (!this.supportsBinary && !query.sid) {\n            query.b64 = 1;\n        }\n        return this.createUri(schema, query);\n    }\n    /**\n     * Creates a request.\n     *\n     * @param {String} method\n     * @private\n     */\n    request(opts = {}) {\n        Object.assign(opts, { xd: this.xd, cookieJar: this.cookieJar }, this.opts);\n        return new Request(this.uri(), opts);\n    }\n    /**\n     * Sends data.\n     *\n     * @param {String} data to send.\n     * @param {Function} called upon flush.\n     * @private\n     */\n    doWrite(data, fn) {\n        const req = this.request({\n            method: \"POST\",\n            data: data,\n        });\n        req.on(\"success\", fn);\n        req.on(\"error\", (xhrStatus, context) => {\n            this.onError(\"xhr post error\", xhrStatus, context);\n        });\n    }\n    /**\n     * Starts a poll cycle.\n     *\n     * @private\n     */\n    doPoll() {\n        const req = this.request();\n        req.on(\"data\", this.onData.bind(this));\n        req.on(\"error\", (xhrStatus, context) => {\n            this.onError(\"xhr poll error\", xhrStatus, context);\n        });\n        this.pollXhr = req;\n    }\n}\nexport class Request extends Emitter {\n    /**\n     * Request constructor\n     *\n     * @param {Object} options\n     * @package\n     */\n    constructor(uri, opts) {\n        super();\n        installTimerFunctions(this, opts);\n        this.opts = opts;\n        this.method = opts.method || \"GET\";\n        this.uri = uri;\n        this.data = undefined !== opts.data ? opts.data : null;\n        this.create();\n    }\n    /**\n     * Creates the XHR object and sends the request.\n     *\n     * @private\n     */\n    create() {\n        var _a;\n        const opts = pick(this.opts, \"agent\", \"pfx\", \"key\", \"passphrase\", \"cert\", \"ca\", \"ciphers\", \"rejectUnauthorized\", \"autoUnref\");\n        opts.xdomain = !!this.opts.xd;\n        const xhr = (this.xhr = new XMLHttpRequest(opts));\n        try {\n            xhr.open(this.method, this.uri, true);\n            try {\n                if (this.opts.extraHeaders) {\n                    xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);\n                    for (let i in this.opts.extraHeaders) {\n                        if (this.opts.extraHeaders.hasOwnProperty(i)) {\n                            xhr.setRequestHeader(i, this.opts.extraHeaders[i]);\n                        }\n                    }\n                }\n            }\n            catch (e) { }\n            if (\"POST\" === this.method) {\n                try {\n                    xhr.setRequestHeader(\"Content-type\", \"text/plain;charset=UTF-8\");\n                }\n                catch (e) { }\n            }\n            try {\n                xhr.setRequestHeader(\"Accept\", \"*/*\");\n            }\n            catch (e) { }\n            (_a = this.opts.cookieJar) === null || _a === void 0 ? void 0 : _a.addCookies(xhr);\n            // ie6 check\n            if (\"withCredentials\" in xhr) {\n                xhr.withCredentials = this.opts.withCredentials;\n            }\n            if (this.opts.requestTimeout) {\n                xhr.timeout = this.opts.requestTimeout;\n            }\n            xhr.onreadystatechange = () => {\n                var _a;\n                if (xhr.readyState === 3) {\n                    (_a = this.opts.cookieJar) === null || _a === void 0 ? void 0 : _a.parseCookies(xhr);\n                }\n                if (4 !== xhr.readyState)\n                    return;\n                if (200 === xhr.status || 1223 === xhr.status) {\n                    this.onLoad();\n                }\n                else {\n                    // make sure the `error` event handler that's user-set\n                    // does not throw in the same tick and gets caught here\n                    this.setTimeoutFn(() => {\n                        this.onError(typeof xhr.status === \"number\" ? xhr.status : 0);\n                    }, 0);\n                }\n            };\n            xhr.send(this.data);\n        }\n        catch (e) {\n            // Need to defer since .create() is called directly from the constructor\n            // and thus the 'error' event can only be only bound *after* this exception\n            // occurs.  Therefore, also, we cannot throw here at all.\n            this.setTimeoutFn(() => {\n                this.onError(e);\n            }, 0);\n            return;\n        }\n        if (typeof document !== \"undefined\") {\n            this.index = Request.requestsCount++;\n            Request.requests[this.index] = this;\n        }\n    }\n    /**\n     * Called upon error.\n     *\n     * @private\n     */\n    onError(err) {\n        this.emitReserved(\"error\", err, this.xhr);\n        this.cleanup(true);\n    }\n    /**\n     * Cleans up house.\n     *\n     * @private\n     */\n    cleanup(fromError) {\n        if (\"undefined\" === typeof this.xhr || null === this.xhr) {\n            return;\n        }\n        this.xhr.onreadystatechange = empty;\n        if (fromError) {\n            try {\n                this.xhr.abort();\n            }\n            catch (e) { }\n        }\n        if (typeof document !== \"undefined\") {\n            delete Request.requests[this.index];\n        }\n        this.xhr = null;\n    }\n    /**\n     * Called upon load.\n     *\n     * @private\n     */\n    onLoad() {\n        const data = this.xhr.responseText;\n        if (data !== null) {\n            this.emitReserved(\"data\", data);\n            this.emitReserved(\"success\");\n            this.cleanup();\n        }\n    }\n    /**\n     * Aborts the request.\n     *\n     * @package\n     */\n    abort() {\n        this.cleanup();\n    }\n}\nRequest.requestsCount = 0;\nRequest.requests = {};\n/**\n * Aborts pending requests when unloading the window. This is needed to prevent\n * memory leaks (e.g. when using IE) and to ensure that no spurious error is\n * emitted.\n */\nif (typeof document !== \"undefined\") {\n    // @ts-ignore\n    if (typeof attachEvent === \"function\") {\n        // @ts-ignore\n        attachEvent(\"onunload\", unloadHandler);\n    }\n    else if (typeof addEventListener === \"function\") {\n        const terminationEvent = \"onpagehide\" in globalThis ? \"pagehide\" : \"unload\";\n        addEventListener(terminationEvent, unloadHandler, false);\n    }\n}\nfunction unloadHandler() {\n    for (let i in Request.requests) {\n        if (Request.requests.hasOwnProperty(i)) {\n            Request.requests[i].abort();\n        }\n    }\n}\n","import { globalThisShim as globalThis } from \"../globalThis.js\";\nexport const nextTick = (() => {\n    const isPromiseAvailable = typeof Promise === \"function\" && typeof Promise.resolve === \"function\";\n    if (isPromiseAvailable) {\n        return (cb) => Promise.resolve().then(cb);\n    }\n    else {\n        return (cb, setTimeoutFn) => setTimeoutFn(cb, 0);\n    }\n})();\nexport const WebSocket = globalThis.WebSocket || globalThis.MozWebSocket;\nexport const usingBrowserWebSocket = true;\nexport const defaultBinaryType = \"arraybuffer\";\n","import { Transport } from \"../transport.js\";\nimport { yeast } from \"../contrib/yeast.js\";\nimport { pick } from \"../util.js\";\nimport { nextTick, usingBrowserWebSocket, WebSocket, } from \"./websocket-constructor.js\";\nimport { encodePacket } from \"engine.io-parser\";\n// detect ReactNative environment\nconst isReactNative = typeof navigator !== \"undefined\" &&\n    typeof navigator.product === \"string\" &&\n    navigator.product.toLowerCase() === \"reactnative\";\nexport class WS extends Transport {\n    /**\n     * WebSocket transport constructor.\n     *\n     * @param {Object} opts - connection options\n     * @protected\n     */\n    constructor(opts) {\n        super(opts);\n        this.supportsBinary = !opts.forceBase64;\n    }\n    get name() {\n        return \"websocket\";\n    }\n    doOpen() {\n        if (!this.check()) {\n            // let probe timeout\n            return;\n        }\n        const uri = this.uri();\n        const protocols = this.opts.protocols;\n        // React Native only supports the 'headers' option, and will print a warning if anything else is passed\n        const opts = isReactNative\n            ? {}\n            : pick(this.opts, \"agent\", \"perMessageDeflate\", \"pfx\", \"key\", \"passphrase\", \"cert\", \"ca\", \"ciphers\", \"rejectUnauthorized\", \"localAddress\", \"protocolVersion\", \"origin\", \"maxPayload\", \"family\", \"checkServerIdentity\");\n        if (this.opts.extraHeaders) {\n            opts.headers = this.opts.extraHeaders;\n        }\n        try {\n            this.ws =\n                usingBrowserWebSocket && !isReactNative\n                    ? protocols\n                        ? new WebSocket(uri, protocols)\n                        : new WebSocket(uri)\n                    : new WebSocket(uri, protocols, opts);\n        }\n        catch (err) {\n            return this.emitReserved(\"error\", err);\n        }\n        this.ws.binaryType = this.socket.binaryType;\n        this.addEventListeners();\n    }\n    /**\n     * Adds event listeners to the socket\n     *\n     * @private\n     */\n    addEventListeners() {\n        this.ws.onopen = () => {\n            if (this.opts.autoUnref) {\n                this.ws._socket.unref();\n            }\n            this.onOpen();\n        };\n        this.ws.onclose = (closeEvent) => this.onClose({\n            description: \"websocket connection closed\",\n            context: closeEvent,\n        });\n        this.ws.onmessage = (ev) => this.onData(ev.data);\n        this.ws.onerror = (e) => this.onError(\"websocket error\", e);\n    }\n    write(packets) {\n        this.writable = false;\n        // encodePacket efficient as it uses WS framing\n        // no need for encodePayload\n        for (let i = 0; i < packets.length; i++) {\n            const packet = packets[i];\n            const lastPacket = i === packets.length - 1;\n            encodePacket(packet, this.supportsBinary, (data) => {\n                // always create a new object (GH-437)\n                const opts = {};\n                if (!usingBrowserWebSocket) {\n                    if (packet.options) {\n                        opts.compress = packet.options.compress;\n                    }\n                    if (this.opts.perMessageDeflate) {\n                        const len = \n                        // @ts-ignore\n                        \"string\" === typeof data ? Buffer.byteLength(data) : data.length;\n                        if (len < this.opts.perMessageDeflate.threshold) {\n                            opts.compress = false;\n                        }\n                    }\n                }\n                // Sometimes the websocket has already been closed but the browser didn't\n                // have a chance of informing us about it yet, in that case send will\n                // throw an error\n                try {\n                    if (usingBrowserWebSocket) {\n                        // TypeError is thrown when passing the second argument on Safari\n                        this.ws.send(data);\n                    }\n                    else {\n                        this.ws.send(data, opts);\n                    }\n                }\n                catch (e) {\n                }\n                if (lastPacket) {\n                    // fake drain\n                    // defer to next tick to allow Socket to clear writeBuffer\n                    nextTick(() => {\n                        this.writable = true;\n                        this.emitReserved(\"drain\");\n                    }, this.setTimeoutFn);\n                }\n            });\n        }\n    }\n    doClose() {\n        if (typeof this.ws !== \"undefined\") {\n            this.ws.close();\n            this.ws = null;\n        }\n    }\n    /**\n     * Generates uri for connection.\n     *\n     * @private\n     */\n    uri() {\n        const schema = this.opts.secure ? \"wss\" : \"ws\";\n        const query = this.query || {};\n        // append timestamp to URI\n        if (this.opts.timestampRequests) {\n            query[this.opts.timestampParam] = yeast();\n        }\n        // communicate binary support capabilities\n        if (!this.supportsBinary) {\n            query.b64 = 1;\n        }\n        return this.createUri(schema, query);\n    }\n    /**\n     * Feature detection for WebSocket.\n     *\n     * @return {Boolean} whether this transport is available.\n     * @private\n     */\n    check() {\n        return !!WebSocket;\n    }\n}\n","import { Transport } from \"../transport.js\";\nimport { nextTick } from \"./websocket-constructor.js\";\nimport { createPacketDecoderStream, createPacketEncoderStream, } from \"engine.io-parser\";\nexport class WT extends Transport {\n    get name() {\n        return \"webtransport\";\n    }\n    doOpen() {\n        // @ts-ignore\n        if (typeof WebTransport !== \"function\") {\n            return;\n        }\n        // @ts-ignore\n        this.transport = new WebTransport(this.createUri(\"https\"), this.opts.transportOptions[this.name]);\n        this.transport.closed\n            .then(() => {\n            this.onClose();\n        })\n            .catch((err) => {\n            this.onError(\"webtransport error\", err);\n        });\n        // note: we could have used async/await, but that would require some additional polyfills\n        this.transport.ready.then(() => {\n            this.transport.createBidirectionalStream().then((stream) => {\n                const decoderStream = createPacketDecoderStream(Number.MAX_SAFE_INTEGER, this.socket.binaryType);\n                const reader = stream.readable.pipeThrough(decoderStream).getReader();\n                const encoderStream = createPacketEncoderStream();\n                encoderStream.readable.pipeTo(stream.writable);\n                this.writer = encoderStream.writable.getWriter();\n                const read = () => {\n                    reader\n                        .read()\n                        .then(({ done, value }) => {\n                        if (done) {\n                            return;\n                        }\n                        this.onPacket(value);\n                        read();\n                    })\n                        .catch((err) => {\n                    });\n                };\n                read();\n                const packet = { type: \"open\" };\n                if (this.query.sid) {\n                    packet.data = `{\"sid\":\"${this.query.sid}\"}`;\n                }\n                this.writer.write(packet).then(() => this.onOpen());\n            });\n        });\n    }\n    write(packets) {\n        this.writable = false;\n        for (let i = 0; i < packets.length; i++) {\n            const packet = packets[i];\n            const lastPacket = i === packets.length - 1;\n            this.writer.write(packet).then(() => {\n                if (lastPacket) {\n                    nextTick(() => {\n                        this.writable = true;\n                        this.emitReserved(\"drain\");\n                    }, this.setTimeoutFn);\n                }\n            });\n        }\n    }\n    doClose() {\n        var _a;\n        (_a = this.transport) === null || _a === void 0 ? void 0 : _a.close();\n    }\n}\n","import { Polling } from \"./polling.js\";\nimport { WS } from \"./websocket.js\";\nimport { WT } from \"./webtransport.js\";\nexport const transports = {\n    websocket: WS,\n    webtransport: WT,\n    polling: Polling,\n};\n","// imported from https://github.com/galkn/parseuri\n/**\n * Parses a URI\n *\n * Note: we could also have used the built-in URL object, but it isn't supported on all platforms.\n *\n * See:\n * - https://developer.mozilla.org/en-US/docs/Web/API/URL\n * - https://caniuse.com/url\n * - https://www.rfc-editor.org/rfc/rfc3986#appendix-B\n *\n * History of the parse() method:\n * - first commit: https://github.com/socketio/socket.io-client/commit/4ee1d5d94b3906a9c052b459f1a818b15f38f91c\n * - export into its own module: https://github.com/socketio/engine.io-client/commit/de2c561e4564efeb78f1bdb1ba39ef81b2822cb3\n * - reimport: https://github.com/socketio/engine.io-client/commit/df32277c3f6d622eec5ed09f493cae3f3391d242\n *\n * @author Steven Levithan <stevenlevithan.com> (MIT license)\n * @api private\n */\nconst re = /^(?:(?![^:@\\/?#]+:[^:@\\/]*@)(http|https|ws|wss):\\/\\/)?((?:(([^:@\\/?#]*)(?::([^:@\\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\nconst parts = [\n    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host', 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'\n];\nexport function parse(str) {\n    const src = str, b = str.indexOf('['), e = str.indexOf(']');\n    if (b != -1 && e != -1) {\n        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ';') + str.substring(e, str.length);\n    }\n    let m = re.exec(str || ''), uri = {}, i = 14;\n    while (i--) {\n        uri[parts[i]] = m[i] || '';\n    }\n    if (b != -1 && e != -1) {\n        uri.source = src;\n        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ':');\n        uri.authority = uri.authority.replace('[', '').replace(']', '').replace(/;/g, ':');\n        uri.ipv6uri = true;\n    }\n    uri.pathNames = pathNames(uri, uri['path']);\n    uri.queryKey = queryKey(uri, uri['query']);\n    return uri;\n}\nfunction pathNames(obj, path) {\n    const regx = /\\/{2,9}/g, names = path.replace(regx, \"/\").split(\"/\");\n    if (path.slice(0, 1) == '/' || path.length === 0) {\n        names.splice(0, 1);\n    }\n    if (path.slice(-1) == '/') {\n        names.splice(names.length - 1, 1);\n    }\n    return names;\n}\nfunction queryKey(uri, query) {\n    const data = {};\n    query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function ($0, $1, $2) {\n        if ($1) {\n            data[$1] = $2;\n        }\n    });\n    return data;\n}\n","import { transports } from \"./transports/index.js\";\nimport { installTimerFunctions, byteLength } from \"./util.js\";\nimport { decode } from \"./contrib/parseqs.js\";\nimport { parse } from \"./contrib/parseuri.js\";\nimport { Emitter } from \"@socket.io/component-emitter\";\nimport { protocol } from \"engine.io-parser\";\nimport { defaultBinaryType } from \"./transports/websocket-constructor.js\";\nexport class Socket extends Emitter {\n    /**\n     * Socket constructor.\n     *\n     * @param {String|Object} uri - uri or options\n     * @param {Object} opts - options\n     */\n    constructor(uri, opts = {}) {\n        super();\n        this.binaryType = defaultBinaryType;\n        this.writeBuffer = [];\n        if (uri && \"object\" === typeof uri) {\n            opts = uri;\n            uri = null;\n        }\n        if (uri) {\n            uri = parse(uri);\n            opts.hostname = uri.host;\n            opts.secure = uri.protocol === \"https\" || uri.protocol === \"wss\";\n            opts.port = uri.port;\n            if (uri.query)\n                opts.query = uri.query;\n        }\n        else if (opts.host) {\n            opts.hostname = parse(opts.host).host;\n        }\n        installTimerFunctions(this, opts);\n        this.secure =\n            null != opts.secure\n                ? opts.secure\n                : typeof location !== \"undefined\" && \"https:\" === location.protocol;\n        if (opts.hostname && !opts.port) {\n            // if no port is specified manually, use the protocol default\n            opts.port = this.secure ? \"443\" : \"80\";\n        }\n        this.hostname =\n            opts.hostname ||\n                (typeof location !== \"undefined\" ? location.hostname : \"localhost\");\n        this.port =\n            opts.port ||\n                (typeof location !== \"undefined\" && location.port\n                    ? location.port\n                    : this.secure\n                        ? \"443\"\n                        : \"80\");\n        this.transports = opts.transports || [\n            \"polling\",\n            \"websocket\",\n            \"webtransport\",\n        ];\n        this.writeBuffer = [];\n        this.prevBufferLen = 0;\n        this.opts = Object.assign({\n            path: \"/engine.io\",\n            agent: false,\n            withCredentials: false,\n            upgrade: true,\n            timestampParam: \"t\",\n            rememberUpgrade: false,\n            addTrailingSlash: true,\n            rejectUnauthorized: true,\n            perMessageDeflate: {\n                threshold: 1024,\n            },\n            transportOptions: {},\n            closeOnBeforeunload: false,\n        }, opts);\n        this.opts.path =\n            this.opts.path.replace(/\\/$/, \"\") +\n                (this.opts.addTrailingSlash ? \"/\" : \"\");\n        if (typeof this.opts.query === \"string\") {\n            this.opts.query = decode(this.opts.query);\n        }\n        // set on handshake\n        this.id = null;\n        this.upgrades = null;\n        this.pingInterval = null;\n        this.pingTimeout = null;\n        // set on heartbeat\n        this.pingTimeoutTimer = null;\n        if (typeof addEventListener === \"function\") {\n            if (this.opts.closeOnBeforeunload) {\n                // Firefox closes the connection when the \"beforeunload\" event is emitted but not Chrome. This event listener\n                // ensures every browser behaves the same (no \"disconnect\" event at the Socket.IO level when the page is\n                // closed/reloaded)\n                this.beforeunloadEventListener = () => {\n                    if (this.transport) {\n                        // silently close the transport\n                        this.transport.removeAllListeners();\n                        this.transport.close();\n                    }\n                };\n                addEventListener(\"beforeunload\", this.beforeunloadEventListener, false);\n            }\n            if (this.hostname !== \"localhost\") {\n                this.offlineEventListener = () => {\n                    this.onClose(\"transport close\", {\n                        description: \"network connection lost\",\n                    });\n                };\n                addEventListener(\"offline\", this.offlineEventListener, false);\n            }\n        }\n        this.open();\n    }\n    /**\n     * Creates transport of the given type.\n     *\n     * @param {String} name - transport name\n     * @return {Transport}\n     * @private\n     */\n    createTransport(name) {\n        const query = Object.assign({}, this.opts.query);\n        // append engine.io protocol identifier\n        query.EIO = protocol;\n        // transport name\n        query.transport = name;\n        // session id if we already have one\n        if (this.id)\n            query.sid = this.id;\n        const opts = Object.assign({}, this.opts, {\n            query,\n            socket: this,\n            hostname: this.hostname,\n            secure: this.secure,\n            port: this.port,\n        }, this.opts.transportOptions[name]);\n        return new transports[name](opts);\n    }\n    /**\n     * Initializes transport to use and starts probe.\n     *\n     * @private\n     */\n    open() {\n        let transport;\n        if (this.opts.rememberUpgrade &&\n            Socket.priorWebsocketSuccess &&\n            this.transports.indexOf(\"websocket\") !== -1) {\n            transport = \"websocket\";\n        }\n        else if (0 === this.transports.length) {\n            // Emit error on next tick so it can be listened to\n            this.setTimeoutFn(() => {\n                this.emitReserved(\"error\", \"No transports available\");\n            }, 0);\n            return;\n        }\n        else {\n            transport = this.transports[0];\n        }\n        this.readyState = \"opening\";\n        // Retry with the next transport if the transport is disabled (jsonp: false)\n        try {\n            transport = this.createTransport(transport);\n        }\n        catch (e) {\n            this.transports.shift();\n            this.open();\n            return;\n        }\n        transport.open();\n        this.setTransport(transport);\n    }\n    /**\n     * Sets the current transport. Disables the existing one (if any).\n     *\n     * @private\n     */\n    setTransport(transport) {\n        if (this.transport) {\n            this.transport.removeAllListeners();\n        }\n        // set up transport\n        this.transport = transport;\n        // set up transport listeners\n        transport\n            .on(\"drain\", this.onDrain.bind(this))\n            .on(\"packet\", this.onPacket.bind(this))\n            .on(\"error\", this.onError.bind(this))\n            .on(\"close\", (reason) => this.onClose(\"transport close\", reason));\n    }\n    /**\n     * Probes a transport.\n     *\n     * @param {String} name - transport name\n     * @private\n     */\n    probe(name) {\n        let transport = this.createTransport(name);\n        let failed = false;\n        Socket.priorWebsocketSuccess = false;\n        const onTransportOpen = () => {\n            if (failed)\n                return;\n            transport.send([{ type: \"ping\", data: \"probe\" }]);\n            transport.once(\"packet\", (msg) => {\n                if (failed)\n                    return;\n                if (\"pong\" === msg.type && \"probe\" === msg.data) {\n                    this.upgrading = true;\n                    this.emitReserved(\"upgrading\", transport);\n                    if (!transport)\n                        return;\n                    Socket.priorWebsocketSuccess = \"websocket\" === transport.name;\n                    this.transport.pause(() => {\n                        if (failed)\n                            return;\n                        if (\"closed\" === this.readyState)\n                            return;\n                        cleanup();\n                        this.setTransport(transport);\n                        transport.send([{ type: \"upgrade\" }]);\n                        this.emitReserved(\"upgrade\", transport);\n                        transport = null;\n                        this.upgrading = false;\n                        this.flush();\n                    });\n                }\n                else {\n                    const err = new Error(\"probe error\");\n                    // @ts-ignore\n                    err.transport = transport.name;\n                    this.emitReserved(\"upgradeError\", err);\n                }\n            });\n        };\n        function freezeTransport() {\n            if (failed)\n                return;\n            // Any callback called by transport should be ignored since now\n            failed = true;\n            cleanup();\n            transport.close();\n            transport = null;\n        }\n        // Handle any error that happens while probing\n        const onerror = (err) => {\n            const error = new Error(\"probe error: \" + err);\n            // @ts-ignore\n            error.transport = transport.name;\n            freezeTransport();\n            this.emitReserved(\"upgradeError\", error);\n        };\n        function onTransportClose() {\n            onerror(\"transport closed\");\n        }\n        // When the socket is closed while we're probing\n        function onclose() {\n            onerror(\"socket closed\");\n        }\n        // When the socket is upgraded while we're probing\n        function onupgrade(to) {\n            if (transport && to.name !== transport.name) {\n                freezeTransport();\n            }\n        }\n        // Remove all listeners on the transport and on self\n        const cleanup = () => {\n            transport.removeListener(\"open\", onTransportOpen);\n            transport.removeListener(\"error\", onerror);\n            transport.removeListener(\"close\", onTransportClose);\n            this.off(\"close\", onclose);\n            this.off(\"upgrading\", onupgrade);\n        };\n        transport.once(\"open\", onTransportOpen);\n        transport.once(\"error\", onerror);\n        transport.once(\"close\", onTransportClose);\n        this.once(\"close\", onclose);\n        this.once(\"upgrading\", onupgrade);\n        if (this.upgrades.indexOf(\"webtransport\") !== -1 &&\n            name !== \"webtransport\") {\n            // favor WebTransport\n            this.setTimeoutFn(() => {\n                if (!failed) {\n                    transport.open();\n                }\n            }, 200);\n        }\n        else {\n            transport.open();\n        }\n    }\n    /**\n     * Called when connection is deemed open.\n     *\n     * @private\n     */\n    onOpen() {\n        this.readyState = \"open\";\n        Socket.priorWebsocketSuccess = \"websocket\" === this.transport.name;\n        this.emitReserved(\"open\");\n        this.flush();\n        // we check for `readyState` in case an `open`\n        // listener already closed the socket\n        if (\"open\" === this.readyState && this.opts.upgrade) {\n            let i = 0;\n            const l = this.upgrades.length;\n            for (; i < l; i++) {\n                this.probe(this.upgrades[i]);\n            }\n        }\n    }\n    /**\n     * Handles a packet.\n     *\n     * @private\n     */\n    onPacket(packet) {\n        if (\"opening\" === this.readyState ||\n            \"open\" === this.readyState ||\n            \"closing\" === this.readyState) {\n            this.emitReserved(\"packet\", packet);\n            // Socket is live - any packet counts\n            this.emitReserved(\"heartbeat\");\n            this.resetPingTimeout();\n            switch (packet.type) {\n                case \"open\":\n                    this.onHandshake(JSON.parse(packet.data));\n                    break;\n                case \"ping\":\n                    this.sendPacket(\"pong\");\n                    this.emitReserved(\"ping\");\n                    this.emitReserved(\"pong\");\n                    break;\n                case \"error\":\n                    const err = new Error(\"server error\");\n                    // @ts-ignore\n                    err.code = packet.data;\n                    this.onError(err);\n                    break;\n                case \"message\":\n                    this.emitReserved(\"data\", packet.data);\n                    this.emitReserved(\"message\", packet.data);\n                    break;\n            }\n        }\n        else {\n        }\n    }\n    /**\n     * Called upon handshake completion.\n     *\n     * @param {Object} data - handshake obj\n     * @private\n     */\n    onHandshake(data) {\n        this.emitReserved(\"handshake\", data);\n        this.id = data.sid;\n        this.transport.query.sid = data.sid;\n        this.upgrades = this.filterUpgrades(data.upgrades);\n        this.pingInterval = data.pingInterval;\n        this.pingTimeout = data.pingTimeout;\n        this.maxPayload = data.maxPayload;\n        this.onOpen();\n        // In case open handler closes socket\n        if (\"closed\" === this.readyState)\n            return;\n        this.resetPingTimeout();\n    }\n    /**\n     * Sets and resets ping timeout timer based on server pings.\n     *\n     * @private\n     */\n    resetPingTimeout() {\n        this.clearTimeoutFn(this.pingTimeoutTimer);\n        this.pingTimeoutTimer = this.setTimeoutFn(() => {\n            this.onClose(\"ping timeout\");\n        }, this.pingInterval + this.pingTimeout);\n        if (this.opts.autoUnref) {\n            this.pingTimeoutTimer.unref();\n        }\n    }\n    /**\n     * Called on `drain` event\n     *\n     * @private\n     */\n    onDrain() {\n        this.writeBuffer.splice(0, this.prevBufferLen);\n        // setting prevBufferLen = 0 is very important\n        // for example, when upgrading, upgrade packet is sent over,\n        // and a nonzero prevBufferLen could cause problems on `drain`\n        this.prevBufferLen = 0;\n        if (0 === this.writeBuffer.length) {\n            this.emitReserved(\"drain\");\n        }\n        else {\n            this.flush();\n        }\n    }\n    /**\n     * Flush write buffers.\n     *\n     * @private\n     */\n    flush() {\n        if (\"closed\" !== this.readyState &&\n            this.transport.writable &&\n            !this.upgrading &&\n            this.writeBuffer.length) {\n            const packets = this.getWritablePackets();\n            this.transport.send(packets);\n            // keep track of current length of writeBuffer\n            // splice writeBuffer and callbackBuffer on `drain`\n            this.prevBufferLen = packets.length;\n            this.emitReserved(\"flush\");\n        }\n    }\n    /**\n     * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP\n     * long-polling)\n     *\n     * @private\n     */\n    getWritablePackets() {\n        const shouldCheckPayloadSize = this.maxPayload &&\n            this.transport.name === \"polling\" &&\n            this.writeBuffer.length > 1;\n        if (!shouldCheckPayloadSize) {\n            return this.writeBuffer;\n        }\n        let payloadSize = 1; // first packet type\n        for (let i = 0; i < this.writeBuffer.length; i++) {\n            const data = this.writeBuffer[i].data;\n            if (data) {\n                payloadSize += byteLength(data);\n            }\n            if (i > 0 && payloadSize > this.maxPayload) {\n                return this.writeBuffer.slice(0, i);\n            }\n            payloadSize += 2; // separator + packet type\n        }\n        return this.writeBuffer;\n    }\n    /**\n     * Sends a message.\n     *\n     * @param {String} msg - message.\n     * @param {Object} options.\n     * @param {Function} callback function.\n     * @return {Socket} for chaining.\n     */\n    write(msg, options, fn) {\n        this.sendPacket(\"message\", msg, options, fn);\n        return this;\n    }\n    send(msg, options, fn) {\n        this.sendPacket(\"message\", msg, options, fn);\n        return this;\n    }\n    /**\n     * Sends a packet.\n     *\n     * @param {String} type: packet type.\n     * @param {String} data.\n     * @param {Object} options.\n     * @param {Function} fn - callback function.\n     * @private\n     */\n    sendPacket(type, data, options, fn) {\n        if (\"function\" === typeof data) {\n            fn = data;\n            data = undefined;\n        }\n        if (\"function\" === typeof options) {\n            fn = options;\n            options = null;\n        }\n        if (\"closing\" === this.readyState || \"closed\" === this.readyState) {\n            return;\n        }\n        options = options || {};\n        options.compress = false !== options.compress;\n        const packet = {\n            type: type,\n            data: data,\n            options: options,\n        };\n        this.emitReserved(\"packetCreate\", packet);\n        this.writeBuffer.push(packet);\n        if (fn)\n            this.once(\"flush\", fn);\n        this.flush();\n    }\n    /**\n     * Closes the connection.\n     */\n    close() {\n        const close = () => {\n            this.onClose(\"forced close\");\n            this.transport.close();\n        };\n        const cleanupAndClose = () => {\n            this.off(\"upgrade\", cleanupAndClose);\n            this.off(\"upgradeError\", cleanupAndClose);\n            close();\n        };\n        const waitForUpgrade = () => {\n            // wait for upgrade to finish since we can't send packets while pausing a transport\n            this.once(\"upgrade\", cleanupAndClose);\n            this.once(\"upgradeError\", cleanupAndClose);\n        };\n        if (\"opening\" === this.readyState || \"open\" === this.readyState) {\n            this.readyState = \"closing\";\n            if (this.writeBuffer.length) {\n                this.once(\"drain\", () => {\n                    if (this.upgrading) {\n                        waitForUpgrade();\n                    }\n                    else {\n                        close();\n                    }\n                });\n            }\n            else if (this.upgrading) {\n                waitForUpgrade();\n            }\n            else {\n                close();\n            }\n        }\n        return this;\n    }\n    /**\n     * Called upon transport error\n     *\n     * @private\n     */\n    onError(err) {\n        Socket.priorWebsocketSuccess = false;\n        this.emitReserved(\"error\", err);\n        this.onClose(\"transport error\", err);\n    }\n    /**\n     * Called upon transport close.\n     *\n     * @private\n     */\n    onClose(reason, description) {\n        if (\"opening\" === this.readyState ||\n            \"open\" === this.readyState ||\n            \"closing\" === this.readyState) {\n            // clear timers\n            this.clearTimeoutFn(this.pingTimeoutTimer);\n            // stop event from firing again for transport\n            this.transport.removeAllListeners(\"close\");\n            // ensure transport won't stay open\n            this.transport.close();\n            // ignore further transport communication\n            this.transport.removeAllListeners();\n            if (typeof removeEventListener === \"function\") {\n                removeEventListener(\"beforeunload\", this.beforeunloadEventListener, false);\n                removeEventListener(\"offline\", this.offlineEventListener, false);\n            }\n            // set ready state\n            this.readyState = \"closed\";\n            // clear session id\n            this.id = null;\n            // emit close event\n            this.emitReserved(\"close\", reason, description);\n            // clean buffers after, so users can still\n            // grab the buffers on `close` event\n            this.writeBuffer = [];\n            this.prevBufferLen = 0;\n        }\n    }\n    /**\n     * Filters upgrades, returning only those matching client transports.\n     *\n     * @param {Array} upgrades - server upgrades\n     * @private\n     */\n    filterUpgrades(upgrades) {\n        const filteredUpgrades = [];\n        let i = 0;\n        const j = upgrades.length;\n        for (; i < j; i++) {\n            if (~this.transports.indexOf(upgrades[i]))\n                filteredUpgrades.push(upgrades[i]);\n        }\n        return filteredUpgrades;\n    }\n}\nSocket.protocol = protocol;\n","import { Socket } from \"./socket.js\";\nexport { Socket };\nexport const protocol = Socket.protocol;\nexport { Transport } from \"./transport.js\";\nexport { transports } from \"./transports/index.js\";\nexport { installTimerFunctions } from \"./util.js\";\nexport { parse } from \"./contrib/parseuri.js\";\nexport { nextTick } from \"./transports/websocket-constructor.js\";\n","import { parse } from \"engine.io-client\";\n/**\n * URL parser.\n *\n * @param uri - url\n * @param path - the request path of the connection\n * @param loc - An object meant to mimic window.location.\n *        Defaults to window.location.\n * @public\n */\nexport function url(uri, path = \"\", loc) {\n    let obj = uri;\n    // default to window.location\n    loc = loc || (typeof location !== \"undefined\" && location);\n    if (null == uri)\n        uri = loc.protocol + \"//\" + loc.host;\n    // relative path support\n    if (typeof uri === \"string\") {\n        if (\"/\" === uri.charAt(0)) {\n            if (\"/\" === uri.charAt(1)) {\n                uri = loc.protocol + uri;\n            }\n            else {\n                uri = loc.host + uri;\n            }\n        }\n        if (!/^(https?|wss?):\\/\\//.test(uri)) {\n            if (\"undefined\" !== typeof loc) {\n                uri = loc.protocol + \"//\" + uri;\n            }\n            else {\n                uri = \"https://\" + uri;\n            }\n        }\n        // parse\n        obj = parse(uri);\n    }\n    // make sure we treat `localhost:80` and `localhost` equally\n    if (!obj.port) {\n        if (/^(http|ws)$/.test(obj.protocol)) {\n            obj.port = \"80\";\n        }\n        else if (/^(http|ws)s$/.test(obj.protocol)) {\n            obj.port = \"443\";\n        }\n    }\n    obj.path = obj.path || \"/\";\n    const ipv6 = obj.host.indexOf(\":\") !== -1;\n    const host = ipv6 ? \"[\" + obj.host + \"]\" : obj.host;\n    // define unique id\n    obj.id = obj.protocol + \"://\" + host + \":\" + obj.port + path;\n    // define href\n    obj.href =\n        obj.protocol +\n            \"://\" +\n            host +\n            (loc && loc.port === obj.port ? \"\" : \":\" + obj.port);\n    return obj;\n}\n","const withNativeArrayBuffer = typeof ArrayBuffer === \"function\";\nconst isView = (obj) => {\n    return typeof ArrayBuffer.isView === \"function\"\n        ? ArrayBuffer.isView(obj)\n        : obj.buffer instanceof ArrayBuffer;\n};\nconst toString = Object.prototype.toString;\nconst withNativeBlob = typeof Blob === \"function\" ||\n    (typeof Blob !== \"undefined\" &&\n        toString.call(Blob) === \"[object BlobConstructor]\");\nconst withNativeFile = typeof File === \"function\" ||\n    (typeof File !== \"undefined\" &&\n        toString.call(File) === \"[object FileConstructor]\");\n/**\n * Returns true if obj is a Buffer, an ArrayBuffer, a Blob or a File.\n *\n * @private\n */\nexport function isBinary(obj) {\n    return ((withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj))) ||\n        (withNativeBlob && obj instanceof Blob) ||\n        (withNativeFile && obj instanceof File));\n}\nexport function hasBinary(obj, toJSON) {\n    if (!obj || typeof obj !== \"object\") {\n        return false;\n    }\n    if (Array.isArray(obj)) {\n        for (let i = 0, l = obj.length; i < l; i++) {\n            if (hasBinary(obj[i])) {\n                return true;\n            }\n        }\n        return false;\n    }\n    if (isBinary(obj)) {\n        return true;\n    }\n    if (obj.toJSON &&\n        typeof obj.toJSON === \"function\" &&\n        arguments.length === 1) {\n        return hasBinary(obj.toJSON(), true);\n    }\n    for (const key in obj) {\n        if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {\n            return true;\n        }\n    }\n    return false;\n}\n","import { isBinary } from \"./is-binary.js\";\n/**\n * Replaces every Buffer | ArrayBuffer | Blob | File in packet with a numbered placeholder.\n *\n * @param {Object} packet - socket.io event packet\n * @return {Object} with deconstructed packet and list of buffers\n * @public\n */\nexport function deconstructPacket(packet) {\n    const buffers = [];\n    const packetData = packet.data;\n    const pack = packet;\n    pack.data = _deconstructPacket(packetData, buffers);\n    pack.attachments = buffers.length; // number of binary 'attachments'\n    return { packet: pack, buffers: buffers };\n}\nfunction _deconstructPacket(data, buffers) {\n    if (!data)\n        return data;\n    if (isBinary(data)) {\n        const placeholder = { _placeholder: true, num: buffers.length };\n        buffers.push(data);\n        return placeholder;\n    }\n    else if (Array.isArray(data)) {\n        const newData = new Array(data.length);\n        for (let i = 0; i < data.length; i++) {\n            newData[i] = _deconstructPacket(data[i], buffers);\n        }\n        return newData;\n    }\n    else if (typeof data === \"object\" && !(data instanceof Date)) {\n        const newData = {};\n        for (const key in data) {\n            if (Object.prototype.hasOwnProperty.call(data, key)) {\n                newData[key] = _deconstructPacket(data[key], buffers);\n            }\n        }\n        return newData;\n    }\n    return data;\n}\n/**\n * Reconstructs a binary packet from its placeholder packet and buffers\n *\n * @param {Object} packet - event packet with placeholders\n * @param {Array} buffers - binary buffers to put in placeholder positions\n * @return {Object} reconstructed packet\n * @public\n */\nexport function reconstructPacket(packet, buffers) {\n    packet.data = _reconstructPacket(packet.data, buffers);\n    delete packet.attachments; // no longer useful\n    return packet;\n}\nfunction _reconstructPacket(data, buffers) {\n    if (!data)\n        return data;\n    if (data && data._placeholder === true) {\n        const isIndexValid = typeof data.num === \"number\" &&\n            data.num >= 0 &&\n            data.num < buffers.length;\n        if (isIndexValid) {\n            return buffers[data.num]; // appropriate buffer (should be natural order anyway)\n        }\n        else {\n            throw new Error(\"illegal attachments\");\n        }\n    }\n    else if (Array.isArray(data)) {\n        for (let i = 0; i < data.length; i++) {\n            data[i] = _reconstructPacket(data[i], buffers);\n        }\n    }\n    else if (typeof data === \"object\") {\n        for (const key in data) {\n            if (Object.prototype.hasOwnProperty.call(data, key)) {\n                data[key] = _reconstructPacket(data[key], buffers);\n            }\n        }\n    }\n    return data;\n}\n","import { Emitter } from \"@socket.io/component-emitter\";\nimport { deconstructPacket, reconstructPacket } from \"./binary.js\";\nimport { isBinary, hasBinary } from \"./is-binary.js\";\n/**\n * These strings must not be used as event names, as they have a special meaning.\n */\nconst RESERVED_EVENTS = [\n    \"connect\",\n    \"connect_error\",\n    \"disconnect\",\n    \"disconnecting\",\n    \"newListener\",\n    \"removeListener\", // used by the Node.js EventEmitter\n];\n/**\n * Protocol version.\n *\n * @public\n */\nexport const protocol = 5;\nexport var PacketType;\n(function (PacketType) {\n    PacketType[PacketType[\"CONNECT\"] = 0] = \"CONNECT\";\n    PacketType[PacketType[\"DISCONNECT\"] = 1] = \"DISCONNECT\";\n    PacketType[PacketType[\"EVENT\"] = 2] = \"EVENT\";\n    PacketType[PacketType[\"ACK\"] = 3] = \"ACK\";\n    PacketType[PacketType[\"CONNECT_ERROR\"] = 4] = \"CONNECT_ERROR\";\n    PacketType[PacketType[\"BINARY_EVENT\"] = 5] = \"BINARY_EVENT\";\n    PacketType[PacketType[\"BINARY_ACK\"] = 6] = \"BINARY_ACK\";\n})(PacketType || (PacketType = {}));\n/**\n * A socket.io Encoder instance\n */\nexport class Encoder {\n    /**\n     * Encoder constructor\n     *\n     * @param {function} replacer - custom replacer to pass down to JSON.parse\n     */\n    constructor(replacer) {\n        this.replacer = replacer;\n    }\n    /**\n     * Encode a packet as a single string if non-binary, or as a\n     * buffer sequence, depending on packet type.\n     *\n     * @param {Object} obj - packet object\n     */\n    encode(obj) {\n        if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {\n            if (hasBinary(obj)) {\n                return this.encodeAsBinary({\n                    type: obj.type === PacketType.EVENT\n                        ? PacketType.BINARY_EVENT\n                        : PacketType.BINARY_ACK,\n                    nsp: obj.nsp,\n                    data: obj.data,\n                    id: obj.id,\n                });\n            }\n        }\n        return [this.encodeAsString(obj)];\n    }\n    /**\n     * Encode packet as string.\n     */\n    encodeAsString(obj) {\n        // first is type\n        let str = \"\" + obj.type;\n        // attachments if we have them\n        if (obj.type === PacketType.BINARY_EVENT ||\n            obj.type === PacketType.BINARY_ACK) {\n            str += obj.attachments + \"-\";\n        }\n        // if we have a namespace other than `/`\n        // we append it followed by a comma `,`\n        if (obj.nsp && \"/\" !== obj.nsp) {\n            str += obj.nsp + \",\";\n        }\n        // immediately followed by the id\n        if (null != obj.id) {\n            str += obj.id;\n        }\n        // json data\n        if (null != obj.data) {\n            str += JSON.stringify(obj.data, this.replacer);\n        }\n        return str;\n    }\n    /**\n     * Encode packet as 'buffer sequence' by removing blobs, and\n     * deconstructing packet into object with placeholders and\n     * a list of buffers.\n     */\n    encodeAsBinary(obj) {\n        const deconstruction = deconstructPacket(obj);\n        const pack = this.encodeAsString(deconstruction.packet);\n        const buffers = deconstruction.buffers;\n        buffers.unshift(pack); // add packet info to beginning of data list\n        return buffers; // write all the buffers\n    }\n}\n// see https://stackoverflow.com/questions/8511281/check-if-a-value-is-an-object-in-javascript\nfunction isObject(value) {\n    return Object.prototype.toString.call(value) === \"[object Object]\";\n}\n/**\n * A socket.io Decoder instance\n *\n * @return {Object} decoder\n */\nexport class Decoder extends Emitter {\n    /**\n     * Decoder constructor\n     *\n     * @param {function} reviver - custom reviver to pass down to JSON.stringify\n     */\n    constructor(reviver) {\n        super();\n        this.reviver = reviver;\n    }\n    /**\n     * Decodes an encoded packet string into packet JSON.\n     *\n     * @param {String} obj - encoded packet\n     */\n    add(obj) {\n        let packet;\n        if (typeof obj === \"string\") {\n            if (this.reconstructor) {\n                throw new Error(\"got plaintext data when reconstructing a packet\");\n            }\n            packet = this.decodeString(obj);\n            const isBinaryEvent = packet.type === PacketType.BINARY_EVENT;\n            if (isBinaryEvent || packet.type === PacketType.BINARY_ACK) {\n                packet.type = isBinaryEvent ? PacketType.EVENT : PacketType.ACK;\n                // binary packet's json\n                this.reconstructor = new BinaryReconstructor(packet);\n                // no attachments, labeled binary but no binary data to follow\n                if (packet.attachments === 0) {\n                    super.emitReserved(\"decoded\", packet);\n                }\n            }\n            else {\n                // non-binary full packet\n                super.emitReserved(\"decoded\", packet);\n            }\n        }\n        else if (isBinary(obj) || obj.base64) {\n            // raw binary data\n            if (!this.reconstructor) {\n                throw new Error(\"got binary data when not reconstructing a packet\");\n            }\n            else {\n                packet = this.reconstructor.takeBinaryData(obj);\n                if (packet) {\n                    // received final buffer\n                    this.reconstructor = null;\n                    super.emitReserved(\"decoded\", packet);\n                }\n            }\n        }\n        else {\n            throw new Error(\"Unknown type: \" + obj);\n        }\n    }\n    /**\n     * Decode a packet String (JSON data)\n     *\n     * @param {String} str\n     * @return {Object} packet\n     */\n    decodeString(str) {\n        let i = 0;\n        // look up type\n        const p = {\n            type: Number(str.charAt(0)),\n        };\n        if (PacketType[p.type] === undefined) {\n            throw new Error(\"unknown packet type \" + p.type);\n        }\n        // look up attachments if type binary\n        if (p.type === PacketType.BINARY_EVENT ||\n            p.type === PacketType.BINARY_ACK) {\n            const start = i + 1;\n            while (str.charAt(++i) !== \"-\" && i != str.length) { }\n            const buf = str.substring(start, i);\n            if (buf != Number(buf) || str.charAt(i) !== \"-\") {\n                throw new Error(\"Illegal attachments\");\n            }\n            p.attachments = Number(buf);\n        }\n        // look up namespace (if any)\n        if (\"/\" === str.charAt(i + 1)) {\n            const start = i + 1;\n            while (++i) {\n                const c = str.charAt(i);\n                if (\",\" === c)\n                    break;\n                if (i === str.length)\n                    break;\n            }\n            p.nsp = str.substring(start, i);\n        }\n        else {\n            p.nsp = \"/\";\n        }\n        // look up id\n        const next = str.charAt(i + 1);\n        if (\"\" !== next && Number(next) == next) {\n            const start = i + 1;\n            while (++i) {\n                const c = str.charAt(i);\n                if (null == c || Number(c) != c) {\n                    --i;\n                    break;\n                }\n                if (i === str.length)\n                    break;\n            }\n            p.id = Number(str.substring(start, i + 1));\n        }\n        // look up json data\n        if (str.charAt(++i)) {\n            const payload = this.tryParse(str.substr(i));\n            if (Decoder.isPayloadValid(p.type, payload)) {\n                p.data = payload;\n            }\n            else {\n                throw new Error(\"invalid payload\");\n            }\n        }\n        return p;\n    }\n    tryParse(str) {\n        try {\n            return JSON.parse(str, this.reviver);\n        }\n        catch (e) {\n            return false;\n        }\n    }\n    static isPayloadValid(type, payload) {\n        switch (type) {\n            case PacketType.CONNECT:\n                return isObject(payload);\n            case PacketType.DISCONNECT:\n                return payload === undefined;\n            case PacketType.CONNECT_ERROR:\n                return typeof payload === \"string\" || isObject(payload);\n            case PacketType.EVENT:\n            case PacketType.BINARY_EVENT:\n                return (Array.isArray(payload) &&\n                    (typeof payload[0] === \"number\" ||\n                        (typeof payload[0] === \"string\" &&\n                            RESERVED_EVENTS.indexOf(payload[0]) === -1)));\n            case PacketType.ACK:\n            case PacketType.BINARY_ACK:\n                return Array.isArray(payload);\n        }\n    }\n    /**\n     * Deallocates a parser's resources\n     */\n    destroy() {\n        if (this.reconstructor) {\n            this.reconstructor.finishedReconstruction();\n            this.reconstructor = null;\n        }\n    }\n}\n/**\n * A manager of a binary event's 'buffer sequence'. Should\n * be constructed whenever a packet of type BINARY_EVENT is\n * decoded.\n *\n * @param {Object} packet\n * @return {BinaryReconstructor} initialized reconstructor\n */\nclass BinaryReconstructor {\n    constructor(packet) {\n        this.packet = packet;\n        this.buffers = [];\n        this.reconPack = packet;\n    }\n    /**\n     * Method to be called when binary data received from connection\n     * after a BINARY_EVENT packet.\n     *\n     * @param {Buffer | ArrayBuffer} binData - the raw binary data received\n     * @return {null | Object} returns null if more binary data is expected or\n     *   a reconstructed packet object if all buffers have been received.\n     */\n    takeBinaryData(binData) {\n        this.buffers.push(binData);\n        if (this.buffers.length === this.reconPack.attachments) {\n            // done with buffer list\n            const packet = reconstructPacket(this.reconPack, this.buffers);\n            this.finishedReconstruction();\n            return packet;\n        }\n        return null;\n    }\n    /**\n     * Cleans up binary packet reconstruction variables.\n     */\n    finishedReconstruction() {\n        this.reconPack = null;\n        this.buffers = [];\n    }\n}\n","export function on(obj, ev, fn) {\n    obj.on(ev, fn);\n    return function subDestroy() {\n        obj.off(ev, fn);\n    };\n}\n","import { PacketType } from \"socket.io-parser\";\nimport { on } from \"./on.js\";\nimport { Emitter, } from \"@socket.io/component-emitter\";\n/**\n * Internal events.\n * These events can't be emitted by the user.\n */\nconst RESERVED_EVENTS = Object.freeze({\n    connect: 1,\n    connect_error: 1,\n    disconnect: 1,\n    disconnecting: 1,\n    // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener\n    newListener: 1,\n    removeListener: 1,\n});\n/**\n * A Socket is the fundamental class for interacting with the server.\n *\n * A Socket belongs to a certain Namespace (by default /) and uses an underlying {@link Manager} to communicate.\n *\n * @example\n * const socket = io();\n *\n * socket.on(\"connect\", () => {\n *   console.log(\"connected\");\n * });\n *\n * // send an event to the server\n * socket.emit(\"foo\", \"bar\");\n *\n * socket.on(\"foobar\", () => {\n *   // an event was received from the server\n * });\n *\n * // upon disconnection\n * socket.on(\"disconnect\", (reason) => {\n *   console.log(`disconnected due to ${reason}`);\n * });\n */\nexport class Socket extends Emitter {\n    /**\n     * `Socket` constructor.\n     */\n    constructor(io, nsp, opts) {\n        super();\n        /**\n         * Whether the socket is currently connected to the server.\n         *\n         * @example\n         * const socket = io();\n         *\n         * socket.on(\"connect\", () => {\n         *   console.log(socket.connected); // true\n         * });\n         *\n         * socket.on(\"disconnect\", () => {\n         *   console.log(socket.connected); // false\n         * });\n         */\n        this.connected = false;\n        /**\n         * Whether the connection state was recovered after a temporary disconnection. In that case, any missed packets will\n         * be transmitted by the server.\n         */\n        this.recovered = false;\n        /**\n         * Buffer for packets received before the CONNECT packet\n         */\n        this.receiveBuffer = [];\n        /**\n         * Buffer for packets that will be sent once the socket is connected\n         */\n        this.sendBuffer = [];\n        /**\n         * The queue of packets to be sent with retry in case of failure.\n         *\n         * Packets are sent one by one, each waiting for the server acknowledgement, in order to guarantee the delivery order.\n         * @private\n         */\n        this._queue = [];\n        /**\n         * A sequence to generate the ID of the {@link QueuedPacket}.\n         * @private\n         */\n        this._queueSeq = 0;\n        this.ids = 0;\n        /**\n         * A map containing acknowledgement handlers.\n         *\n         * The `withError` attribute is used to differentiate handlers that accept an error as first argument:\n         *\n         * - `socket.emit(\"test\", (err, value) => { ... })` with `ackTimeout` option\n         * - `socket.timeout(5000).emit(\"test\", (err, value) => { ... })`\n         * - `const value = await socket.emitWithAck(\"test\")`\n         *\n         * From those that don't:\n         *\n         * - `socket.emit(\"test\", (value) => { ... });`\n         *\n         * In the first case, the handlers will be called with an error when:\n         *\n         * - the timeout is reached\n         * - the socket gets disconnected\n         *\n         * In the second case, the handlers will be simply discarded upon disconnection, since the client will never receive\n         * an acknowledgement from the server.\n         *\n         * @private\n         */\n        this.acks = {};\n        this.flags = {};\n        this.io = io;\n        this.nsp = nsp;\n        if (opts && opts.auth) {\n            this.auth = opts.auth;\n        }\n        this._opts = Object.assign({}, opts);\n        if (this.io._autoConnect)\n            this.open();\n    }\n    /**\n     * Whether the socket is currently disconnected\n     *\n     * @example\n     * const socket = io();\n     *\n     * socket.on(\"connect\", () => {\n     *   console.log(socket.disconnected); // false\n     * });\n     *\n     * socket.on(\"disconnect\", () => {\n     *   console.log(socket.disconnected); // true\n     * });\n     */\n    get disconnected() {\n        return !this.connected;\n    }\n    /**\n     * Subscribe to open, close and packet events\n     *\n     * @private\n     */\n    subEvents() {\n        if (this.subs)\n            return;\n        const io = this.io;\n        this.subs = [\n            on(io, \"open\", this.onopen.bind(this)),\n            on(io, \"packet\", this.onpacket.bind(this)),\n            on(io, \"error\", this.onerror.bind(this)),\n            on(io, \"close\", this.onclose.bind(this)),\n        ];\n    }\n    /**\n     * Whether the Socket will try to reconnect when its Manager connects or reconnects.\n     *\n     * @example\n     * const socket = io();\n     *\n     * console.log(socket.active); // true\n     *\n     * socket.on(\"disconnect\", (reason) => {\n     *   if (reason === \"io server disconnect\") {\n     *     // the disconnection was initiated by the server, you need to manually reconnect\n     *     console.log(socket.active); // false\n     *   }\n     *   // else the socket will automatically try to reconnect\n     *   console.log(socket.active); // true\n     * });\n     */\n    get active() {\n        return !!this.subs;\n    }\n    /**\n     * \"Opens\" the socket.\n     *\n     * @example\n     * const socket = io({\n     *   autoConnect: false\n     * });\n     *\n     * socket.connect();\n     */\n    connect() {\n        if (this.connected)\n            return this;\n        this.subEvents();\n        if (!this.io[\"_reconnecting\"])\n            this.io.open(); // ensure open\n        if (\"open\" === this.io._readyState)\n            this.onopen();\n        return this;\n    }\n    /**\n     * Alias for {@link connect()}.\n     */\n    open() {\n        return this.connect();\n    }\n    /**\n     * Sends a `message` event.\n     *\n     * This method mimics the WebSocket.send() method.\n     *\n     * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send\n     *\n     * @example\n     * socket.send(\"hello\");\n     *\n     * // this is equivalent to\n     * socket.emit(\"message\", \"hello\");\n     *\n     * @return self\n     */\n    send(...args) {\n        args.unshift(\"message\");\n        this.emit.apply(this, args);\n        return this;\n    }\n    /**\n     * Override `emit`.\n     * If the event is in `events`, it's emitted normally.\n     *\n     * @example\n     * socket.emit(\"hello\", \"world\");\n     *\n     * // all serializable datastructures are supported (no need to call JSON.stringify)\n     * socket.emit(\"hello\", 1, \"2\", { 3: [\"4\"], 5: Uint8Array.from([6]) });\n     *\n     * // with an acknowledgement from the server\n     * socket.emit(\"hello\", \"world\", (val) => {\n     *   // ...\n     * });\n     *\n     * @return self\n     */\n    emit(ev, ...args) {\n        if (RESERVED_EVENTS.hasOwnProperty(ev)) {\n            throw new Error('\"' + ev.toString() + '\" is a reserved event name');\n        }\n        args.unshift(ev);\n        if (this._opts.retries && !this.flags.fromQueue && !this.flags.volatile) {\n            this._addToQueue(args);\n            return this;\n        }\n        const packet = {\n            type: PacketType.EVENT,\n            data: args,\n        };\n        packet.options = {};\n        packet.options.compress = this.flags.compress !== false;\n        // event ack callback\n        if (\"function\" === typeof args[args.length - 1]) {\n            const id = this.ids++;\n            const ack = args.pop();\n            this._registerAckCallback(id, ack);\n            packet.id = id;\n        }\n        const isTransportWritable = this.io.engine &&\n            this.io.engine.transport &&\n            this.io.engine.transport.writable;\n        const discardPacket = this.flags.volatile && (!isTransportWritable || !this.connected);\n        if (discardPacket) {\n        }\n        else if (this.connected) {\n            this.notifyOutgoingListeners(packet);\n            this.packet(packet);\n        }\n        else {\n            this.sendBuffer.push(packet);\n        }\n        this.flags = {};\n        return this;\n    }\n    /**\n     * @private\n     */\n    _registerAckCallback(id, ack) {\n        var _a;\n        const timeout = (_a = this.flags.timeout) !== null && _a !== void 0 ? _a : this._opts.ackTimeout;\n        if (timeout === undefined) {\n            this.acks[id] = ack;\n            return;\n        }\n        // @ts-ignore\n        const timer = this.io.setTimeoutFn(() => {\n            delete this.acks[id];\n            for (let i = 0; i < this.sendBuffer.length; i++) {\n                if (this.sendBuffer[i].id === id) {\n                    this.sendBuffer.splice(i, 1);\n                }\n            }\n            ack.call(this, new Error(\"operation has timed out\"));\n        }, timeout);\n        const fn = (...args) => {\n            // @ts-ignore\n            this.io.clearTimeoutFn(timer);\n            ack.apply(this, args);\n        };\n        fn.withError = true;\n        this.acks[id] = fn;\n    }\n    /**\n     * Emits an event and waits for an acknowledgement\n     *\n     * @example\n     * // without timeout\n     * const response = await socket.emitWithAck(\"hello\", \"world\");\n     *\n     * // with a specific timeout\n     * try {\n     *   const response = await socket.timeout(1000).emitWithAck(\"hello\", \"world\");\n     * } catch (err) {\n     *   // the server did not acknowledge the event in the given delay\n     * }\n     *\n     * @return a Promise that will be fulfilled when the server acknowledges the event\n     */\n    emitWithAck(ev, ...args) {\n        return new Promise((resolve, reject) => {\n            const fn = (arg1, arg2) => {\n                return arg1 ? reject(arg1) : resolve(arg2);\n            };\n            fn.withError = true;\n            args.push(fn);\n            this.emit(ev, ...args);\n        });\n    }\n    /**\n     * Add the packet to the queue.\n     * @param args\n     * @private\n     */\n    _addToQueue(args) {\n        let ack;\n        if (typeof args[args.length - 1] === \"function\") {\n            ack = args.pop();\n        }\n        const packet = {\n            id: this._queueSeq++,\n            tryCount: 0,\n            pending: false,\n            args,\n            flags: Object.assign({ fromQueue: true }, this.flags),\n        };\n        args.push((err, ...responseArgs) => {\n            if (packet !== this._queue[0]) {\n                // the packet has already been acknowledged\n                return;\n            }\n            const hasError = err !== null;\n            if (hasError) {\n                if (packet.tryCount > this._opts.retries) {\n                    this._queue.shift();\n                    if (ack) {\n                        ack(err);\n                    }\n                }\n            }\n            else {\n                this._queue.shift();\n                if (ack) {\n                    ack(null, ...responseArgs);\n                }\n            }\n            packet.pending = false;\n            return this._drainQueue();\n        });\n        this._queue.push(packet);\n        this._drainQueue();\n    }\n    /**\n     * Send the first packet of the queue, and wait for an acknowledgement from the server.\n     * @param force - whether to resend a packet that has not been acknowledged yet\n     *\n     * @private\n     */\n    _drainQueue(force = false) {\n        if (!this.connected || this._queue.length === 0) {\n            return;\n        }\n        const packet = this._queue[0];\n        if (packet.pending && !force) {\n            return;\n        }\n        packet.pending = true;\n        packet.tryCount++;\n        this.flags = packet.flags;\n        this.emit.apply(this, packet.args);\n    }\n    /**\n     * Sends a packet.\n     *\n     * @param packet\n     * @private\n     */\n    packet(packet) {\n        packet.nsp = this.nsp;\n        this.io._packet(packet);\n    }\n    /**\n     * Called upon engine `open`.\n     *\n     * @private\n     */\n    onopen() {\n        if (typeof this.auth == \"function\") {\n            this.auth((data) => {\n                this._sendConnectPacket(data);\n            });\n        }\n        else {\n            this._sendConnectPacket(this.auth);\n        }\n    }\n    /**\n     * Sends a CONNECT packet to initiate the Socket.IO session.\n     *\n     * @param data\n     * @private\n     */\n    _sendConnectPacket(data) {\n        this.packet({\n            type: PacketType.CONNECT,\n            data: this._pid\n                ? Object.assign({ pid: this._pid, offset: this._lastOffset }, data)\n                : data,\n        });\n    }\n    /**\n     * Called upon engine or manager `error`.\n     *\n     * @param err\n     * @private\n     */\n    onerror(err) {\n        if (!this.connected) {\n            this.emitReserved(\"connect_error\", err);\n        }\n    }\n    /**\n     * Called upon engine `close`.\n     *\n     * @param reason\n     * @param description\n     * @private\n     */\n    onclose(reason, description) {\n        this.connected = false;\n        delete this.id;\n        this.emitReserved(\"disconnect\", reason, description);\n        this._clearAcks();\n    }\n    /**\n     * Clears the acknowledgement handlers upon disconnection, since the client will never receive an acknowledgement from\n     * the server.\n     *\n     * @private\n     */\n    _clearAcks() {\n        Object.keys(this.acks).forEach((id) => {\n            const isBuffered = this.sendBuffer.some((packet) => String(packet.id) === id);\n            if (!isBuffered) {\n                // note: handlers that do not accept an error as first argument are ignored here\n                const ack = this.acks[id];\n                delete this.acks[id];\n                if (ack.withError) {\n                    ack.call(this, new Error(\"socket has been disconnected\"));\n                }\n            }\n        });\n    }\n    /**\n     * Called with socket packet.\n     *\n     * @param packet\n     * @private\n     */\n    onpacket(packet) {\n        const sameNamespace = packet.nsp === this.nsp;\n        if (!sameNamespace)\n            return;\n        switch (packet.type) {\n            case PacketType.CONNECT:\n                if (packet.data && packet.data.sid) {\n                    this.onconnect(packet.data.sid, packet.data.pid);\n                }\n                else {\n                    this.emitReserved(\"connect_error\", new Error(\"It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)\"));\n                }\n                break;\n            case PacketType.EVENT:\n            case PacketType.BINARY_EVENT:\n                this.onevent(packet);\n                break;\n            case PacketType.ACK:\n            case PacketType.BINARY_ACK:\n                this.onack(packet);\n                break;\n            case PacketType.DISCONNECT:\n                this.ondisconnect();\n                break;\n            case PacketType.CONNECT_ERROR:\n                this.destroy();\n                const err = new Error(packet.data.message);\n                // @ts-ignore\n                err.data = packet.data.data;\n                this.emitReserved(\"connect_error\", err);\n                break;\n        }\n    }\n    /**\n     * Called upon a server event.\n     *\n     * @param packet\n     * @private\n     */\n    onevent(packet) {\n        const args = packet.data || [];\n        if (null != packet.id) {\n            args.push(this.ack(packet.id));\n        }\n        if (this.connected) {\n            this.emitEvent(args);\n        }\n        else {\n            this.receiveBuffer.push(Object.freeze(args));\n        }\n    }\n    emitEvent(args) {\n        if (this._anyListeners && this._anyListeners.length) {\n            const listeners = this._anyListeners.slice();\n            for (const listener of listeners) {\n                listener.apply(this, args);\n            }\n        }\n        super.emit.apply(this, args);\n        if (this._pid && args.length && typeof args[args.length - 1] === \"string\") {\n            this._lastOffset = args[args.length - 1];\n        }\n    }\n    /**\n     * Produces an ack callback to emit with an event.\n     *\n     * @private\n     */\n    ack(id) {\n        const self = this;\n        let sent = false;\n        return function (...args) {\n            // prevent double callbacks\n            if (sent)\n                return;\n            sent = true;\n            self.packet({\n                type: PacketType.ACK,\n                id: id,\n                data: args,\n            });\n        };\n    }\n    /**\n     * Called upon a server acknowledgement.\n     *\n     * @param packet\n     * @private\n     */\n    onack(packet) {\n        const ack = this.acks[packet.id];\n        if (typeof ack !== \"function\") {\n            return;\n        }\n        delete this.acks[packet.id];\n        // @ts-ignore FIXME ack is incorrectly inferred as 'never'\n        if (ack.withError) {\n            packet.data.unshift(null);\n        }\n        // @ts-ignore\n        ack.apply(this, packet.data);\n    }\n    /**\n     * Called upon server connect.\n     *\n     * @private\n     */\n    onconnect(id, pid) {\n        this.id = id;\n        this.recovered = pid && this._pid === pid;\n        this._pid = pid; // defined only if connection state recovery is enabled\n        this.connected = true;\n        this.emitBuffered();\n        this.emitReserved(\"connect\");\n        this._drainQueue(true);\n    }\n    /**\n     * Emit buffered events (received and emitted).\n     *\n     * @private\n     */\n    emitBuffered() {\n        this.receiveBuffer.forEach((args) => this.emitEvent(args));\n        this.receiveBuffer = [];\n        this.sendBuffer.forEach((packet) => {\n            this.notifyOutgoingListeners(packet);\n            this.packet(packet);\n        });\n        this.sendBuffer = [];\n    }\n    /**\n     * Called upon server disconnect.\n     *\n     * @private\n     */\n    ondisconnect() {\n        this.destroy();\n        this.onclose(\"io server disconnect\");\n    }\n    /**\n     * Called upon forced client/server side disconnections,\n     * this method ensures the manager stops tracking us and\n     * that reconnections don't get triggered for this.\n     *\n     * @private\n     */\n    destroy() {\n        if (this.subs) {\n            // clean subscriptions to avoid reconnections\n            this.subs.forEach((subDestroy) => subDestroy());\n            this.subs = undefined;\n        }\n        this.io[\"_destroy\"](this);\n    }\n    /**\n     * Disconnects the socket manually. In that case, the socket will not try to reconnect.\n     *\n     * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.\n     *\n     * @example\n     * const socket = io();\n     *\n     * socket.on(\"disconnect\", (reason) => {\n     *   // console.log(reason); prints \"io client disconnect\"\n     * });\n     *\n     * socket.disconnect();\n     *\n     * @return self\n     */\n    disconnect() {\n        if (this.connected) {\n            this.packet({ type: PacketType.DISCONNECT });\n        }\n        // remove socket from pool\n        this.destroy();\n        if (this.connected) {\n            // fire events\n            this.onclose(\"io client disconnect\");\n        }\n        return this;\n    }\n    /**\n     * Alias for {@link disconnect()}.\n     *\n     * @return self\n     */\n    close() {\n        return this.disconnect();\n    }\n    /**\n     * Sets the compress flag.\n     *\n     * @example\n     * socket.compress(false).emit(\"hello\");\n     *\n     * @param compress - if `true`, compresses the sending data\n     * @return self\n     */\n    compress(compress) {\n        this.flags.compress = compress;\n        return this;\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not\n     * ready to send messages.\n     *\n     * @example\n     * socket.volatile.emit(\"hello\"); // the server may or may not receive it\n     *\n     * @returns self\n     */\n    get volatile() {\n        this.flags.volatile = true;\n        return this;\n    }\n    /**\n     * Sets a modifier for a subsequent event emission that the callback will be called with an error when the\n     * given number of milliseconds have elapsed without an acknowledgement from the server:\n     *\n     * @example\n     * socket.timeout(5000).emit(\"my-event\", (err) => {\n     *   if (err) {\n     *     // the server did not acknowledge the event in the given delay\n     *   }\n     * });\n     *\n     * @returns self\n     */\n    timeout(timeout) {\n        this.flags.timeout = timeout;\n        return this;\n    }\n    /**\n     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n     * callback.\n     *\n     * @example\n     * socket.onAny((event, ...args) => {\n     *   console.log(`got ${event}`);\n     * });\n     *\n     * @param listener\n     */\n    onAny(listener) {\n        this._anyListeners = this._anyListeners || [];\n        this._anyListeners.push(listener);\n        return this;\n    }\n    /**\n     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n     * callback. The listener is added to the beginning of the listeners array.\n     *\n     * @example\n     * socket.prependAny((event, ...args) => {\n     *   console.log(`got event ${event}`);\n     * });\n     *\n     * @param listener\n     */\n    prependAny(listener) {\n        this._anyListeners = this._anyListeners || [];\n        this._anyListeners.unshift(listener);\n        return this;\n    }\n    /**\n     * Removes the listener that will be fired when any event is emitted.\n     *\n     * @example\n     * const catchAllListener = (event, ...args) => {\n     *   console.log(`got event ${event}`);\n     * }\n     *\n     * socket.onAny(catchAllListener);\n     *\n     * // remove a specific listener\n     * socket.offAny(catchAllListener);\n     *\n     * // or remove all listeners\n     * socket.offAny();\n     *\n     * @param listener\n     */\n    offAny(listener) {\n        if (!this._anyListeners) {\n            return this;\n        }\n        if (listener) {\n            const listeners = this._anyListeners;\n            for (let i = 0; i < listeners.length; i++) {\n                if (listener === listeners[i]) {\n                    listeners.splice(i, 1);\n                    return this;\n                }\n            }\n        }\n        else {\n            this._anyListeners = [];\n        }\n        return this;\n    }\n    /**\n     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,\n     * e.g. to remove listeners.\n     */\n    listenersAny() {\n        return this._anyListeners || [];\n    }\n    /**\n     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n     * callback.\n     *\n     * Note: acknowledgements sent to the server are not included.\n     *\n     * @example\n     * socket.onAnyOutgoing((event, ...args) => {\n     *   console.log(`sent event ${event}`);\n     * });\n     *\n     * @param listener\n     */\n    onAnyOutgoing(listener) {\n        this._anyOutgoingListeners = this._anyOutgoingListeners || [];\n        this._anyOutgoingListeners.push(listener);\n        return this;\n    }\n    /**\n     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the\n     * callback. The listener is added to the beginning of the listeners array.\n     *\n     * Note: acknowledgements sent to the server are not included.\n     *\n     * @example\n     * socket.prependAnyOutgoing((event, ...args) => {\n     *   console.log(`sent event ${event}`);\n     * });\n     *\n     * @param listener\n     */\n    prependAnyOutgoing(listener) {\n        this._anyOutgoingListeners = this._anyOutgoingListeners || [];\n        this._anyOutgoingListeners.unshift(listener);\n        return this;\n    }\n    /**\n     * Removes the listener that will be fired when any event is emitted.\n     *\n     * @example\n     * const catchAllListener = (event, ...args) => {\n     *   console.log(`sent event ${event}`);\n     * }\n     *\n     * socket.onAnyOutgoing(catchAllListener);\n     *\n     * // remove a specific listener\n     * socket.offAnyOutgoing(catchAllListener);\n     *\n     * // or remove all listeners\n     * socket.offAnyOutgoing();\n     *\n     * @param [listener] - the catch-all listener (optional)\n     */\n    offAnyOutgoing(listener) {\n        if (!this._anyOutgoingListeners) {\n            return this;\n        }\n        if (listener) {\n            const listeners = this._anyOutgoingListeners;\n            for (let i = 0; i < listeners.length; i++) {\n                if (listener === listeners[i]) {\n                    listeners.splice(i, 1);\n                    return this;\n                }\n            }\n        }\n        else {\n            this._anyOutgoingListeners = [];\n        }\n        return this;\n    }\n    /**\n     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,\n     * e.g. to remove listeners.\n     */\n    listenersAnyOutgoing() {\n        return this._anyOutgoingListeners || [];\n    }\n    /**\n     * Notify the listeners for each packet sent\n     *\n     * @param packet\n     *\n     * @private\n     */\n    notifyOutgoingListeners(packet) {\n        if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {\n            const listeners = this._anyOutgoingListeners.slice();\n            for (const listener of listeners) {\n                listener.apply(this, packet.data);\n            }\n        }\n    }\n}\n","/**\n * Initialize backoff timer with `opts`.\n *\n * - `min` initial timeout in milliseconds [100]\n * - `max` max timeout [10000]\n * - `jitter` [0]\n * - `factor` [2]\n *\n * @param {Object} opts\n * @api public\n */\nexport function Backoff(opts) {\n    opts = opts || {};\n    this.ms = opts.min || 100;\n    this.max = opts.max || 10000;\n    this.factor = opts.factor || 2;\n    this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;\n    this.attempts = 0;\n}\n/**\n * Return the backoff duration.\n *\n * @return {Number}\n * @api public\n */\nBackoff.prototype.duration = function () {\n    var ms = this.ms * Math.pow(this.factor, this.attempts++);\n    if (this.jitter) {\n        var rand = Math.random();\n        var deviation = Math.floor(rand * this.jitter * ms);\n        ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;\n    }\n    return Math.min(ms, this.max) | 0;\n};\n/**\n * Reset the number of attempts.\n *\n * @api public\n */\nBackoff.prototype.reset = function () {\n    this.attempts = 0;\n};\n/**\n * Set the minimum duration\n *\n * @api public\n */\nBackoff.prototype.setMin = function (min) {\n    this.ms = min;\n};\n/**\n * Set the maximum duration\n *\n * @api public\n */\nBackoff.prototype.setMax = function (max) {\n    this.max = max;\n};\n/**\n * Set the jitter\n *\n * @api public\n */\nBackoff.prototype.setJitter = function (jitter) {\n    this.jitter = jitter;\n};\n","import { Socket as Engine, installTimerFunctions, nextTick, } from \"engine.io-client\";\nimport { Socket } from \"./socket.js\";\nimport * as parser from \"socket.io-parser\";\nimport { on } from \"./on.js\";\nimport { Backoff } from \"./contrib/backo2.js\";\nimport { Emitter, } from \"@socket.io/component-emitter\";\nexport class Manager extends Emitter {\n    constructor(uri, opts) {\n        var _a;\n        super();\n        this.nsps = {};\n        this.subs = [];\n        if (uri && \"object\" === typeof uri) {\n            opts = uri;\n            uri = undefined;\n        }\n        opts = opts || {};\n        opts.path = opts.path || \"/socket.io\";\n        this.opts = opts;\n        installTimerFunctions(this, opts);\n        this.reconnection(opts.reconnection !== false);\n        this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);\n        this.reconnectionDelay(opts.reconnectionDelay || 1000);\n        this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);\n        this.randomizationFactor((_a = opts.randomizationFactor) !== null && _a !== void 0 ? _a : 0.5);\n        this.backoff = new Backoff({\n            min: this.reconnectionDelay(),\n            max: this.reconnectionDelayMax(),\n            jitter: this.randomizationFactor(),\n        });\n        this.timeout(null == opts.timeout ? 20000 : opts.timeout);\n        this._readyState = \"closed\";\n        this.uri = uri;\n        const _parser = opts.parser || parser;\n        this.encoder = new _parser.Encoder();\n        this.decoder = new _parser.Decoder();\n        this._autoConnect = opts.autoConnect !== false;\n        if (this._autoConnect)\n            this.open();\n    }\n    reconnection(v) {\n        if (!arguments.length)\n            return this._reconnection;\n        this._reconnection = !!v;\n        return this;\n    }\n    reconnectionAttempts(v) {\n        if (v === undefined)\n            return this._reconnectionAttempts;\n        this._reconnectionAttempts = v;\n        return this;\n    }\n    reconnectionDelay(v) {\n        var _a;\n        if (v === undefined)\n            return this._reconnectionDelay;\n        this._reconnectionDelay = v;\n        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMin(v);\n        return this;\n    }\n    randomizationFactor(v) {\n        var _a;\n        if (v === undefined)\n            return this._randomizationFactor;\n        this._randomizationFactor = v;\n        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setJitter(v);\n        return this;\n    }\n    reconnectionDelayMax(v) {\n        var _a;\n        if (v === undefined)\n            return this._reconnectionDelayMax;\n        this._reconnectionDelayMax = v;\n        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMax(v);\n        return this;\n    }\n    timeout(v) {\n        if (!arguments.length)\n            return this._timeout;\n        this._timeout = v;\n        return this;\n    }\n    /**\n     * Starts trying to reconnect if reconnection is enabled and we have not\n     * started reconnecting yet\n     *\n     * @private\n     */\n    maybeReconnectOnOpen() {\n        // Only try to reconnect if it's the first time we're connecting\n        if (!this._reconnecting &&\n            this._reconnection &&\n            this.backoff.attempts === 0) {\n            // keeps reconnection from firing twice for the same reconnection loop\n            this.reconnect();\n        }\n    }\n    /**\n     * Sets the current transport `socket`.\n     *\n     * @param {Function} fn - optional, callback\n     * @return self\n     * @public\n     */\n    open(fn) {\n        if (~this._readyState.indexOf(\"open\"))\n            return this;\n        this.engine = new Engine(this.uri, this.opts);\n        const socket = this.engine;\n        const self = this;\n        this._readyState = \"opening\";\n        this.skipReconnect = false;\n        // emit `open`\n        const openSubDestroy = on(socket, \"open\", function () {\n            self.onopen();\n            fn && fn();\n        });\n        const onError = (err) => {\n            this.cleanup();\n            this._readyState = \"closed\";\n            this.emitReserved(\"error\", err);\n            if (fn) {\n                fn(err);\n            }\n            else {\n                // Only do this if there is no fn to handle the error\n                this.maybeReconnectOnOpen();\n            }\n        };\n        // emit `error`\n        const errorSub = on(socket, \"error\", onError);\n        if (false !== this._timeout) {\n            const timeout = this._timeout;\n            // set timer\n            const timer = this.setTimeoutFn(() => {\n                openSubDestroy();\n                onError(new Error(\"timeout\"));\n                socket.close();\n            }, timeout);\n            if (this.opts.autoUnref) {\n                timer.unref();\n            }\n            this.subs.push(() => {\n                this.clearTimeoutFn(timer);\n            });\n        }\n        this.subs.push(openSubDestroy);\n        this.subs.push(errorSub);\n        return this;\n    }\n    /**\n     * Alias for open()\n     *\n     * @return self\n     * @public\n     */\n    connect(fn) {\n        return this.open(fn);\n    }\n    /**\n     * Called upon transport open.\n     *\n     * @private\n     */\n    onopen() {\n        // clear old subs\n        this.cleanup();\n        // mark as open\n        this._readyState = \"open\";\n        this.emitReserved(\"open\");\n        // add new subs\n        const socket = this.engine;\n        this.subs.push(on(socket, \"ping\", this.onping.bind(this)), on(socket, \"data\", this.ondata.bind(this)), on(socket, \"error\", this.onerror.bind(this)), on(socket, \"close\", this.onclose.bind(this)), on(this.decoder, \"decoded\", this.ondecoded.bind(this)));\n    }\n    /**\n     * Called upon a ping.\n     *\n     * @private\n     */\n    onping() {\n        this.emitReserved(\"ping\");\n    }\n    /**\n     * Called with data.\n     *\n     * @private\n     */\n    ondata(data) {\n        try {\n            this.decoder.add(data);\n        }\n        catch (e) {\n            this.onclose(\"parse error\", e);\n        }\n    }\n    /**\n     * Called when parser fully decodes a packet.\n     *\n     * @private\n     */\n    ondecoded(packet) {\n        // the nextTick call prevents an exception in a user-provided event listener from triggering a disconnection due to a \"parse error\"\n        nextTick(() => {\n            this.emitReserved(\"packet\", packet);\n        }, this.setTimeoutFn);\n    }\n    /**\n     * Called upon socket error.\n     *\n     * @private\n     */\n    onerror(err) {\n        this.emitReserved(\"error\", err);\n    }\n    /**\n     * Creates a new socket for the given `nsp`.\n     *\n     * @return {Socket}\n     * @public\n     */\n    socket(nsp, opts) {\n        let socket = this.nsps[nsp];\n        if (!socket) {\n            socket = new Socket(this, nsp, opts);\n            this.nsps[nsp] = socket;\n        }\n        else if (this._autoConnect && !socket.active) {\n            socket.connect();\n        }\n        return socket;\n    }\n    /**\n     * Called upon a socket close.\n     *\n     * @param socket\n     * @private\n     */\n    _destroy(socket) {\n        const nsps = Object.keys(this.nsps);\n        for (const nsp of nsps) {\n            const socket = this.nsps[nsp];\n            if (socket.active) {\n                return;\n            }\n        }\n        this._close();\n    }\n    /**\n     * Writes a packet.\n     *\n     * @param packet\n     * @private\n     */\n    _packet(packet) {\n        const encodedPackets = this.encoder.encode(packet);\n        for (let i = 0; i < encodedPackets.length; i++) {\n            this.engine.write(encodedPackets[i], packet.options);\n        }\n    }\n    /**\n     * Clean up transport subscriptions and packet buffer.\n     *\n     * @private\n     */\n    cleanup() {\n        this.subs.forEach((subDestroy) => subDestroy());\n        this.subs.length = 0;\n        this.decoder.destroy();\n    }\n    /**\n     * Close the current socket.\n     *\n     * @private\n     */\n    _close() {\n        this.skipReconnect = true;\n        this._reconnecting = false;\n        this.onclose(\"forced close\");\n        if (this.engine)\n            this.engine.close();\n    }\n    /**\n     * Alias for close()\n     *\n     * @private\n     */\n    disconnect() {\n        return this._close();\n    }\n    /**\n     * Called upon engine close.\n     *\n     * @private\n     */\n    onclose(reason, description) {\n        this.cleanup();\n        this.backoff.reset();\n        this._readyState = \"closed\";\n        this.emitReserved(\"close\", reason, description);\n        if (this._reconnection && !this.skipReconnect) {\n            this.reconnect();\n        }\n    }\n    /**\n     * Attempt a reconnection.\n     *\n     * @private\n     */\n    reconnect() {\n        if (this._reconnecting || this.skipReconnect)\n            return this;\n        const self = this;\n        if (this.backoff.attempts >= this._reconnectionAttempts) {\n            this.backoff.reset();\n            this.emitReserved(\"reconnect_failed\");\n            this._reconnecting = false;\n        }\n        else {\n            const delay = this.backoff.duration();\n            this._reconnecting = true;\n            const timer = this.setTimeoutFn(() => {\n                if (self.skipReconnect)\n                    return;\n                this.emitReserved(\"reconnect_attempt\", self.backoff.attempts);\n                // check again for the case socket closed in above events\n                if (self.skipReconnect)\n                    return;\n                self.open((err) => {\n                    if (err) {\n                        self._reconnecting = false;\n                        self.reconnect();\n                        this.emitReserved(\"reconnect_error\", err);\n                    }\n                    else {\n                        self.onreconnect();\n                    }\n                });\n            }, delay);\n            if (this.opts.autoUnref) {\n                timer.unref();\n            }\n            this.subs.push(() => {\n                this.clearTimeoutFn(timer);\n            });\n        }\n    }\n    /**\n     * Called upon successful reconnect.\n     *\n     * @private\n     */\n    onreconnect() {\n        const attempt = this.backoff.attempts;\n        this._reconnecting = false;\n        this.backoff.reset();\n        this.emitReserved(\"reconnect\", attempt);\n    }\n}\n","import { url } from \"./url.js\";\nimport { Manager } from \"./manager.js\";\nimport { Socket } from \"./socket.js\";\n/**\n * Managers cache.\n */\nconst cache = {};\nfunction lookup(uri, opts) {\n    if (typeof uri === \"object\") {\n        opts = uri;\n        uri = undefined;\n    }\n    opts = opts || {};\n    const parsed = url(uri, opts.path || \"/socket.io\");\n    const source = parsed.source;\n    const id = parsed.id;\n    const path = parsed.path;\n    const sameNamespace = cache[id] && path in cache[id][\"nsps\"];\n    const newConnection = opts.forceNew ||\n        opts[\"force new connection\"] ||\n        false === opts.multiplex ||\n        sameNamespace;\n    let io;\n    if (newConnection) {\n        io = new Manager(source, opts);\n    }\n    else {\n        if (!cache[id]) {\n            cache[id] = new Manager(source, opts);\n        }\n        io = cache[id];\n    }\n    if (parsed.query && !opts.query) {\n        opts.query = parsed.queryKey;\n    }\n    return io.socket(parsed.path, opts);\n}\n// so that \"lookup\" can be used both as a function (e.g. `io(...)`) and as a\n// namespace (e.g. `io.connect(...)`), for backward compatibility\nObject.assign(lookup, {\n    Manager,\n    Socket,\n    io: lookup,\n    connect: lookup,\n});\n/**\n * Protocol version.\n *\n * @public\n */\nexport { protocol } from \"socket.io-parser\";\n/**\n * Expose constructors for standalone build.\n *\n * @public\n */\nexport { Manager, Socket, lookup as io, lookup as connect, lookup as default, };\n","/**\r\n * 簡単なペイントアプリケーション\r\n *  ペイントチャットでの活用を考慮している．\r\n */\r\n// CSSの定義を読み込む．\r\nimport '../css/Paint.css';\r\n\r\nimport { useState, useRef, useImperativeHandle, forwardRef } from 'react';\r\n\r\nexport const Paint = forwardRef(({\r\n  // canvasの大きさのデフォルト値\r\n  width = 300, height = 200,\r\n  // canvasの描画コンテキストの指定\r\n  lineCap = 'round',\r\n  lineJoin = 'round',\r\n  lineColor = '#ff0000', // penColorの初期値\r\n  lineWidth = 1, // penSizeの初期値\r\n  // ペイントチャットで使用する時，関数を指定する．\r\n  drawLine, clearCanvas }, ref) => {\r\n\r\n  // canvas要素へのref\r\n  const canvasRef = useRef(null);\r\n  // 最後に描いた線の終点（次に描く線の始点）\r\n  const lastPosRef = useRef(null);\r\n  // ペンの色\r\n  const [penColor, setPenColor] = useState(lineColor);\r\n  // ペンのサイズ\r\n  const [penSize, setPenSize] = useState(lineWidth);\r\n\r\n  // ペンの色を変更する．\r\n  const changeColor = (event) => {\r\n    setPenColor(event.target.value);\r\n  };\r\n\r\n  // ペンのサイズを変更する．\r\n  const changePenSize = (event) => {\r\n    setPenSize(event.target.value);\r\n  };\r\n\r\n  /// Canvasに線を描く\r\n  // マウスイベントの座標をCanvas内の座標に変換する．\r\n  const getCoords = (event) => {\r\n    const canvas = canvasRef.current;\r\n    const rect = canvas.getBoundingClientRect();\r\n    const style = getComputedStyle(canvas);\r\n    const bleft = parseFloat(style.borderLeftWidth);\r\n    const btop = parseFloat(style.borderTopWidth);\r\n    const pleft = parseFloat(style.paddingLeft);\r\n    const ptop = parseFloat(style.paddingTop);\r\n    const offsetX = rect.left + bleft + pleft;\r\n    const offsetY = rect.top + btop + ptop;\r\n    const posx = event.clientX - offsetX;\r\n    const posy = event.clientY - offsetY;\r\n    // Canvasが拡大・縮小表示されている場合の補正を行う．\r\n    const bright = parseFloat(style.borderRightWidth);\r\n    const bbottom = parseFloat(style.borderBottomWidth);\r\n    const pright = parseFloat(style.paddingRight);\r\n    const pbottom = parseFloat(style.paddingBottom);\r\n    const x = posx * canvas.width / (rect.width - (bleft + bright + pleft + pright));\r\n    const y = posy * canvas.height / (rect.height - (btop + bbottom + ptop + pbottom));\r\n    return { x, y };\r\n  };\r\n\r\n  // mousedownのイベントリスナー\r\n  const mousedown = (event) => {\r\n    // 描画モードに入る．\r\n    // canvas要素外にマウスが動くことも想定し，documentに対して，mousemoveとmouseupのイベントリスナーを設定する．\r\n    document.addEventListener('mousemove', mousemove, false);\r\n    document.addEventListener('mouseup', mouseup, false);\r\n    // ブラウザによってはテキスト選択が始まるのを防ぐ．\r\n    event.preventDefault();\r\n    // マウスが押された座標を記録しておく．\r\n    const pos = getCoords(event);\r\n    lastPosRef.current = pos;\r\n  };\r\n\r\n  // mousemoveのイベントリスナー\r\n  const mousemove = (event) => {\r\n    const pos = getCoords(event);\r\n    // lastPosから現在のマウスの位置まで線を描く．\r\n    drawLine(\r\n      lastPosRef.current.x,\r\n      lastPosRef.current.y,\r\n      pos.x,\r\n      pos.y,\r\n      penColor,\r\n      penSize\r\n    );\r\n    // lastPosを更新する．\r\n    lastPosRef.current = pos;\r\n  };\r\n\r\n  // mouseupのイベントリスナー\r\n  const mouseup = () => {\r\n    // mousemoveとmouseupのイベントリスナーを削除し，描画モードを抜ける．\r\n    document.removeEventListener('mousemove', mousemove, false);\r\n    document.removeEventListener('mouseup', mouseup, false);\r\n  };\r\n\r\n  // (x0, y0) から (x1, y1)まで線を描く．\r\n  const drawLineInternal = (x0, y0, x1, y1, color, size) => {\r\n    const ctx = canvasRef.current.getContext('2d');\r\n    ctx.save();\r\n    ctx.lineCap = lineCap;\r\n    ctx.lineJoin = lineJoin;\r\n    ctx.strokeStyle = color;\r\n    ctx.lineWidth = size;\r\n    ctx.beginPath();\r\n    ctx.moveTo(x0, y0);\r\n    ctx.lineTo(x1, y1);\r\n    ctx.stroke();\r\n    ctx.restore();\r\n  };\r\n\r\n  // drawLineが指定されていない時は，drawLineInternalに設定する．\r\n  if (!drawLine) {\r\n    drawLine = drawLineInternal;\r\n  }\r\n\r\n  /// Canvasのクリア\r\n  const clearCanvasInternal = () => {\r\n    const canvas = canvasRef.current;\r\n    const ctx = canvas.getContext('2d');\r\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n  };\r\n\r\n  // clearCanvasが指定されていない時は，clearCanvasInternalに設定する．\r\n  if (!clearCanvas) {\r\n    clearCanvas = clearCanvasInternal;\r\n  }\r\n\r\n  /// コンポーネントの外から呼び出せるメソッドを定義する．\r\n  // drawLineとclearCanvasを対象とする\r\n  useImperativeHandle(ref, () => {\r\n    return {\r\n      drawLine: drawLineInternal,\r\n      clearCanvas: clearCanvasInternal\r\n    };\r\n  }, []);\r\n\r\n  // 画像の取得\r\n  const getImageDataURL = () => {\r\n    return canvasRef.current.toDataURL();\r\n  };\r\n  // 画像の設定\r\n  const putImageDataURL = (dataURL) => {\r\n    const image = new Image();\r\n    image.onload = () => {\r\n      const ctx = canvasRef.current.getContext('2d');\r\n      ctx.drawImage(image, 0, 0);\r\n    };\r\n    image.src = dataURL;\r\n  };\r\n\r\n  // コンポーネントの外から呼び出せるメソッドを定義する．\r\n  useImperativeHandle(ref, () => {\r\n    return {\r\n      drawLine: drawLineInternal,\r\n      clearCanvas: clearCanvasInternal,\r\n      getImageDataURL: getImageDataURL,\r\n      putImageDataURL: putImageDataURL\r\n    };\r\n  }, []);\r\n\r\n  return (\r\n    <div className=\"paint\">\r\n      <canvas ref={canvasRef} onMouseDown={mousedown} width={width} height={height} />\r\n      <div className=\"paint-control\">\r\n        <label>\r\n          色\r\n          <input type=\"color\" value={penColor} onChange={changeColor} />\r\n        </label>\r\n        <label>\r\n          ペンサイズ\r\n          <input type=\"number\" min={1} max={9}\r\n            onChange={changePenSize} value={penSize} />\r\n        </label>\r\n        <button type=\"button\" onClick={clearCanvas}>\r\n          クリア\r\n        </button>\r\n      </div>\r\n    </div>\r\n  );\r\n});\r\n"],"names":["$parcel$export","e","n","v","s","Object","defineProperty","get","set","enumerable","configurable","$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","parcelRegister","$97f767c3b2093b90$export$86edbdc9a1e29ae8","$97f767c3b2093b90$export$40a57a2074eac373","$c54Ow","$anUZ9","$lbJE2","$brsYM","createContext","props","socketRef","useRef","connected","setConnected","useState","errorMessage","setErrorMessage","user","useContext","LoginContext","openSocket","authHeader","auth","token","username","current","connect","socket","io","nsp","reconnection","on","error","message","reason","closeSocket","close","useEffect","jsxs","className","children","jsx","type","onClick","Provider","value","factory","_typeof","obj","Symbol","iterator","constructor","prototype","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","i","length","descriptor","writable","_toPropertyKey","arg","key","_toPrimitive","input","hint","prim","toPrimitive","undefined","res","String","Number","_createClass","protoProps","staticProps","_extends","assign","bind","arguments","source","hasOwnProperty","apply","_inherits","subClass","superClass","create","_setPrototypeOf","_getPrototypeOf","o","setPrototypeOf","getPrototypeOf","__proto__","p","_isNativeReflectConstruct","Reflect","construct","sham","Proxy","Boolean","valueOf","_construct","Parent","args","Class","a","push","Function","_wrapNativeSuper","_cache","Map","toString","indexOf","has","Wrapper","_assertThisInitialized","self1","ReferenceError","_createSuper","Derived","hasNativeReflectConstruct","result","Super","_possibleConstructorReturn","_get","property","receiver","base","_superPropBase","object","desc","getOwnPropertyDescriptor","_arrayLikeToArray","arr","len","arr2","Array","_createForOfIteratorHelper","allowArrayLike","it","isArray","_unsupportedIterableToArray","minLen","slice","name","from","test","F","done","f","normalCompletion","didErr","step","next","return","PacketType","PACKET_TYPES","PACKET_TYPES_REVERSE","keys","forEach","ERROR_PACKET","data","withNativeBlob$1","Blob","withNativeArrayBuffer$2","ArrayBuffer","isView$1","isView","buffer","encodePacket","_ref","supportsBinary","callback","encodeBlobAsBase64","fileReader","FileReader","onload","content","split","readAsDataURL","toArray","Uint8Array","byteOffset","byteLength","chars","lookup$1","i$1","charCodeAt","decode$1","base64","encoded1","encoded2","encoded3","encoded4","bufferLength","arraybuffer","bytes","withNativeArrayBuffer$1","decodePacket","encodedPacket","binaryType","mapBinary","charAt","decodeBase64Packet","substring","encodePayload","packets","encodedPackets","count","packet","join","decodePayload","encodedPayload","decodedPacket","totalLength","chunks","reduce","acc","chunk","concatChunks","size","shift","j","Emitter","mixin","addEventListener","event","fn","_callbacks","once","off","removeListener","removeAllListeners","removeEventListener","cb","callbacks","splice","emit","emitReserved","listeners","hasListeners","globalThisShim","self","window","pick","_len","attr","_key","k","NATIVE_SET_TIMEOUT","setTimeout","NATIVE_CLEAR_TIMEOUT","clearTimeout","installTimerFunctions","opts","useNativeTimers","setTimeoutFn","clearTimeoutFn","TEXT_ENCODER","TEXT_DECODER","prev","TransportError","_Error","_super","description","context","_this","Transport","_Emitter","_super2","_this2","query","readyState","doOpen","doClose","onClose","write","onPacket","details","onPause","schema","_hostname","_port","path","_query","hostname","port","secure","encodedQuery","encode$1","str","encodeURIComponent","alphabet","map","seed","encode","num","encoded","Math","floor","yeast","now","Date","XMLHttpRequest","hasCORS","XHR","xdomain","concat","empty","hasXHR2","xhr","responseType","Polling","_Transport","polling","location","isSSL","protocol","xd","forceBase64","withCredentials","cookieJar","poll","pause","total","doPoll","_this3","onOpen","_this4","_this5","doWrite","timestampRequests","timestampParam","sid","b64","createUri","Request","uri","_this6","req","request","method","xhrStatus","onError","_this7","onData","pollXhr","_this8","_a","_this9","open","extraHeaders","setDisableHeaderCheck","setRequestHeader","addCookies","requestTimeout","timeout","onreadystatechange","parseCookies","status","onLoad","send","document","index","requestsCount","requests","cleanup","fromError","abort","responseText","unloadHandler","attachEvent","nextTick","Promise","resolve","then","WebSocket","MozWebSocket","isReactNative","navigator","product","toLowerCase","transports","websocket","WS","check","protocols","headers","ws","usingBrowserWebSocket","addEventListeners","onopen","autoUnref","_socket","unref","onclose","closeEvent","onmessage","ev","onerror","_loop","lastPacket","webtransport","WT","WebTransport","transport","transportOptions","closed","ready","createBidirectionalStream","stream","maxPayload","state","expectedLength","isBinary","decoderStream","MAX_SAFE_INTEGER","TextDecoder","TransformStream","transform","controller","header","headerArray","DataView","getUint16","_headerArray","view","getUint32","enqueue","decode","reader","readable","pipeThrough","getReader","encoderStream","payloadLength","setUint8","setUint16","_view","setBigUint64","BigInt","arrayBuffer","TextEncoder","pipeTo","writer","getWriter","read","re","parts","parse","names","src","b","replace","m","exec","host","authority","ipv6uri","pathNames","queryKey","$0","$1","$2","Socket$1","Socket","writeBuffer","prevBufferLen","agent","upgrade","rememberUpgrade","addTrailingSlash","rejectUnauthorized","perMessageDeflate","threshold","closeOnBeforeunload","qs","qry","pairs","l","pair","decodeURIComponent","upgrades","pingInterval","pingTimeout","pingTimeoutTimer","beforeunloadEventListener","offlineEventListener","EIO","priorWebsocketSuccess","createTransport","setTransport","onDrain","failed","onTransportOpen","msg","upgrading","flush","freezeTransport","onTransportClose","onupgrade","to","probe","resetPingTimeout","onHandshake","JSON","sendPacket","filterUpgrades","getWritablePackets","payloadSize","utf8Length","c","ceil","options","compress","cleanupAndClose","waitForUpgrade","filteredUpgrades","withNativeArrayBuffer","withNativeBlob","withNativeFile","File","RESERVED_EVENTS$1","Encoder","replacer","EVENT","ACK","hasBinary","toJSON","encodeAsBinary","BINARY_EVENT","BINARY_ACK","encodeAsString","attachments","stringify","buffers","packetData","deconstruction","pack","_deconstructPacket","placeholder","_placeholder","newData","_newData","unshift","isObject","Decoder","reviver","reconstructor","isBinaryEvent","decodeString","BinaryReconstructor","takeBinaryData","start","buf","_start","_start2","_c","payload","tryParse","substr","isPayloadValid","finishedReconstruction","CONNECT","DISCONNECT","CONNECT_ERROR","reconPack","binData","_reconstructPacket","parser","freeze","RESERVED_EVENTS","connect_error","disconnect","disconnecting","newListener","recovered","receiveBuffer","sendBuffer","_queue","_queueSeq","ids","acks","flags","_opts","_autoConnect","subs","onpacket","subEvents","_readyState","_len2","_key2","retries","fromQueue","_addToQueue","ack","pop","_registerAckCallback","isTransportWritable","engine","notifyOutgoingListeners","ackTimeout","timer","_len3","_key3","withError","_len4","_key4","reject","arg1","arg2","tryCount","pending","_len5","responseArgs","_key5","_drainQueue","force","_packet","_sendConnectPacket","_pid","pid","offset","_lastOffset","_clearAcks","some","onconnect","onevent","onack","ondisconnect","destroy","emitEvent","_anyListeners","_step","_iterator","listener","sent","_len6","_key6","emitBuffered","subDestroy","_compress","_timeout","_anyOutgoingListeners","_step2","_iterator2","Backoff","ms","min","max","factor","jitter","attempts","duration","pow","rand","random","deviation","reset","setMin","setMax","setJitter","Manager","nsps","reconnectionAttempts","Infinity","reconnectionDelay","reconnectionDelayMax","randomizationFactor","backoff","_parser","encoder","decoder","autoConnect","_reconnection","_reconnectionAttempts","_reconnectionDelay","_randomizationFactor","_reconnectionDelayMax","_reconnecting","reconnect","skipReconnect","openSubDestroy","maybeReconnectOnOpen","errorSub","onping","ondata","ondecoded","add","active","_i","_nsps","_close","delay","onreconnect","attempt","cache","lookup","parsed","url","loc","ipv6","href","sameNamespace","forceNew","multiplex","$c9a0f875e10d7256$export$fbe17ae5b75efa7","forwardRef","width","height","lineCap","lineJoin","lineColor","lineWidth","drawLine","clearCanvas","ref","canvasRef","lastPosRef","penColor","setPenColor","penSize","setPenSize","getCoords","canvas","rect","getBoundingClientRect","style","getComputedStyle","bleft","parseFloat","borderLeftWidth","btop","borderTopWidth","pleft","paddingLeft","ptop","paddingTop","offsetX","left","offsetY","top","posx","clientX","posy","clientY","bright","borderRightWidth","bbottom","borderBottomWidth","pright","paddingRight","pbottom","paddingBottom","x","y","mousemove","pos","mouseup","drawLineInternal","x0","y0","x1","y1","color","ctx","getContext","save","strokeStyle","beginPath","moveTo","lineTo","stroke","restore","clearCanvasInternal","clearRect","useImperativeHandle","getImageDataURL","toDataURL","putImageDataURL","dataURL","image","Image","drawImage","onMouseDown","preventDefault","onChange","encodePacketToBinary","packetType","decoded","SEPARATOR","fromCharCode","createPacketEncoderStream","createPacketDecoderStream","BASE64_OVERHEAD","createCookieJar","terminationEvent","isPromiseAvailable","defaultBinaryType","regx","shouldCheckPayloadSize","deconstructPacket","reconstructPacket","isIndexValid","discardPacket","emitWithAck","hasError","isBuffered","onAny","prependAny","offAny","listenersAny","onAnyOutgoing","prependAnyOutgoing","offAnyOutgoing","listenersAnyOutgoing","Engine","_destroy","newConnection"],"version":3,"file":"report02.93fe4c56.js.map"}